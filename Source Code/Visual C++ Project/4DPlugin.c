/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source skeleton generated by 4D Plugin Wizard
 #	Project : Win32API
 #	author :  dcompton & dschilling
 #	6/21/2001
 #
 # --------------------------------------------------------------------------------*/

//
//	04/16/02 Replaced Plugin API 671 with 672.  Made modifications to 
//						672 for compatibility with 4D 6.5
//
//	08/23/02 Replaced Plugin API 672 with 681.  Made modifications for 
//						compatibility with 4D 6.5 (Win32API release version 3.5)
//	09/04/02 Corrected version flag in 4DPluginAPI.c.  Added sys_IsAppLoaded for 
//						version release 3.5.1
//
//	IMPORTANT: The 4DPluginAPI.c code has been modified to be backwards compatible with pre 6.7
//	IMPORTANT		4D.  Only functions that necaessry for the Win32API plugin have been modified.
//	IMPORTANT		Other functions may require modification if used in Win32API.
//	IMPORTANT		If compatibility with pre-6.7 4D is required, DO NOT replace 4DPluginAPI.c 
//	IMPORTANT		without first comparing and copying code modifications from the modified 672. 


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include <string.h>
#include <stdio.h>
#include <commdlg.h>
#include <commctrl.h> 
#include <rpc.h>
#include <IphlpApi.h> //req'd for sys_GetRoutes
#include <time.h> // req'd for sys_GetOCTOffset
#include <sys/timeb.h> // req'd for sys_GetOCTOffset
#include <winspool.h>
#include "PrivateTypes.h"
#include "EntryPoints.h"
#include "EZTWAIN.h" // REB 6/23/09 #14151
#include "TWAIN.h" // REB 6/23/09 #14151
#include "utilities.h" // REB 3/28/11 #25290
#include "process.h" // REB 2/25/13 #35165

char		g_methodText[255]; // holds method name to execute on tool tip action
char		intrProcStr1[MAX_PATH], intrProcStr2[MAX_PATH];
BOOL		g_bDragFull;
pLL			startOfList = NULL; // unordered linked list for restictWindow
HANDLE		hSubclassMutex;  // MJG 3/26/04
BOOL		g_FolderSelected;  // MJG 6/15/05
char		pathName[512]; // MWD 10/21/05 #9246 holds path to Win32API.4DX
LPCWSTR		KEY_DisableTaskMgr = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System";
LPCWSTR		VAL_DisableTaskMgr = "DisableTaskMgr";
LONG_PTR	windowStyle = 0; // REB 3/11/10 #23109 To hold the default window style.

struct		HOOKHANDLES
{
	HHOOK		openSaveHookHndl;
	HHOOK		printSettingsHookHndl;
	HHOOK		printHookHndl;
	HHOOK		postProcHookHndl;
	HHOOK		systemMsgHook; // used to hook window for tool tips
	HHOOK		keyboardLLHook; // REB 1/8/10 #22389 Handles low level keyboard events.
} hookHandles;

HANDLE		g_parentHndl;// dialog handle used in Open/Save functions

struct		WINDOWHANDLES
{
	HWND		fourDhWnd; // 4D main window
	HWND		prtSettingshWnd; // handle your print settings dialog
	HWND		prthWnd; // handle to print dialog
	HWND		MDIhWnd;
	HWND		hwndTT; // used for tool tips
	HWND		displayedTTOwnerhwnd; // used for tool tips
	HWND		openSaveTBhwnd; // used in Open/Save dialog
	HWND		MDIs_4DhWnd; // window to get class for all 4D windows (ProToolsSubMDIWndClass)
} windowHandles;

struct		PROCESSHANDLES
{
	WNDPROC		wpFourDOrigProc; // used for tray icon subclass
	WNDPROC		wpPrintSettingsDlgOrigProc; // used for subclassing Print Settings Dialog
	WNDPROC		wpPrintDlgOrigProc; // used for subclassing Print Dialog
	WNDPROC		wpProToolsOrigProc; // used for subclassing ALL 4D windows
} processHandles;

INT_PTR				FD_Flags; // used for open file dialog
INT_PTR				g_intrProcMsg = PS_IDLE;

struct		PRINTSETTINGS
{
	char		printerSelection[80];
	char		size[80];
	char		source[80];
	LONG_PTR		portraitLandscape;
	char		copies[10];
	BOOL		printPreview;
	BOOL		printToFile;
} printerSettings;

// various flags used to know what feature/functions are living call to call
struct		ACTIVECALLS
{
	BOOL		bPrinterCapture;
	BOOL		bTrayIcons;
	BOOL		b4DMaximize; //01/21/03
} activeCalls;

//added 01/17/03 see 4DPlugin082102.c

// REB 4/7/09 #19472
typedef struct _REG_TZI_FORMAT
{
    LONG Bias;
    LONG StandardBias;
    LONG DaylightBias;
    SYSTEMTIME StandardDate;
    SYSTEMTIME DaylightDate;
} REG_TZI_FORMAT;





extern struct		TOOLBARRESTRICT
{
	LONG_PTR		toolBarOnDeck;
	LONG_PTR		top;
	LONG_PTR		left;
	LONG_PTR		right;
	LONG_PTR		bottom;
	INT_PTR			topProcessNbr;
	INT_PTR			leftProcessNbr;
	INT_PTR			rightProcessNbr;
	INT_PTR			bottomProcessNbr;
	LONG_PTR		trackingRestriction;
	LONG_PTR		appBeingMaxed;
	LONG_PTR		appWindowState;
	RECT		origWindowRect;
	LONG_PTR		clientOffsetx;
	LONG_PTR		clientOffsety;
	char		minimizedWindows[SMLBUF][SMLBUF]; // REB 8/11/08 #16207 
	RECT		previousWindowRect; // REB 3/26/10
} toolBarRestrictions;


// REB 2/26/13 #35165 Structure to communicate with the helper thread
typedef struct	_TWAIN_CAPTURE
{
	LONG_PTR	returnValue;
	HANDLE		DIBHandle;
	BOOL		done;

} TWAIN_CAPTURE;


// MWD 10/21/05 #9246
// Use the DllMain function to get the path to the calling DLL and store it in a global for further use.
#if WIN32
#ifdef _cplusplus
extern "C" __declspec(dllexport) {
#endif
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  BOOL result = TRUE;
  char fullpath[512] = "";
  GetModuleFileName(hinstDLL, fullpath, sizeof (fullpath)); // Get the path to the 4DX
  strcpy((char *)pathName, (char *)fullpath);
  return result;
}
#ifdef _cplusplus
}
#endif
#endif


void PluginMain( LONG_PTR selector, PA_PluginParameters params )
{

	HWND				hWnd, NexthWnd;
	PA_Unistring		Unistring;
	char				*pathName, *charPos;
	char			WindowName[255];
	char			szClassName[255];

	switch( selector )
	{
// --- Win32API Commands


		case kInitPlugin :
		case kServerInitPlugin:

			// get MDI & parent window on init 4/15/02
			// REB 2/20/09 #19122 Use new method to get handles.  PA_GetHWND(0) does not work in v11 like it did in previous version.
			// REB 3/24/10 It appears that PA_GetHWND(0) works again, at least in Win7, but I'm leaving this change in place.
			// REB 4/20/11 #27322 Support for the GetMainWindow and GetMDIClientWindow commands is no longer available in the new 4D API. Also PA_GetHWND seems to not work when
			//    there is no focused window in 4D.  Instead I'll use the server workaround.

			// This logic fails if there is a separate application running that returns the same value from GetClassLongPtr as PA_Get4DHInstance returns.
			/*
			h = (HINSTANCE)PA_Get4DHInstance(); 
			hWnd = NULL; 
      
			w = FindWindow(NULL, NULL); 
			      
			do { 
			 if(!GetParent(w)){ 
				  if(h == (HINSTANCE)GetClassLongPtr(w, GCLP_HMODULE)){ 
				     hWnd = w; 
					 break; 
				 } 
				} 
          
				w = GetWindow(w, GW_HWNDNEXT); 
          
		   } while (w); 
      
			windowHandles.MDIs_4DhWnd = w; 

			*/

			// REB 11/2/12 #34333
			Unistring = PA_GetApplicationFullPath();
			pathName = UnistringToCString(&Unistring);
			charPos = strrchr(pathName,'\\');
			*charPos = 0;
			windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);
			
			NexthWnd = GetWindow(windowHandles.fourDhWnd,GW_CHILD);
			do {
				if(IsWindow(NexthWnd)){
					GetWindowText(NexthWnd,WindowName,255);
					GetClassName(NexthWnd, szClassName, 255);
					if (strcmp(_strlwr(szClassName), "mdiclient") == 0){
						//windowHandles.MDIs_4DhWnd =  NexthWnd; // AMS 8/12/14 #39693 This was not the correct handle to use for the MDI Client. It was causing toolbars to work incorrectly.  
						windowHandles.MDIhWnd = NexthWnd; // AMS 8/12/14 #39693 This is the correct handle for the MDI Client.
						break;
					}
					NexthWnd = GetNextWindow(NexthWnd,GW_HWNDNEXT);
				}
			} while(IsWindow(NexthWnd));
		



			//windowHandles.fourDhWnd = GetMainWindow();
			//windowHandles.MDIhWnd = GetMDIClientWindow();
			// REB 8/30/11 #28504 We already have this handle now.
			windowHandles.MDIs_4DhWnd = GetWindow(windowHandles.MDIhWnd, GW_CHILD); //REB 3/26/10 #22878 Get the correct child handle so toolbars work correctly. // AMS 8/12/14 #39693 Uncommented this line. This line is still needed in order for tollbars to work correctly.

			SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &g_bDragFull, 0);
			hSubclassMutex = CreateMutex(NULL, FALSE, "Win32APIMutexToProtect4DProc");  // MJG 3/26/04
	
			break;

		case kDeinitPlugin :
			if (!PA_Is4DServer()) {
				gui_LoadBackground( params, TRUE); // true signifies closing subclassed window
				SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, g_bDragFull, NULL, 0);
				if (hookHandles.systemMsgHook != NULL) {
					UnhookWindowsHookEx(hookHandles.systemMsgHook);
				}
				clear_list(&startOfList);
				restoreOrig4DWindowProcess(); // MJG 3/26/04
			}
			CloseHandle(hSubclassMutex); // MJG 3/26/04
			// REB 1/8/10 #22389
			// REB 12/10/12 #34565
			//sys_EnableTaskManager( params );
			//gui_ShowTaskBar( params );
			//gui_ShowTitleBar( params );
			//gui_SetMDIOpaque( params );
			break;

		case 1 :
		  //Blk4D.fHandle = NULL;  OBSOLETE
		  //Call4D (EX_GET_HWND, &Blk4D);
		  //hWnd = (HWND)Blk4D.fHandle;
			hWnd = PA_GetHWND(NULL); // the current frontmost window
			if(!(IsWindow(hWnd))){
			// Always get the frontmost window in this way.
				 //Unistring = PA_GetApplicationFullPath();
				 //pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
				 //charPos = strrchr(pathName,'\\');
				 //*charPos = 0;
				 //hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
				if(!(IsWindow(windowHandles.MDIs_4DhWnd))){
					Unistring = PA_GetApplicationFullPath();
					pathName = UnistringToCString(&Unistring);
					charPos = strrchr(pathName,'\\');
					*charPos = 0;
					windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);
			
					NexthWnd = GetWindow(windowHandles.fourDhWnd,GW_CHILD);
					do {
						if(IsWindow(NexthWnd)){
							GetWindowText(NexthWnd,WindowName,255);
							GetClassName(NexthWnd, szClassName, 255);
							if (strcmp(_strlwr(szClassName), "mdiclient") == 0){
								windowHandles.MDIs_4DhWnd =  NexthWnd;
								break;
							}
							NexthWnd = GetNextWindow(NexthWnd,GW_HWNDNEXT);
						}
					} while(IsWindow(NexthWnd));

				}
				 hWnd = windowHandles.MDIs_4DhWnd;
			}//else{
				//hWnd = PA_GetHWND(NULL); // the current frontmost window
			//}
		
			// while this is all we need to get frontmost window, we are probably looking for a titled window
			gui_GetWindow( params, hWnd );
			
			break;

		case 2 :
			gui_GetWndRect( params );
			break;

		case 3 :
			gui_SetWndRect( params );
			break;

		case 4 :
			gui_ShowWindow( params );
			break;

		case 5 :
			sys_GetUserName( params );
			break;

		case 6 :
			gui_SetWindowTitle( params );
			break;

		case 7 :
			sys_IsMultiByte( params );
			break;

		case 8 :
			gui_DisableCloseBox( params );
			break;

		case 9 :
			gui_SetWindowLong( params );
			break;

		case 10 :
			gui_FlashWindow( params );
			break;

		case 11 :
			gui_WinHelp( params );
			break;

		case 12 :
			sys_GetDefPrinter( params );
			break;

		case 13 :
			sys_SetDefPrinter( params );
			break;

		case 14 :
			sys_EnumPrinters( params ); 
			break;

		case 15 :
			gui_DelMenuItem( params );
			break;

		case 16 :
			gui_GetOpenFileName( params );
			break;

		case 17 :
			gui_GetSaveFileName( params );
			break;

		case 18 :
			gui_LoadIcon( params );
			break;

		case 19 :
			gui_SetIcon( params );
			break;

		case 20 :
			gui_GetWindowFrom4DWin( params );
			break;

		case 21 :
			sys_GetRegionSettings( params, TRUE );
			break;

		case 22 :
			sys_GetTimeZone( params );
			break;

		case 23 :
			sys_GetUTCOffset( params );
			break;

		case 24 :
			gui_GetDisplayFontDPI( params );
			break;

		case 25 :
			sys_GetRegionSettings( params, FALSE ); // sys_GetOneRegionSetting -- uses same code as GetRegionSettings
			break;

		case 26 :
			sys_GetPrintJob( params );
			break;

		case 27 :
			sys_GetGUID( params );
			break;

		case 28 :
			sys_GetRoutes( params );
			break;

		case 29 :
			sys_GetNetworkInfo( params );
			break;
			
		case 30 :
			sys_GetOSVersion( 0, params ); // first param is 0 if called as plugin call
			break;

		case 31 :
			sys_PlayWav( params );
			break;

		case 32 :
			sys_GetWindowMetrics( params );
			break;

		case 33 :
			gui_LoadBackground( params, FALSE );
			break;

		case 34 :
			sys_SetClientTime( params );
			break;

		case 35 :
			sys_SetClientDate( params );
			break;

		case 36 :
			gui_ToolTipCreate( params );
			break;

		case 37 :
			gui_ToolTipShowOnObject( params );
			break;

		case 38 :
			gui_ToolTipShowOnCoord( params );
			break;

		case 39 :
			gui_ToolTipHide( params );
			break;

		case 40 :
			gui_ToolTipDestroyControl( params );
			break;

		case 41 :
			gui_SetTrayIcon( params );
			break;

		case 42 :
			sys_FileCheck( params );
			break;
	
		case 43 :
			sys_GetCommandLine( params );
			break;

		case 44 :
			gui_RestrictWindow( params );
			break;

		case 45 :
			gui_GetWindowStyle( params );
			break;

		case 46 :
			gui_GetWindowState( params );
			break;

		case 47 :
			gui_SubClassInit( params );
			break;

		case 48 :
			sys_ShellExecute( params );
			break;

		case 49 :
			sys_IsAppLoaded( params );
			break;

		case 50 :
			gui_SelectColor( params );
			break;

	    case 51 :
			gui_RespectToolBar( params );
			break;

		case 52:
			sys_IsConnectedToInternet( params );
			break;

		case 53:
			gui_GetSysColor( params );
			break;

		case 54:
			gui_SetSysColor( params );
			break;

		case 55:
			sys_GetEnv( params );
			break;

		case 56:
			sys_SetEnv( params );
			break;

		case 57:
		case 58:
		case 59:
		case 60:
			sys_GetRegKey( params );
			break;

		case 61:
			sys_GetRegType( params );
			break;

		case 62:
			sys_GetRegEnum( params );
			break;

		case 63:
			sys_GetDocumentList( params );
			break;

		case 64:
			sys_SetPluginLanguage( params );
			break;

		case 65:
			gui_SetWindowStyle( params );
			break;

		case 66:
			sys_FileExists( params );
			break;

		case 67:
			sys_DirectoryExists( params );
			break;

	  // MWD 8/15/06 #10250
		// Enable USB Label Printing
		case 68:
			sys_PrintDirect2Driver(params);
			break;

		case 69:
			sys_KillProcessByName(params);
			break;

		case 70:
			sys_KillProcessByID(params);
			break;

		case 71:
			sys_EnumProcesses(params);
			break;

		case 72:
			sys_LogonUser(params);
			break;

		case 73:
			sys_GetTimeZoneList(params); // REB 4/6/09 #19472
			break;

		case 74:
			TWAIN_GetSources(params); // REB 6/23/09 #14151
			break;

		case 75:
			TWAIN_SetSource(params); // REB 6/23/09 #14151
			break;

		case 76:
			TWAIN_AcquireImage(params); // REB 6/23/09 #14151
			break;

		case 77:
			sys_IsAppFrontmost(params); // REB 8/21/09
			break;

		case 78:
			gui_MessageBox(params); // REB 12/3/09
			break;

		case 79:
			gui_SetMDIOpaque (params); // REB 1/8/10 #22389
			break;

		case 80:
			gui_SetMDITransparent (params); // REB 1/8/10 #22389
			break;

		case 81:
			gui_HideTaskBar (params); // REB 1/8/10 #22389
			break;

		case 82:
			gui_ShowTaskBar (params); // REB 1/8/10 #22389
			break;

		case 83:
			gui_HideTitleBar (params); // REB 1/8/10 #22389
			break;

		case 84:
			gui_ShowTitleBar (params); // REB 1/8/10 #22389
			break;

		case 85:
			gui_MaximizeMDI (params); // REB 1/8/10 #22389
			break;

		case 86:
			gui_RestoreMDI (params); // REB 1/8/10 #22389
			break;

		case 87:
			gui_MinimizeMDI (params); // REB 1/8/10 #22389
			break;

		case 88:
			sys_DisableTaskManager (params); // REB 1/8/10 #22389
			break;

		case 89:
			sys_EnableTaskManager (params); // REB 1/8/10 #22389
			break;

		case 90:
		case 91:
		case 92:
		case 93:
			sys_SetRegKey( params, selector ); // REB 11/17/10 #25402
			break;

		case 94:
			sys_IsAppRunningAsService( params ); // REB 1/12/11 #25587
			break;

		case 95:
			sys_CompareBLOBs( params ); // REB 11/9/12 TESTING
			break;

		case 96:
			sys_GetFileVersionInfo( params ); // AMS 2/10/14 #36899
			break;

		case 97:
			sys_GetOSVersionEX( 0, params ); // AMS2 12/5/14 #37816 
			break;

		case 98:
			sys_SendRawPrinterData(params);  // AMS2 12/9/14 #40598
			break;
	}
}

// ------------------------------- Win32API Commands ------------------------------



// ------------------------------------------------
// 
//  FUNCTION: sys_EnumPrinters( PA_PluginParameters params )
//
//  PURPOSE:	Find all printers that a workstation has available
//
//  COMMENTS:	Code modified from a method written by Tomas Restrepo.
//						 http://www.mvps.org/windev/ptk/enumprint.html
//						This module is also called by GetPrintJob.       
//						Gets local and remote printers
//						Returns info in a format suitable for using to set default printer
//
//	MODIFICATIONS: 04/20/02 added optional second param from 4D to 
//									select what is returned, i.e., 
//									0 = complete string based upon OpenPrinter and GetPrinter functions 
//									1 = printer names only (not suitable for using with sys_SetDefPrinter. 
//									2 = printer string built from registry entries for NT/2000/XP and 
//											from Win.ini file for 95/98/Me
//					08/11/09	Removed logic that checks for versions of Windows before 2000.
//
//	DATE:			dcc 07/03/01 
// 
void sys_EnumPrinters( PA_PluginParameters params )
{
	PA_Variable				printerArray;
	LONG_PTR					returnValue = 0, action = 0, defPrinterPosition, lSize = 0;
	DWORD					dwSizeNeeded, cByteNeeded, cByteUsed;
	DWORD					dwNumItems, dwTotalNumPrinters, dwRemoteNumItems = 0;
	DWORD					dwItem;
	LPPRINTER_INFO_1		lpInfo1 = NULL;
	LPPRINTER_INFO_2		lpInfo2 = NULL;
	char					printer_driver_port[255];
	char					printerName[255];
	HANDLE					hPrinter;
	PRINTER_DEFAULTS		ptrDef;
	BOOL					bPrinterSuccess, bNamesOnly = FALSE;

	printerArray = PA_GetVariableParameter( params, 1 );
	PA_ResizeArray (&printerArray, 0); //09/21/01

	action = PA_GetLongParameter( params, 2 );
	switch (action)
	{
		case EP_NAMES_ONLY :
			bNamesOnly = TRUE;
			break;

		case EP_USE_OPEN :
			break;

		case EP_USE_REGISTRY :
			defPrinterPosition = enumPrintersUsingRegistry( &printerArray );

			PA_SetVariableParameter( params, 1, printerArray, 0 );
			PA_ReturnLong( params, defPrinterPosition );
		return;
	}
	
	// Get buffer size for local printers  PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS
	// Combining the two calls to EnumPrinters into a single call.
	EnumPrinters ( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 1, NULL, 0, &dwSizeNeeded, &dwNumItems );

	// allocate memory
	lpInfo1 = (LPPRINTER_INFO_1)HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, dwSizeNeeded );
	if ( lpInfo1 == NULL )
	{
	  returnValue = 0;
    return;
	}

	if ( EnumPrinters ( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,NULL,1,(LPBYTE)lpInfo1,dwSizeNeeded,&dwSizeNeeded,&dwNumItems) == 0 )	{
		// free memory
		HeapFree ( GetProcessHeap (), 0, lpInfo1 );
		returnValue = 0;
		PA_ReturnLong( params, returnValue );
		return;
	}

	PA_ResizeArray (&printerArray, dwNumItems); 

	//localPrinters = PA_CreateVariable( eVK_ArrayString, 255);
	//PA_ResizeArray (&localPrinters, dwNumItems);
	for ( dwItem = 0; dwItem < dwNumItems; dwItem++ )
	{
		strcpy(printerName, lpInfo1[dwItem].pName);
		printerName[strlen(printerName)] = '\0';
		PA_SetTextInArray (printerArray, dwItem+1, printerName, strlen(printerName));
	}
	// free memory
	HeapFree ( GetProcessHeap (), 0, lpInfo1 );
	dwTotalNumPrinters = dwNumItems;
	//dwLocalNumItems = dwNumItems;

	/*
	// Get buffer size for remote printers
	EnumPrinters ( PRINTER_ENUM_CONNECTIONS, NULL, 1, NULL, 0, &dwSizeNeeded, &dwNumItems );

	// allocate memory
	lpInfo1 = (LPPRINTER_INFO_1)HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, dwSizeNeeded );
	if ( lpInfo1 == NULL )
	{
	  returnValue = 0;
    return;
	}

	if ( EnumPrinters ( PRINTER_ENUM_CONNECTIONS,		// what to enumerate
			    NULL,			// printer name (NULL for all)
			    1,				// level
			    (LPBYTE)lpInfo1,		// buffer
			    dwSizeNeeded,		// size of buffer
			    &dwSizeNeeded,		// returns size
			    &dwNumItems			// return num. items
			  ) == 0 )	{
		// free memory
		HeapFree ( GetProcessHeap (), 0, lpInfo1 );
	  returnValue = 0;
	  PA_ReturnLong( params, returnValue );
    return;
	}

	dwRemoteNumItems = dwNumItems;
	if (dwRemoteNumItems) {
		remotePrinters = PA_CreateVariable(eVK_ArrayString, 255);
		PA_ResizeArray (&remotePrinters, dwRemoteNumItems);
		for ( dwItem = 0; dwItem < dwRemoteNumItems; dwItem++ )
		{
			strcpy(printerName, lpInfo1[dwItem].pName);
			printerName[strlen(printerName)] = '\0';
			PA_SetStringInArray (remotePrinters, dwItem + 1, printerName);
		}
		// free memory
		HeapFree ( GetProcessHeap (), 0, lpInfo1 );
		dwTotalNumPrinters += dwRemoteNumItems;
	}
	*/
	//PA_ResizeArray (&printerArray, dwTotalNumPrinters); 
  //sprintf(debugStr,"Number of elements: %d",PA_GetArrayNbElements (printerArray));
	//MessageBox(NULL,debugStr,"Debugging",MB_OK);
	
	// get complete info on each printer	

	ptrDef.pDatatype = NULL;
	ptrDef.pDevMode = NULL;
	ptrDef.DesiredAccess = PRINTER_ACCESS_USE;
	/*
	if (dwLocalNumItems ==0) { // 09/19/01
		ptrPA_Var = &remotePrinters;
		bRemoteOnly = TRUE;
	} else {
		ptrPA_Var = &localPrinters;
		bRemoteOnly = FALSE;
	}
	*/
	//loopOffset = 0;

	for (dwItem = 0; dwItem < dwTotalNumPrinters; dwItem++)
	{
		lSize = PA_GetTextInArray( printerArray, dwItem + 1, printerName);
		printerName[lSize] = '\0';
		strcpy(printer_driver_port, "");

		bPrinterSuccess = OpenPrinter( printerName, &hPrinter, NULL ); //&ptrDef );

		if (bPrinterSuccess){ 
			if (!bNamesOnly) {		
				// Get the buffer size needed 
				if (!GetPrinter(hPrinter, 2, NULL, 0, &cByteNeeded))
				{
					if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
						returnValue = 0;
						bPrinterSuccess = ClosePrinter(hPrinter);
						return;
					}
				}

				lpInfo2 = (PRINTER_INFO_2 *)malloc(cByteNeeded);
				if (!(lpInfo2)) {
					// failure to allocate memory 
					returnValue = 0;
					bPrinterSuccess = ClosePrinter(hPrinter);
					return;
				}

				// get the printer info 
				if (!GetPrinter(hPrinter, 2, (LPSTR)lpInfo2, cByteNeeded, &cByteUsed))
				{
					// failure to access the printer 
					free(lpInfo2);
					lpInfo2 = NULL;
					returnValue = 0;
					bPrinterSuccess = ClosePrinter(hPrinter);
					return;
				}

				strcpy(printer_driver_port, lpInfo2[0].pPrinterName);
				strcat(printer_driver_port, ",");
				strcat(printer_driver_port, lpInfo2[0].pDriverName);
				strcat(printer_driver_port, ",");
				strcat(printer_driver_port, lpInfo2[0].pPortName);
			} else {
				strcpy(printer_driver_port, printerName);
			}

			bPrinterSuccess = ClosePrinter(hPrinter); // REB 10/29/09 #21643 This was not getting closed.

		} else {
			strcpy(printer_driver_port, printerName); // chg made to populate array with name if add'l info can't be retrieved
			if (!bNamesOnly) {
				strcat(printer_driver_port, ": Could Not Open");
			}
		}

		PA_SetTextInArray (printerArray, dwItem + 1, printer_driver_port, strlen(printer_driver_port));
		/*
		if ((dwRemoteNumItems > 0) && (dwItem == (dwLocalNumItems - 1)) && (!bRemoteOnly)) {
			PA_ClearVariable(&localPrinters);
			ptrPA_Var = &remotePrinters;
			loopOffset = (LONG_PTR)dwLocalNumItems * -1; // offset so new array will start at beginning
		}
		*/
		free(lpInfo2);
		lpInfo2 = NULL;
	} //(i = 0, i < dwTotalNumPrinters, i++)

	//free memory
	HeapFree ( GetProcessHeap (), 0, lpInfo2 );
	/*
	if (dwTotalNumPrinters > dwLocalNumItems) {
		PA_ClearVariable(ptrPA_Var);
	}
	*/
	returnValue = dwTotalNumPrinters;

	PA_SetVariableParameter( params, 1, printerArray, 0 );

	PA_ReturnLong( params, returnValue );
}


// ------------------------------------------------
// 
//  FUNCTION: sys_GetPrintJob( PA_PluginParameters params)
//
//  PURPOSE:	Primarily to get what printer was selected for printing
//
//  COMMENTS:	
//	IMPORTANT	NOTE: This an gui_SetTrayIcon use the same subclassed window procedure.
//									You cannot arbitrarily delete the function newProc
//									without breaking tray icons.
//        
//	DATE:			dcc 10/23/01 
//
//	MODIFICATIONS: Rewritten 10/23/01 to improve reliability.  Previous use
//						of spooler had several inadequacies depending on 
//						local, network printers, or print servers.
//						04/15/02 fixed problem when called from dialog box code rather than a form window 
//						11/25/02 fixed problem when Print dialog cancelled and then function called a second time (3.5.3)
void sys_GetPrintJob( PA_PluginParameters params)
{

	LONG_PTR							ret, length;
	LONG_PTR							returnValue = 0, count = 0;
	PA_Variable				        	printer;
	char								windowTitle[] = "", printerName[255], executeCommand[255];
	char								*pComma;
	char								returnString[20];
	LONG_PTR							printerName_len = 255, execCommand_len = 255;
	PA_Unistring						Unistring;
	

	activeCalls.bPrinterCapture							= TRUE;

	hookHandles.printSettingsHookHndl					= NULL;
	hookHandles.printHookHndl							= NULL;
	processHandles.wpPrintDlgOrigProc					= NULL; // 08/08/02
	processHandles.wpPrintSettingsDlgOrigProc = NULL; // 08/08/02

	execCommand_len = PA_GetTextParameter(params, 2, executeCommand);
	executeCommand[execCommand_len] = '\0';
	if (execCommand_len == 0) { // the default is Print Settings
		strcpy(executeCommand, "Print Settings");
		execCommand_len = strlen(executeCommand);
	}
	
	
	//if ((activeCalls.bTrayIcons == FALSE) && (processHandles.wpFourDOrigProc == NULL)) { // same subclassed procedure used for trayIcons
	//	processHandles.wpFourDOrigProc = (WNDPROC) SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) newProc);	
	//}
	subclass4DWindowProcess(); // MJG 3/26/04 Replaced code above with function call.

	g_intrProcMsg = PS_SEARCH;

	// REB 4/20/11 #27322 Conver the C string to a Unistring
	Unistring = CStringToUnistring(&executeCommand);
	PA_ExecuteMethod(&Unistring);
	//PA_ExecuteMethod(executeCommand, execCommand_len);

	printer = PA_GetVariableParameter( params, 1 );

	if (strlen(printerSettings.printerSelection) == 0) {  
		PA_ResizeArray (&printer, 1);
		ret = GetProfileString("windows", "device", ",,,", printerName, printerName_len);
		pComma = strstr(printerName, ",");
		printerName[pComma - printerName] = '\0';
		strcpy(printerSettings.printerSelection, printerName);
		PA_SetTextInArray (printer, 1, printerSettings.printerSelection,
				strlen(printerSettings.printerSelection));
		returnValue = 1;
	} else {

		PA_ResizeArray(&printer, 10);		
		
		PA_SetTextInArray (printer, 1, printerSettings.printerSelection,
				strlen(printerSettings.printerSelection));
		PA_SetTextInArray (printer, 2, printerSettings.size,
				strlen(printerSettings.size));
		PA_SetTextInArray (printer, 3, printerSettings.source,
				strlen(printerSettings.source));
		PA_SetTextInArray (printer, 4, printerSettings.copies,
				strlen(printerSettings.copies));
		if (printerSettings.portraitLandscape == PS_PORTRAIT) {
			strcpy(returnString, "Portrait");
		} else {
			strcpy(returnString, "Landscape");
		}
		PA_SetTextInArray (printer, 5, returnString,
			strlen(returnString));

		if (printerSettings.printToFile == TRUE) {
			strcpy(returnString, "Printed To File");
		} else {
			strcpy(returnString, "");
		}
		PA_SetTextInArray (printer, 6, returnString,
			strlen(returnString));

		if (printerSettings.printPreview == TRUE) {
			strcpy(returnString, "Print Preview");
		} else {
			strcpy(returnString, "");
		}
		PA_SetTextInArray (printer, 7, returnString, strlen(returnString));
		
		returnValue = strlen(printerSettings.printerSelection);
	}

	// restoreOrig4DWindowProcess(); // 01//21/03  // MJG 3/26/04 The 4D window will remain subclassed until the plug-in is unloaded.
	//if (activeCalls.bTrayIcons == FALSE) { // 11/26/02 moved this below if statement
		//SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) processHandles.wpFourDOrigProc);
		//processHandles.wpFourDOrigProc = NULL;
	//}
	if (hookHandles.printSettingsHookHndl != NULL) {
		UnhookWindowsHookEx(hookHandles.printSettingsHookHndl);
		hookHandles.printSettingsHookHndl = NULL; // 08/08/02
	}
	if (hookHandles.printHookHndl != NULL) {
		UnhookWindowsHookEx(hookHandles.printHookHndl);
		hookHandles.printHookHndl = NULL; // 08/08/02
	}

	windowHandles.prthWnd					  = 0;
	windowHandles.prtSettingshWnd			  = NULL;
	processHandles.wpPrintDlgOrigProc		  = NULL; // 08/08/02
	processHandles.wpPrintSettingsDlgOrigProc = NULL; // 08/08/02
	g_intrProcMsg							  = PS_IDLE;
	activeCalls.bPrinterCapture				  = FALSE;

	strcpy(printerSettings.printerSelection, "");
	PA_SetVariableParameter( params, 1, printer, 0 );
	PA_ReturnLong( params, returnValue );

}


// 
//  FUNCTION: sys_GetNetworkInfo( PA_PluginParameters params )
//
//  PURPOSE:	Returns network info 
//
//  COMMENTS:	Only availabel in Windows 98 and Win2K and later
//						NOT NT 3.51 or NT 4
//
//	DATE:			dcc 08/09/01 
//
//  MODIFICATIONS:  04/10/02 made function call into pointer to
//						avoid problems with Win95/NT that may not have IphlpAPI.dll installed.
//						4D cannot resolve this when a direct reference and dll is missing
// 
void	sys_GetNetworkInfo( PA_PluginParameters params )
{
	DWORD					dwFuncReturn;
	LONG_PTR					returnValue = 0;
	char					infoString[255];
	LONG_PTR					infoString_len = strlen(infoString);
	FIXED_INFO		*fixedInfo;
	IP_ADDR_STRING	*pIPAddr;
	ULONG					ulOutBufLen;
	LPFNDLLFUNC2	lpfnDllFunc2;
	HINSTANCE			hDLL;
	

	hDLL = LoadLibrary("IphlpAPI.dll");

	if (hDLL != NULL) {
		lpfnDllFunc2 = (LPFNDLLFUNC2)GetProcAddress(hDLL, "GetNetworkParams");

		if (lpfnDllFunc2) {
			infoString_len = PA_GetTextParameter( params, 1, infoString );
			infoString[infoString_len] = '\0';  // Explicitly set the length

			fixedInfo = (FIXED_INFO *) GlobalAlloc(GPTR, sizeof(FIXED_INFO));
			ulOutBufLen = sizeof(FIXED_INFO);

			if (ERROR_BUFFER_OVERFLOW == lpfnDllFunc2 (fixedInfo, &ulOutBufLen)) {
				GlobalFree(fixedInfo);
				fixedInfo = GlobalAlloc(GPTR, ulOutBufLen);
			}

			if (dwFuncReturn = lpfnDllFunc2(fixedInfo, &ulOutBufLen)) {
				returnValue = 0;
				PA_ReturnLong( params, returnValue );
				return;
			} else {
				returnValue = 1;
				strcpy(infoString, fixedInfo->HostName);
				strcat(infoString, ",");
				strcat(infoString, fixedInfo->DomainName);
				strcat(infoString, ",");
				switch ((UINT)fixedInfo->NodeType)
				{
					case BROADCAST_NODETYPE:
						strcat(infoString, "Broadcast");
						break;
					case PEER_TO_PEER_NODETYPE:
						strcat(infoString, "Peer-to-peer");
						break;
					case MIXED_NODETYPE:
						strcat(infoString, "Mixed");
						break;
					case HYBRID_NODETYPE:
						strcat(infoString, "Hybid");
				}
				strcat(infoString,",");
				switch (fixedInfo->EnableDns)
				{
				case 0:
					strcat(infoString, "DNS No");
					break;
				default:
					strcat(infoString, "DNS Enabled");
				}

				strcat(infoString,",");
				switch (fixedInfo->EnableRouting)
				{
					case 0:
						strcat(infoString, "Routing No");
						break;
					default:
						strcat(infoString, "Routing Enabled");
				}
		
				strcat(infoString,",");
				switch (fixedInfo->EnableProxy)
				{
					case 0:
						strcat(infoString, "Proxy No");
						break;
					default:
						strcat(infoString, "Proxy Enabled");
				}
				if (strlen(fixedInfo->DnsServerList.IpAddress.String) > 0) { 
					strcat(infoString, ",");
					strcat(infoString, fixedInfo->DnsServerList.IpAddress.String);
					pIPAddr = fixedInfo->DnsServerList.Next;
					while (pIPAddr) {
						strcat(infoString, ",");
						strcat(infoString, pIPAddr->IpAddress.String);
						pIPAddr = pIPAddr->Next;
					}
				}
			} //(dwFuncReturn = lpfnDllFunc2(fixedInfo, &ulOutBufLen))

			GlobalFree(fixedInfo);
			PA_SetTextParameter( params, 1, infoString, strlen(infoString) );
		} // (lpfnDllFunc2)
		FreeLibrary(hDLL);
	} //(hDLL != NULL)
	PA_ReturnLong( params, returnValue );

}

// 
//  FUNCTION: sys_GetRoutes( PA_PluginParameters params )
//
//  PURPOSE:	Return IP Route Info 
//
//  COMMENTS:	
//						
//	DATE:			dcc 08/08/01 
// 
//  MODIFICATIONS:  04/10/02 made function call into pointer to
//						avoid problems with Win95/NT that may not have IphlpAPI.dll installed.
//						4D cannot resolve this when a direct reference and dll is missing
//

void	sys_GetRoutes( PA_PluginParameters params )
{
	DWORD					dwFuncReturn;
	LONG_PTR					returnValue = 0, i, tableEntries;
	PA_Variable		table;
	char					routeString[255], numToString[25];
	LONG_PTR					routeString_Len = strlen(routeString);
	ULONG					buffer_len = 0;
	MIB_IPFORWARDTABLE		rtTable;
	PMIB_IPFORWARDTABLE		pTable = &rtTable;
	MIB_IPFORWARDROW			ipRow;
	PMIB_IPFORWARDROW			pRow = &ipRow;
	BOOL					bOrder = FALSE;
	PULONG				pSize = &buffer_len;
	LPFNDLLFUNC3	lpfnDllFunc3;
	HINSTANCE			hDLL;


	hDLL = LoadLibrary("IphlpAPI.dll");

	if (hDLL != NULL) {
		lpfnDllFunc3 = (LPFNDLLFUNC3)GetProcAddress(hDLL, "GetIpForwardTable");

		if (lpfnDllFunc3) {
			table = PA_GetVariableParameter( params, 1 );

			dwFuncReturn = lpfnDllFunc3(pTable, pSize, bOrder);

			// allocate memory
			pTable = (PMIB_IPFORWARDTABLE)malloc (*pSize );
			if ( pTable == NULL )
			{
				returnValue = 0;
				PA_ReturnLong( params, returnValue );
				return;
			}

			dwFuncReturn = lpfnDllFunc3(pTable, pSize, bOrder);
			if (dwFuncReturn != NO_ERROR) {
			// free memory
				free (pTable );
				returnValue = 0;
				PA_ReturnLong( params, returnValue );
				return;
			}
	
			tableEntries = (LONG_PTR) pTable->dwNumEntries;

			returnValue = tableEntries;
			PA_ResizeArray (&table, tableEntries);

			strcpy(routeString,"");
			for (i = 0; i < tableEntries; i++)
			{
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardDest);
				strcat(routeString,",");
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardMask);
				strcat(routeString,",");
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardNextHop);
				strcat(routeString,",");

				switch ((INT_PTR)pTable->table[i].dwForwardType)
				{
					case 1:
						strcat(routeString, "Not specified");
						break;
					case 2:
						strcat(routeString, "Logically deleted");
						break;
					case 3:
						strcat(routeString, "Local - next hop final");
						break;
					case 4:
						strcat(routeString, "Remote");
				}
				strcat(routeString,",");
				_ultoa(pTable->table[i].dwForwardAge, numToString,10);
				strcat(routeString,numToString);
		
				PA_SetTextInArray (table, i + 1, routeString, strlen(routeString));
				strcpy(routeString,"");
			}

			// free memory
			free ( pTable );

			PA_SetVariableParameter( params, 1, table, 0 );
		} //(lpfnDllFunc3)
		FreeLibrary(hDLL);
	} //(hDLL != NULL)
	PA_ReturnLong( params, returnValue );

}


// 
//  FUNCTION: sys_GetGUID( PA_PluginParameters params )
//
//  PURPOSE:	Gets a UUID in string format
//
//  COMMENTS:	Second string parameter contains text on UUID qualifier.
//						 May be OK, Local Only, Error
//
//	DATE:			dcc 07/30/01 
// 
void sys_GetGUID( PA_PluginParameters params)
{
	UUID				uGuid;
	RPC_STATUS			rpc_status;
	PUCHAR				cGuid;
	char				guidString[MAXBUF];
	LONG_PTR				guidString_len, guidStatus_len, returnValue;
	char				guidStatus[MAXBUF];

	guidString_len = PA_GetTextParameter( params, 1, guidString );
	guidString[guidString_len] = '\0';  // Explicitly set the length
	guidStatus_len = PA_GetTextParameter( params, 2, guidStatus );
	guidStatus[guidStatus_len] = '\0';

	returnValue = 1; //unless not OK or local
	rpc_status = UuidCreate(&uGuid);
	switch (rpc_status)
	{
		case RPC_S_OK :
			strcpy(guidStatus, "OK");
			break;

		case RPC_S_UUID_LOCAL_ONLY :
			strcpy(guidStatus, "Local Only");
			break;

		case RPC_S_UUID_NO_ADDRESS :
			strcpy(guidStatus, "Cannot get Ethernet hardware address");
			returnValue = 0;
			break;

		default :
			strcpy(guidStatus, "Unknown status");
			returnValue = 0;
	}

	rpc_status = UuidToString(&uGuid, &cGuid);
	strncpy(guidString, cGuid, MAXBUF);
	RpcStringFree(&cGuid);

	guidString_len = strlen(guidString);
	guidStatus_len = strlen(guidStatus);

	PA_SetTextParameter( params, 1, guidString, guidString_len );
	PA_SetTextParameter( params, 2, guidStatus, guidStatus_len );


	PA_ReturnLong( params, returnValue );
}


// ------------------------------------------------
// 
//  FUNCTION: gui_GetWindow( PA_PluginParameters params, HWND hWnd )
//
//  PURPOSE:	Obtain Windows window handle for window with specific title
//
//  COMMENTS:	Modified 08/17/01 dcc:  Replaced all except param refs with call
//						to getWindowHandle -- an internal function that returns hndl
//						Allows use for function gui_GetWindowProcess(windowTitle)
//	DATE:
//
//	MODIFICATIONS: Added a check for window title="*".  This retreives
//									frontmost window (active window)

void gui_GetWindow( PA_PluginParameters params, HWND hWnd )
{
	LONG_PTR			windowTitle_len;
	char				*windowTitle;
	LONG_PTR			returnValue;

	//windowTitle_len = PA_GetTextParameter( params, 1, windowTitle );
    //windowTitle[windowTitle_len] = '\0';  // Explicitly set the length

	windowTitle_len = PA_GetTextParameter( params, 1, NULL) + 1;
	windowTitle = malloc(windowTitle_len * sizeof(char));
	memset(windowTitle, 0, (windowTitle_len * sizeof(char)));
	windowTitle_len = PA_GetTextParameter( params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';

	if (strcmp(windowTitle, "*") == 0) { // return the frontmost window
		returnValue = (LONG_PTR) hWnd;

	} else {
		if ( (strlen(windowTitle) == 0) && (windowHandles.MDIs_4DhWnd != NULL) ) {
			returnValue = (LONG_PTR) windowHandles.fourDhWnd;
		} else if ((strcmp(_strlwr(windowTitle), "mdi") == 0) && (windowHandles.MDIhWnd != NULL)) {
			returnValue = (LONG_PTR) windowHandles.MDIhWnd;
		} else {
			returnValue = (LONG_PTR)getWindowHandle(windowTitle, hWnd);
		}
		if (!returnValue) {
			returnValue = -3;
		}
	}

	free(windowTitle);

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetWndRect( PA_PluginParameters params )
//

void gui_GetWndRect( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR x;
	LONG_PTR y;
	LONG_PTR w;
	LONG_PTR h;
	LONG_PTR returnValue;
	LONG_PTR mode;                            // MWD 1/12/07 #12852
	HWND WindowhWnd;
	HMONITOR hMon4D;
	MONITORINFO monitorInfo;
	RECT wRect;

	hWnd = PA_GetLongParameter( params, 1 );
	x = PA_GetLongParameter( params, 2 );
	y = PA_GetLongParameter( params, 3 );
	w = PA_GetLongParameter( params, 4 );
	h = PA_GetLongParameter( params, 5 );
	mode = PA_GetLongParameter( params, 6);


	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {
		
		// Allowing a return to the original functionality
		// As the new functionality broke at least one developer's code
		if (mode == 1) {
			// Old functionality
			// Get the coordinates relative the actual virtual desktop
		  if (GetWindowRect(WindowhWnd, &wRect)) {
			  x = wRect.left;
			  y = wRect.top;
			  w = wRect.right - wRect.left;
			  h = wRect.bottom - wRect.top;
			  returnValue = 1;
			} else {
			  returnValue = 0;
			}
    } else {  
		  // New functionality
			// Get the coordinates within the actual monitor that it's in
		  hMon4D = MonitorFromWindow(WindowhWnd, MONITOR_DEFAULTTONEAREST);
		  monitorInfo.cbSize = sizeof(MONITORINFO);
		  if(GetMonitorInfo(hMon4D, &monitorInfo)) {
			  if (GetWindowRect(WindowhWnd, &wRect)) {
				  x = wRect.left - monitorInfo.rcMonitor.left;
				  y = wRect.top - monitorInfo.rcMonitor.top;
				  w = wRect.right - wRect.left;
				  h = wRect.bottom - wRect.top;
			    returnValue = 1;
				} else {
			    returnValue = 0;
				}
			  returnValue = 1;
			} else {
			  returnValue = (LONG_PTR)GetLastError();
			} // end if
    } // end if
	} else {
		returnValue = 0;
	}

	PA_SetLongParameter( params, 2, x );
	PA_SetLongParameter( params, 3, y );
	PA_SetLongParameter( params, 4, w );
	PA_SetLongParameter( params, 5, h );

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetWndRect( PA_PluginParameters params )
//

void gui_SetWndRect( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR x;
	LONG_PTR y;
	LONG_PTR w;
	LONG_PTR h;
	LONG_PTR returnValue, tbHeight, tbWidth, respectTB = 0;
	HWND WindowhWnd, hWndTaskBar;
	RECT taskBarCoords;

	hWnd = PA_GetLongParameter( params, 1 );
	x = PA_GetLongParameter( params, 2 );
	y = PA_GetLongParameter( params, 3 );
	w = PA_GetLongParameter( params, 4 );
	h = PA_GetLongParameter( params, 5 );
	respectTB = PA_GetLongParameter( params, 6);

	// REB 11/10/11 #28503 Prevent them from making the window so large that it
	// hides the task bar.  I'm hesitant to change this because people may rely on 
	// this command to work as is.
	if (respectTB > 0){
		hWndTaskBar = FindWindow("Shell_TrayWnd", NULL); // Get a handle to the taskbar.
		if(GetWindowRect(hWndTaskBar, &taskBarCoords)){
			// We're going to assume that if height < width the taskbar is at the top or bottom.
			tbHeight = (taskBarCoords.bottom - taskBarCoords.top);
			tbWidth = (taskBarCoords.right - taskBarCoords.left);

			// Adjust the specified window size to prevent it from covering the taskbar.
			if((taskBarCoords.top == 0)&(taskBarCoords.left == 0)){
				if(tbHeight < tbWidth){ // Top
					if (y < taskBarCoords.bottom) 
						y = taskBarCoords.bottom; 
				}else{ // Left
					if(x < taskBarCoords.right)
						x = taskBarCoords.right;
				}
			}else if(taskBarCoords.top == 0){ // Right
				if ((x + w) > taskBarCoords.left)
					w = taskBarCoords.left - x;

			}else { // Bottom
				if((y + h) > taskBarCoords.top)
					h = taskBarCoords.top - y;
			}
		}
	}

	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {
		if (SetWindowPos(WindowhWnd, HWND_TOP, x, y, w, h,
				      	     SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOZORDER)) {
			returnValue = 1;
		} else {
			returnValue = 0;
		}
	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_ShowWindow( PA_PluginParameters params )
//

void gui_ShowWindow( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR showState;
	LONG_PTR returnValue;
	HWND WindowhWnd;

	hWnd = PA_GetLongParameter( params, 1 );
	showState = PA_GetLongParameter( params, 2 );

	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {
		// REB 2/26/09 #16207 Handle this slightly differently if we are using a toolbar.
		if(toolBarRestrictions.toolBarOnDeck == 1){
			switch (showState)
			{
				case SW_MAXIMIZE :
					toolBarRestrictions.appBeingMaxed = APP_MAXIMIZING;
					ShowWindowAsync (WindowhWnd, showState);
					break;
				case SW_RESTORE :
					SendMessage(WindowhWnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
					break;
				case SW_MINIMIZE :
					SendMessage(WindowhWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0L); // REB 3/29/10 #22878 
					break;
				default :
					ShowWindowAsync (WindowhWnd, showState);
					break;
			}
		}else{
			ShowWindowAsync (WindowhWnd, showState);
		}
		returnValue = 1;
	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: sys_GetUserName( PA_PluginParameters params )
//

void sys_GetUserName( PA_PluginParameters params )
{
	LONG_PTR userName_len;
	char userName[255];
	LONG_PTR returnValue;

	userName_len = PA_GetTextParameter( params, 1, userName );
  userName[userName_len] = '\0';  // Explicitly set the length

  userName_len = 255;  // This holds the maximum size of userName variable

  if(GetUserName(userName, &userName_len)) {
	  returnValue = 1;
  } else {
		strcpy(userName, "");
	  returnValue = 0;
  }

  // At this point, the user name field is either empty or filled
	// with a valid value.  Return this value to the user in either case.
  userName_len = strlen(userName);
	PA_SetTextParameter( params, 1, userName, userName_len );

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetWindowTitle( PA_PluginParameters params )
//

void gui_SetWindowTitle( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR windowTitle_len;
	char windowTitle[255];
	LONG_PTR returnValue;
	HWND WindowhWnd;

	hWnd = PA_GetLongParameter( params, 1 );
	windowTitle_len = PA_GetTextParameter( params, 2, windowTitle );
  windowTitle[windowTitle_len] = '\0';  // Explicitly set the length


	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {
		SetWindowText(WindowhWnd,windowTitle);
		returnValue = 1;
	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: sys_IsMultiByte( PA_PluginParameters params )
//

void sys_IsMultiByte( PA_PluginParameters params )
{
	LONG_PTR byte_len;
	char byte[255];
	LONG_PTR returnValue;

	byte_len = PA_GetTextParameter( params, 1, byte );

	returnValue = IsDBCSLeadByte(*byte);

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_DisableCloseBox( PA_PluginParameters params )
//
//
//	MODIFICATIONS: 09/09/02 Added functionality to restore the close box.
//								 Pass in the window handle as a negative to restore.

void gui_DisableCloseBox( PA_PluginParameters params )
{
	LONG_PTR				hWnd;
	LONG_PTR				returnValue;
	HWND				WindowhWnd;
	HMENU				hSysMenu;
	BOOL				bUndo = FALSE;

	hWnd = PA_GetLongParameter( params, 1 );

	if (hWnd < 0) {
		bUndo = TRUE;
	}
	WindowhWnd = (HWND) abs(hWnd);
	if(IsWindow(WindowhWnd)) {
		hSysMenu = GetSystemMenu(WindowhWnd,0);
		if (!bUndo) {
			EnableMenuItem (hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
		} else {
			EnableMenuItem (hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
		}
		returnValue = 1;
	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetWindowLong( PA_PluginParameters params )
//
//  PURPOSE:  Multipurpose function to set window styles etc
//

void gui_SetWindowLong( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR s;
	LONG_PTR mode;
	LONG_PTR level;
	LONG_PTR returnValue;
	HWND WindowhWnd;
	LONG style;

	hWnd = PA_GetLongParameter( params, 1 );
	s = PA_GetLongParameter( params, 2 );
	mode = PA_GetLongParameter( params, 3 );
	level = PA_GetLongParameter( params, 4 );

	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {

		if (level == 0)
			style = GetWindowLong(WindowhWnd, GWL_STYLE);
		else
			style = GetWindowLong(WindowhWnd, GWL_EXSTYLE);

		if(mode == 1)
			style |= (s);
		else
			style &= ~(s);

		if(level == 0)
			SetWindowLong(WindowhWnd, GWL_STYLE, style);
		else
			SetWindowLong(WindowhWnd, GWL_EXSTYLE, style);

		SetWindowPos(WindowhWnd, HWND_TOP, 0, 0, 0, 0,
					 SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

		returnValue = 1;
	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_WinHelp( PA_PluginParameters params )
//
void gui_WinHelp( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR fileName_len;
	char fileName[255];
	LONG_PTR helpCommand;
	LONG_PTR helpData;
	LONG_PTR returnValue;
	HWND WindowhWnd;
	INT_PTR ret;

	hWnd = PA_GetLongParameter( params, 1 );
	fileName_len = PA_GetTextParameter( params, 2, fileName );
  fileName[fileName_len] = '\0';  // Explicitly set the length
	helpCommand = PA_GetLongParameter( params, 3 );
	helpData = PA_GetLongParameter( params, 4 );


	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {
		ret = WinHelp(WindowhWnd, fileName, helpCommand, helpData);
		returnValue = (LONG_PTR)ret;
	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}



// ------------------------------------------------
// 
//  FUNCTION: gui_DelMenuItem( PA_PluginParameters params )
//

void gui_DelMenuItem( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR menuNum;
	LONG_PTR menuItem;
	LONG_PTR returnValue;
	HWND WindowhWnd;
	HMENU hSubMenu, hMenu;

	hWnd = PA_GetLongParameter( params, 1 );
	menuNum = PA_GetLongParameter( params, 2 );
	menuItem = PA_GetLongParameter( params, 3 );

    returnValue = 0;
	WindowhWnd = (HWND)hWnd;
	if(IsWindow(WindowhWnd)) {
		hMenu = GetMenu(WindowhWnd);
		if(IsMenu(hMenu)) {
			hSubMenu = GetSubMenu(hMenu, menuNum);
			if(IsMenu(hSubMenu)) {
				RemoveMenu(hSubMenu, (menuItem) - 1, MF_BYPOSITION);
				DrawMenuBar(WindowhWnd);
				returnValue = 1;
			}
		}
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetOpenFileName( PA_PluginParameters params )
//
//  PURPOSE:  display open file common dialog for selecting a file
//
//  COMMENTS: several optins are allowed which hide various
//						buttons or disable entry controls.
//						Uses a hook procedure and a template for folder
//						selection.       
//						Does not open file - only retieves name and path
//	DATE:			07/27/01
//
void gui_GetOpenFileName( PA_PluginParameters params )
{
	LONG_PTR		windowTitle_len;
	char		windowTitle[100];
	LONG_PTR		filePattern_len;
	char		filePattern[100];
	LONG_PTR		fileDescription_len;
	char		fileDescription[100];
	LONG_PTR		startFolder_len;
	char		startFolder[255];
	LONG_PTR		fileNameShort_len;
	char		fileNameShort[255];
	char		fileNameSuggested[255];
	LONG_PTR		fileNameSuggested_len;
	LONG_PTR		fileNameFull_len;
	char		fileNameFull[255];
	LONG_PTR		returnValue;
	OPENFILENAME ofn;
  unsigned char fileOpenPattern[80];
	LONG_PTR		mustExistOption = 0; 
	BOOL		bUnhookSuccess; 
	HWND		hWnd; 
	char		plugInPath[255];
	PA_Unistring		Unistring;
	char				*pathName, *charPos;

	g_FolderSelected = FALSE;  // MJG 6/15/05
	windowHandles.openSaveTBhwnd = NULL;

	if(PA_Is4DServer()){
		 Unistring = PA_GetApplicationFullPath();
		 pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
		 charPos = strrchr(pathName,'\\');
		 *charPos = 0;
		 hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
	}else{
		hWnd = PA_GetHWND(NULL); // the current frontmost window
	}
	//hWnd = (HWND)PA_GetHWND(0);

	windowTitle_len = PA_GetTextParameter( params, 1, windowTitle );
  windowTitle[windowTitle_len] = '\0';  // Explicitly set the length
	filePattern_len = PA_GetTextParameter( params, 2, filePattern );
  filePattern[filePattern_len] = '\0';  // Explicitly set the length
	fileDescription_len = PA_GetTextParameter( params, 3, fileDescription );
  fileDescription[fileDescription_len] = '\0';  // Explicitly set the length
	startFolder_len = PA_GetTextParameter( params, 4, startFolder );
  startFolder[startFolder_len] = '\0';  // Explicitly set the length
	fileNameSuggested_len = PA_GetTextParameter( params, 5, fileNameSuggested );
  fileNameSuggested[fileNameSuggested_len] = '\0';  // Explicitly set the length
	fileNameFull_len = PA_GetTextParameter( params, 6, fileNameFull );
  fileNameFull[fileNameFull_len] = '\0';  // Explicitly set the length

	mustExistOption = PA_GetLongParameter( params, 7 ); 
	FD_Flags = mustExistOption;

  // The pattern consists of two strings, each terminated with a null character
  sprintf(fileOpenPattern,"%s%c%s%c",fileDescription,'\0',filePattern,'\0');

	GetPlugInFullName(plugInPath);

  memset(&ofn,0,sizeof(ofn));
	ofn.lStructSize				= sizeof(ofn); 
	ofn.hwndOwner					= hWnd; 
	ofn.hInstance					= GetModuleHandle(plugInPath);
	ofn.lpstrFilter				= fileOpenPattern;
	ofn.lpstrCustomFilter = NULL; 
	ofn.nMaxCustFilter		= 0; 
	ofn.nFilterIndex			= 1; 
	ofn.lpstrFile					= fileNameSuggested;
	ofn.nMaxFile					= 255;
	ofn.lpstrFileTitle		= fileNameShort;
	ofn.nMaxFileTitle			= 255;
	ofn.lpstrInitialDir		= startFolder;
	ofn.lpstrTitle				= windowTitle;
	ofn.lpTemplateName		= MAKEINTRESOURCE(IDD_COMDLG32); 
	ofn.lpfnHook					= ComDlg32DlgProc; 
	ofn.Flags							= OFN_EXPLORER;

	// Set the return strings to empty
	strcpy(fileNameShort, "");
	strcpy(fileNameFull, "");


	if ( (FD_Flags & FD_HIDE_UP_BUTTON) | (FD_Flags & FD_DISABLE_EDIT_FIELD)
		| (FD_Flags & FD_DISABLE_LOOKIN_FIELD) | (FD_Flags & FD_FILES_ONLY)
		| (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) | (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) 
		| (FD_Flags & FD_SELECT_DIRECTORY) ) {
		ofn.Flags = ofn.Flags | OFN_ENABLEHOOK; 
	}

	if (FD_Flags & FD_FILE_MUST_EXIST) {
		ofn.Flags = ofn.Flags | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	}

	if (FD_Flags == FD_CREATE_PROMPT) {
		ofn.Flags = ofn.Flags | OFN_CREATEPROMPT;
	}

	if (FD_Flags == FD_SELECT_DIRECTORY) {
		strcpy(ofn.lpstrFile, ""); //with this option, cannot use a suggested filename 
		ofn.Flags = ofn.Flags | OFN_ENABLETEMPLATE;
	}
	
	if (GetOpenFileName(&ofn)) {
		returnValue = 1;
	} else {
		if(g_FolderSelected == TRUE){
			returnValue = 1;
		}
		else{
			ProcessCDError(CommDlgExtendedError(), hWnd );
			returnValue = 0;
		}
	}

	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.openSaveHookHndl); // success is non-zero
	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.postProcHookHndl);

  // At this point, the file name fields are either empty or filled
	// with valid values.  Return these values to the user in either case.
	if (FD_Flags & FD_SELECT_DIRECTORY) {
		strcpy(fileNameShort, intrProcStr1);
		strcpy(fileNameFull, intrProcStr1);
	} else {
		strcpy(fileNameFull, fileNameSuggested);
	}

	fileNameShort_len = strlen(fileNameShort);
	fileNameFull_len = strlen(fileNameFull);
	PA_SetTextParameter( params, 5, fileNameShort, fileNameShort_len );
 	PA_SetTextParameter( params, 6, fileNameFull, fileNameFull_len );

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetSaveFileName( PA_PluginParameters params )
//
//  PURPOSE: Save File Common Dialog -- for saving a file 
//
//  COMMENTS:  see comments for OpenFileName
//
//	DATE:	07/21/01
//
void gui_GetSaveFileName( PA_PluginParameters params )
{
	LONG_PTR		windowTitle_len;
	char		windowTitle[100];
	LONG_PTR		filePattern_len;
	char		filePattern[100];
	LONG_PTR		fileDescription_len;
	char		fileDescription[100];
	LONG_PTR		startFolder_len;
	char		startFolder[255];
	LONG_PTR		fileNameShort_len;
	char		fileNameShort[255];
	char		fileNameSuggested[255];
	LONG_PTR		fileNameSuggested_len;
	LONG_PTR		fileNameFull_len;
	char		fileNameFull[255];
	LONG_PTR		returnValue;
	OPENFILENAME ofn;
  unsigned char fileOpenPattern[80];
	LONG_PTR		mustExistOption = 0; 
	BOOL		bUnhookSuccess; 
	HWND		hWnd; 
	char		plugInPath[255];
	PA_Unistring		Unistring;
	char				*pathName, *charPos;

	g_FolderSelected = FALSE;  // MJG 6/15/05
	windowHandles.openSaveTBhwnd = NULL;

	if(PA_Is4DServer()){
		 Unistring = PA_GetApplicationFullPath();
		 pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
		 charPos = strrchr(pathName,'\\');
		 *charPos = 0;
		 hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
	}else{
		hWnd = PA_GetHWND(NULL); // the current frontmost window
	}
	//hWnd = (HWND)	PA_GetHWND(0);

	windowTitle_len = PA_GetTextParameter( params, 1, windowTitle );
  windowTitle[windowTitle_len] = '\0';  // Explicitly set the length
	filePattern_len = PA_GetTextParameter( params, 2, filePattern );
  filePattern[filePattern_len] = '\0';  // Explicitly set the length
	fileDescription_len = PA_GetTextParameter( params, 3, fileDescription );
  fileDescription[fileDescription_len] = '\0';  // Explicitly set the length
	startFolder_len = PA_GetTextParameter( params, 4, startFolder );
  startFolder[startFolder_len] = '\0';  // Explicitly set the length
	fileNameSuggested_len = PA_GetTextParameter( params, 5, fileNameSuggested );
  fileNameSuggested[fileNameSuggested_len] = '\0';  // Explicitly set the length
	fileNameFull_len = PA_GetTextParameter( params, 6, fileNameFull );
  fileNameFull[fileNameFull_len] = '\0';  // Explicitly set the length

	mustExistOption = PA_GetLongParameter( params, 7 ); 
	FD_Flags = mustExistOption;

	// The pattern consists of two strings, each terminated with a null character
  sprintf(fileOpenPattern,"%s%c%s%c",fileDescription,'\0',filePattern,'\0');

	// Set the return strings to empty
	strcpy(fileNameShort, "");
	strcpy(fileNameFull, "");

	GetPlugInFullName(plugInPath);

  memset(&ofn,0,sizeof(ofn));
	ofn.lStructSize				= sizeof(ofn); 
	ofn.hwndOwner					= hWnd; 
	ofn.hInstance					= GetModuleHandle(plugInPath);
	ofn.lpstrFilter				= fileOpenPattern;
	ofn.lpstrCustomFilter = NULL; 
	ofn.nMaxCustFilter		= 0; 
	ofn.nFilterIndex			= 1; 
	ofn.lpstrFile					= fileNameSuggested;
	ofn.nMaxFile					= 255;
	ofn.lpstrFileTitle		= fileNameShort;
	ofn.nMaxFileTitle			= 255;
	ofn.lpstrInitialDir		= startFolder;
	ofn.lpstrTitle				= windowTitle;
	ofn.lpTemplateName		= MAKEINTRESOURCE(IDD_COMDLG32); 
	ofn.lpfnHook					= ComDlg32DlgProc; 
	ofn.Flags							= OFN_EXPLORER;

	if ( (FD_Flags & FD_HIDE_UP_BUTTON) | (FD_Flags & FD_DISABLE_EDIT_FIELD)
		| (FD_Flags & FD_DISABLE_LOOKIN_FIELD) | (FD_Flags & FD_FILES_ONLY)
		| (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) | (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) 
		| (FD_Flags & FD_SELECT_DIRECTORY) ) {
		ofn.Flags = ofn.Flags | OFN_ENABLEHOOK; 
	}

	if (FD_Flags & FD_FILE_MUST_EXIST) {
		ofn.Flags = ofn.Flags | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	}

	if (FD_Flags == FD_OVERWRITE_PROMPT) {
		ofn.Flags = ofn.Flags | OFN_OVERWRITEPROMPT;
	}

	if (FD_Flags == FD_SELECT_DIRECTORY) {
		strcpy(ofn.lpstrFile, ""); //with this option, cannot use a suggested filename 
		ofn.Flags = ofn.Flags | OFN_ENABLETEMPLATE;
	}
	
	if (GetSaveFileName(&ofn)) {
		returnValue = 1;
	} else {
		if(g_FolderSelected == TRUE){
			returnValue = 1;
		}
		else{
			ProcessCDError(CommDlgExtendedError(), hWnd ); // primarily for debugging
			returnValue = 0;
		}
	}

	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.openSaveHookHndl); // success is non-zero
	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.postProcHookHndl);

  // At this point, the file name fields are either empty or filled
	// with valid values.  Return these values to the user in either case.
	if (FD_Flags & FD_SELECT_DIRECTORY) {
		strcpy(fileNameShort, intrProcStr1);
		strcpy(fileNameFull, intrProcStr1);
	} else {
		strcpy(fileNameFull, fileNameSuggested);
	}

	fileNameShort_len = strlen(fileNameShort);
	fileNameFull_len = strlen(fileNameFull);
	PA_SetTextParameter( params, 5, fileNameShort, fileNameShort_len );
 	PA_SetTextParameter( params, 6, fileNameFull, fileNameFull_len );

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_LoadIcon( PA_PluginParameters params )
//

void gui_LoadIcon( PA_PluginParameters params )
{
	LONG_PTR iconName_len;
	char iconName[255];  //complete path of icon file
	LONG_PTR hIcon;
	LONG_PTR returnValue;
    HICON tmpIcon;
	
	iconName_len = PA_GetTextParameter( params, 1, iconName );
    iconName[iconName_len] = '\0';  // Explicitly set the length

	hIcon = PA_GetLongParameter( params, 2 );
  
	// Load the icon
	hIcon = 0;
	tmpIcon = (HICON)LoadImage(0,iconName,IMAGE_ICON,0,0,LR_DEFAULTSIZE | LR_LOADFROMFILE);

	if (tmpIcon != 0) {
	  hIcon = (LONG_PTR)tmpIcon;
	  returnValue = 1;
	}
	else {
	  returnValue = 0;
	}

	PA_SetLongParameter( params, 2, hIcon );

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetIcon( PA_PluginParameters params )
//

void gui_SetIcon( PA_PluginParameters params )
{
	LONG_PTR hWnd;
	LONG_PTR hIcon;
	LONG_PTR returnValue;
	HWND WindowhWnd;

	hWnd = PA_GetLongParameter( params, 1 );
    hIcon = PA_GetLongParameter( params, 2 );

	WindowhWnd = (HWND)hWnd;

	if ((IsWindow(WindowhWnd)) && (hIcon != 0)) {

	  // Tell the window to use this icon
    SendMessage(WindowhWnd, WM_SETICON, (WPARAM)ICON_SMALL,(LPARAM)(HICON) hIcon);
		returnValue = 1;

	} else {
		returnValue = 0;
	}

	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetWindowFrom4DWin( PA_PluginParameters params )
//

void gui_GetWindowFrom4DWin( PA_PluginParameters params )
{
	LONG_PTR h4DWnd;
	LONG_PTR returnValue;
	LONG_PTR serverValue;

	h4DWnd = PA_GetLongParameter(params, 1);
	serverValue = PA_GetLongParameter(params, 2);

	if (serverValue == 1) // AMS 5/20/14 #39556 PA_GetHWND(h4DWnd) does not work on 4D Server // AMS 6/8/14 #39789
	{
		returnValue = PA_GetHWND(PA_GetWindowFocused());
	}
	else
	{
		returnValue = PA_GetHWND(h4DWnd);
	}

	PA_ReturnLong(params, returnValue);
}


// ------------------------------------------------
// 
//  FUNCTION: sys_GetRegionSettings( PA_PluginParameters params, BOOL arraySupplied )
//
//  PURPOSE:	Gets region-specifiuc settings such as decimal char, currency symbol etc
//
//  COMMENTS: Method gets all or one depending on 2nd parameter passed from
//						entry point.
     
//	DATE:			dcc 07/10/01
//
void sys_GetRegionSettings( PA_PluginParameters params, BOOL arraySupplied )
{
	PA_Variable	values, valueDescr;
	char		textParam[80];
	LONG_PTR		textParam_len;
	LCTYPE	infoType[NBR_ELEMENTS];
	char*		description[] = {
	 "Short Date", "Long Date", "Date Separator", "Time Format",
	 "Time Separator", "AM Symbol", "PM Symbol", "Measurement System",
	 "Decimal Symbol", "Leading Zeros", "Digits after Decimal",
	 "Number Grouping Symbol", "Negative Symbol", "Currency Symbol",
	 "Currency Decimal Symbol", "Currency Digits after Decimal",
	 "Currency Grouping Symbol", "List Separator"
	};
	LONG_PTR		returnValue, i, loopStop, gliReturnValue;  //gli = GetLocaleInfo
	LONG_PTR		requestedSetting;
	char		resultString[255];
	char		sz[255]; 
	INT_PTR			bufSize = 255, resultSize = 255;

	infoType[0] = LOCALE_SSHORTDATE;
	infoType[1] = LOCALE_SLONGDATE;
	infoType[2] = LOCALE_SDATE;
	infoType[3] = LOCALE_STIMEFORMAT;
	infoType[4] = LOCALE_STIME;
	infoType[5] = LOCALE_S1159;
	infoType[6] = LOCALE_S2359;
	infoType[7] = LOCALE_IMEASURE;
	infoType[8] = LOCALE_SDECIMAL;
	infoType[9] = LOCALE_ILZERO;
	infoType[10] = LOCALE_IDIGITS;
	infoType[11] = LOCALE_STHOUSAND;
	infoType[12] = LOCALE_SNEGATIVESIGN;
	infoType[13] = LOCALE_SCURRENCY;
	infoType[14] = LOCALE_SMONDECIMALSEP;
	infoType[15] = LOCALE_ICURRDIGITS;
	infoType[16] = LOCALE_SMONTHOUSANDSEP;
	infoType[17] = LOCALE_SLIST;

	returnValue = 0;
	if (arraySupplied) {
		values = PA_GetVariableParameter( params, 1 );
		PA_ResizeArray( &values, NBR_ELEMENTS );

		valueDescr = PA_GetVariableParameter( params, 2);
		PA_ResizeArray( &valueDescr, NBR_ELEMENTS );
		
		loopStop = PA_GetArrayNbElements( values );
		requestedSetting = 0; // start at zero in loop below to get all into the array
	} else {
		textParam_len = PA_GetTextParameter( params, 1, textParam );
		loopStop = PA_GetLongParameter( params, 2 );
		requestedSetting = loopStop -1;
	}


	for (i = requestedSetting; i < loopStop; i++)
	{
		strcpy(sz, resultString);
		resultSize = strlen(sz);
		gliReturnValue = GetLocaleInfo ( LOCALE_USER_DEFAULT, infoType[i], sz, bufSize );
		if (gliReturnValue = 0) {
			strcpy(sz, "n/a"); // some keyNames may be there & some may not
		} 

		if (infoType[i] == LOCALE_IMEASURE) {
			if (sz[0] == '0') {
				strcpy(sz, "Metric");
			}	else {
					strcpy(sz, "U.S.");
			} //(sz[0] == '0')
		} //(infoType[i] == LOCALE_IMEASURE)
		
		if (arraySupplied) { 
			PA_SetTextInArray( values, i + 1, sz, strlen(sz) );
			PA_SetTextInArray( valueDescr, i + 1, description[i], strlen(description[i]) );
			returnValue = i + 1;
		} else {
			PA_SetTextParameter( params, 1, sz, strlen(sz) );
			PA_ReturnLong( params, strlen(sz) );  // return value string length
			return;
		} //(arraySupplied)

	} //(i = requestedSetting; i < loopStop; i++)

	PA_SetVariableParameter( params, 1, values, 0 );
	PA_SetVariableParameter( params, 2, valueDescr, 0 );
	PA_ReturnLong( params, returnValue );

}

// ------------------------------------------------
// 
//  FUNCTION: sys_GetTimeZone( PA_PluginParameters params )
//
//  PURPOSE:	Gets time zone setting of cmptr	
//
//  COMMENTS: Requires two text strings and a LONG_PTR
//						Returns name of standard time, name of daylight time, and
//						flag if cmptr set to auto adjust for daylight savings changes.
//
//						IMPORTANT:  It is imperative that different name & size variables be 
//												used for query on standard time and daylight time.
//												The problem is in release configuration mode where the size
//												returned from first use does not get reset properly (even
//												when set explicitly).  This is alluded to in help file
//												documentation.
//	DATE:			dcc 07/16/01
//
//  REB 1/21/09 #19035  Updated how we retrieve time zone information.  Original code commented out.
//

void sys_GetTimeZone( PA_PluginParameters params )
{
	LONG_PTR		standardName_len;
	char		standardName[255];
	LONG_PTR		daylightName_len;
	char		daylightName[255];
	LONG_PTR		autoDaylight = 0;
	LONG_PTR		returnValue;
	TIME_ZONE_INFORMATION TimeZoneInformation; // REB 1/21/09 #19035

	returnValue = 1;

	GetTimeZoneInformation(&TimeZoneInformation);

	wcstombs(standardName, TimeZoneInformation.StandardName, 255);
	standardName_len = strlen(standardName);

	wcstombs(daylightName, TimeZoneInformation.DaylightName, 255);
	daylightName_len = strlen((char *)daylightName);

	if (TimeZoneInformation.DaylightBias != 0){
		autoDaylight = 1;
	}else{
		autoDaylight = 0;
	}

	PA_SetTextParameter( params, 1, (char *)standardName, standardName_len );
	PA_SetTextParameter( params, 2, (char *)daylightName, daylightName_len );
	PA_SetLongParameter( params, 3, autoDaylight );

	PA_ReturnLong( params, returnValue );

}

// ------------------------------------------------
// 
//  FUNCTION: sys_GetUTCOffset ( PA_PluginParameters params )
//
//  REB 1/21/09 #19035 Updated to use GetTimeZoneInformation

void sys_GetUTCOffset ( PA_PluginParameters params )
{
	LONG_PTR					returnValue = 0;
	LONG_PTR					bias = 0, weekNum = 0;

	//struct _timeb tstruct;
	TIME_ZONE_INFORMATION TimeZoneInformation; // REB 1/21/09 #19035
	SYSTEMTIME SystemTime;

	GetTimeZoneInformation(&TimeZoneInformation);
	GetLocalTime(&SystemTime);

	bias = TimeZoneInformation.Bias;

	//TimeZoneInformation.DaylightDate.wDayOfWeek // Sun - Sat
	//TimeZoneInformation.DaylightDate.wDay // 1 -5 occurance of above day

	// Calculate which occurance of the current day we are on.  Basically which week in the month we are on.
	weekNum = ((SystemTime.wDay - 1)/7) + 1; // Between 1 and 5


	if(SystemTime.wMonth == TimeZoneInformation.StandardDate.wMonth){ 
		// We are in the month when we change back to standard
		if (SystemTime.wDayOfWeek == TimeZoneInformation.StandardDate.wDayOfWeek){
			// We are in the Week that the time changes
			if(weekNum == TimeZoneInformation.StandardDate.wDay){
				// This is the Day the time changes
				if(SystemTime.wHour >= TimeZoneInformation.StandardDate.wHour){
					bias += TimeZoneInformation.StandardBias;
				}else{
					bias += TimeZoneInformation.DaylightBias;
				};
			}else if(weekNum > TimeZoneInformation.StandardDate.wDay){ 
				bias += TimeZoneInformation.StandardBias;
			}else{
				bias += TimeZoneInformation.DaylightBias;
			};
		}else if (SystemTime.wDayOfWeek > TimeZoneInformation.StandardDate.wDayOfWeek){
			if(weekNum > TimeZoneInformation.StandardDate.wDay){ 
				bias += TimeZoneInformation.StandardBias;
			}else{
				bias += TimeZoneInformation.DaylightBias;
			};
		}else{
			bias += TimeZoneInformation.DaylightBias;
		};

	}else if(SystemTime.wMonth == TimeZoneInformation.DaylightDate.wMonth){ 
		// We are in the month when we change back to standard
		if (SystemTime.wDayOfWeek == TimeZoneInformation.DaylightDate.wDayOfWeek){
			// We are in the Week that the time changes
			if(weekNum == TimeZoneInformation.DaylightDate.wDay){
				// This is the Day the time changes
				if(SystemTime.wHour >= TimeZoneInformation.DaylightDate.wHour){
					bias += TimeZoneInformation.DaylightBias;
				}else{
					bias += TimeZoneInformation.StandardBias;
				};
			}else if(weekNum > TimeZoneInformation.DaylightDate.wDay){ 
				bias += TimeZoneInformation.DaylightBias;
			}else{
				bias += TimeZoneInformation.StandardBias;
			};
		}else if (SystemTime.wDayOfWeek > TimeZoneInformation.DaylightDate.wDayOfWeek){
			if(weekNum > TimeZoneInformation.DaylightDate.wDay){ 
				bias += TimeZoneInformation.DaylightBias;
			}else{
				bias += TimeZoneInformation.StandardBias;
			};
		}else{
			bias += TimeZoneInformation.StandardBias;
		};

	}else if(TimeZoneInformation.StandardDate.wMonth > TimeZoneInformation.DaylightDate.wMonth){ 
		// The period of daylight savings time uccurs within a single year.
		if((SystemTime.wMonth > TimeZoneInformation.DaylightDate.wMonth) && (SystemTime.wMonth < TimeZoneInformation.StandardDate.wMonth)){
			bias += TimeZoneInformation.DaylightBias;
		}else{
			bias += TimeZoneInformation.StandardBias;
		};

	}else{ 
		// The period of daylight savings time is split between 2 years (say, November to April). 
		if((SystemTime.wMonth > TimeZoneInformation.DaylightDate.wMonth) || (SystemTime.wMonth < TimeZoneInformation.StandardDate.wMonth)){
			bias += TimeZoneInformation.DaylightBias;
		}else{
			bias += TimeZoneInformation.StandardBias;
		};
	};	
	

	PA_SetLongParameter( params, 1, bias);

	returnValue = PA_GetLongParameter( params, 1 );
	//_tzset();
	//_ftime( &tstruct );
	//PA_SetLongParameter( params, 1, tstruct.timezone );
	if (returnValue == TIME_ZONE_ID_INVALID){
		returnValue = 0;
	}else{
		returnValue = 1;
	};
	
	PA_ReturnLong( params, returnValue );
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetDisplayFontDPI( PA_PluginParameters params)
//
//	DATE:			dcc 07/??/01  <-- Was the calendar broken that day?
//
void gui_GetDisplayFontDPI( PA_PluginParameters params)
{
	LONG_PTR		dpi = 0;
	char		subKey[100];
	LONG_PTR		returnValue, errorCode;
	HKEY		hKey;
	DWORD		dwWordType = REG_DWORD;
	DWORD		dwWordSize = sizeof(DWORD);
	DWORD		dwSZSize = 255;
	DWORD		dwDPI;

	returnValue = 0;

	strcpy ( subKey, "Software\\Microsoft\\Windows NT\\CurrentVersion\\FontDPI");
	hKey = HKEY_LOCAL_MACHINE;
	errorCode = RegOpenKeyEx ( hKey, subKey, 0, KEY_READ, &hKey );
	if (errorCode != ERROR_SUCCESS) {
		returnValue = 0;
		PA_ReturnLong( params, returnValue );
		return;
	}
	errorCode = RegQueryValueEx ( hKey, "LogPixels", NULL, &dwWordType, (PCHAR) &dwDPI, &dwWordSize );
	if (errorCode != ERROR_SUCCESS) {	
		returnValue = 0;
		PA_ReturnLong( params, returnValue );
		return;
	} else {
		dpi = dwDPI;
	}
	errorCode = RegCloseKey( hKey );

	PA_SetLongParameter( params, 1, dpi );
	returnValue = dpi;
	PA_ReturnLong( params, returnValue );

}


// ------------------------------------------------
// 
//  FUNCTION: sys_GetDefPrinter( PA_PluginParameters params )
//
//  PURPOSE:  Determines which printer is marked as default
//		REB 3/6/09 #17333 Updated to work with Windows Vista and beyond.
//		REB 8/11/09		Removed logic used in versions of Windows older than 2000.
//
void sys_GetDefPrinter( PA_PluginParameters params )
{
	LONG_PTR printerName_len;
	char printerName[255];
	char *pDefaultPrinter;				// REB 3/6/09 #17333 
	LONG_PTR returnValue;
	ULONG_PTR ulBytesNeeded;		// REB 3/6/09 #17333 

	printerName_len = PA_GetTextParameter( params, 1, printerName );
    printerName[printerName_len] = '\0';  // Explicitly set the length
   
    printerName_len = 255;  // This holds the maximum size of printerName variable
	ulBytesNeeded = MAXBUF; 

	pDefaultPrinter = (char *)malloc(ulBytesNeeded);
	memset(pDefaultPrinter, 0, ulBytesNeeded);
		
	returnValue = GetDefaultPrinter(pDefaultPrinter, &ulBytesNeeded);
	strcpy(printerName, pDefaultPrinter);

    // At this point, the printer name field is either empty or filled
	// with a valid value.  Return this value to the user in either case.
	printerName_len = strlen(printerName);
	PA_SetTextParameter( params, 1, printerName, printerName_len );

	PA_ReturnLong( params, returnValue );
}


// ------------------------------------------------
// 
//  FUNCTION: sys_SetDefPrinter( PA_PluginParameters params )
//
//  PURPOSE:  Sets the default printer
//
void sys_SetDefPrinter( PA_PluginParameters params )
{
	LONG_PTR printerName_len;
	char printerName[255];
	char tempName[255];					// REB 3/6/09 #17333 Printer name after spooler info is removed
	char separator[] = ",";				// REB 3/6/09 #17333 Separates printer name from spooler info
	BOOL returnValue;

	printerName_len = PA_GetTextParameter( params, 1, printerName );
    printerName[printerName_len] = '\0';  // Explicitly set the length


	// REB 3/6/09 #17333 Remove spooler info from printer name.
	printerName_len = strcspn(printerName, separator);
	if(printerName_len > 0){
		strncpy(tempName, printerName, printerName_len);
		tempName[printerName_len] = '\0';
		returnValue = SetDefaultPrinter(tempName);
	}		

	PA_ReturnLong( params, (LONG_PTR)returnValue );
}



// ------------------------------------------------
// 
//  FUNCTION: sys_GetOSVersion(BOOL bInternalCall, PA_PluginParameters params)
//
//  PURPOSE:  Get version of operating system
//
//  COMMENTS: Internally returns LONG_PTR that corresponds to constant defined
//			  for each OS.  params are ignored on internal calls.
//			  External call gets version as constant and string for service pack.
//			  Some info is in win.ini file (Win95/98/Me) and some
//			  in registry.  Need to know where to go hunting
//	DATE:	  dcc 07/10/01
//
//	MODIFICATIONS: 12/1/03 Added check for Windows Server 2003.
//				   7/15/09 Added check for Windows 7 
//				   10/31/12 Added support for Windows 8 and Server 2012
//			       AMS2 9/26/14 #37816 Windows 8.1 and Server 2012 R2 and newer versions of Windows should use sys_GetOSVersionEX as GetVersionEX is deprecated
//            
//
LONG_PTR sys_GetOSVersion(BOOL bInternalCall, PA_PluginParameters params)
{

	OSVERSIONINFOEX		osvinfo;
	LONG_PTR			returnValue = 0;

	osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx( &osvinfo );

	if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_WIN95;
	} else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 10) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_WIN98;
	} else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 90) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_ME;
	} else if ((osvinfo.dwMajorVersion == 3) & (osvinfo.dwMinorVersion == 51) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_NT351;
	} else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_NT4;
	} else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_W2K;
	} else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_XP;
	} else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 2) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_WIN03;
    } else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)& (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_VISTA_LONGHORN;
	} else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)& (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2K8;
	} else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) & (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_WIN7;
	} else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) & (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2K8R2;
	} else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 2)  & (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_WIN8; // REB 10/31/12 #34333
	} else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 2)  & (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2012; // REB 10/31/12 #34333
	}

	if (!bInternalCall) {
		PA_SetLongParameter( params, 1, returnValue );
		PA_SetTextParameter( params, 2, osvinfo.szCSDVersion, strlen(osvinfo.szCSDVersion) );
		PA_ReturnLong( params, returnValue );
	}
	return returnValue;	
}


// *******   end of plugin call modules **********


// supporting modules ---------------------------------------------



// ------------------------------------------------
// 
//  FUNCTION:  ComDlg32DlgProc
//
//  PURPOSE:	Callback function for Open/Save FileName Dialog modifications
//
//  COMMENTS:  Some callback features inspired by Shanker Chandrabose's code
//							Kids -- don't try this at home :)
//
//	DATE:  07/21/01
//
BOOL CALLBACK ComDlg32DlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	WORD		wNotifyCode	= HIWORD(wParam);
	WORD		wID					= LOWORD(wParam);					
	TCHAR		szPathName[255];

	switch (uMsg)
	{
		case WM_INITDIALOG :
			EnumChildWindows( (HWND)GetParent(hDlg), EnumChildProc, (LPARAM)NULL);
			hookHandles.openSaveHookHndl = SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC) theHook, (HINSTANCE) NULL, (DWORD)GetCurrentThreadId());		
			hookHandles.postProcHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC) postHook, (HINSTANCE) NULL, (DWORD)GetCurrentThreadId());		
			g_parentHndl = hDlg;
			break;

		case WM_COMMAND :
			if ((wNotifyCode == BN_CLICKED) & (wID == IDC_BUTTON1)) {
				GetDlgItemText(g_parentHndl, IDE_SELECTED, szPathName, MAX_PATH);
				strcpy(intrProcStr1, szPathName);

				// MJG 4/29/05 Invoke cancel button.  Don't forcibly close dialog.
				//SendMessage(g_parentHndl, WM_COMMAND, (WM_USER + 31488), 0L);
				g_FolderSelected = TRUE;
				PostMessage(GetParent(g_parentHndl), WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
			}
			
			break;

		case WM_NOTIFY :
			TestNotify( hDlg, (LPOFNOTIFY)lParam);

		default :
			return FALSE;
	}
	return TRUE;
}

// ------------------------------------------------
// 
//  FUNCTION: postHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Exit dialog using a different control
//
//  COMMENTS: OpenFile dialog has trouble closing without using		
//							IDOK, IDCANCEL or IDCLOSE.  IDOK requires
//							a file be selected.  A directory won't do.
//   
//	DATE:			dcc 07/30/01
//
LRESULT CALLBACK postHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{

	/*
	CWPRETSTRUCT	*cwprs		= (CWPRETSTRUCT*)lParam;

	if (cwprs->message == WM_COMMAND) {
		if (cwprs->wParam == (WM_USER + 31488)) {
			EndDialog(g_parentHndl, TRUE); //end the child dialog
			EndDialog(GetParent(g_parentHndl), TRUE); // now end the main dialog (parent)
			return TRUE;
		}
	}
	*/
	return CallNextHookEx(hookHandles.postProcHookHndl, hCode, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: theHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Process disable and hide controls
//
//	DATE:			dcc 07/14/01
//
//	MODIFICATIONS:  08/13/02 Corrected problem where FD_HIDE_UP_BUTTON
//					and FD_HIDE_NEWDIRECTORY_BUTTON could not be used
//					together.
//					04/14/04 Improved efficiency when working with 
//                  FD_SELECT_DIRECTORY. 

LRESULT CALLBACK theHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{
	
	TCHAR					szClassName[255];
	TCHAR					szItemName[255];
	TCHAR					szPathName[255];
	LVITEM				item;
	HANDLE				buttonToDisable;
	CWPSTRUCT			*cwps		= (CWPSTRUCT*)lParam;
	TBBUTTONINFO	tbInfo;
	BOOL					bChangeHiddenState = TRUE, bSelectedItem = FALSE;
	static INT_PTR		tbOnetime = 0;
	INT_PTR						count, i;

	if (windowHandles.openSaveTBhwnd == NULL) {
		tbOnetime = 0;
	}
	GetClassName(cwps->hwnd, szClassName, 255);

	if (strcmp(_strlwr(szClassName), "toolbarwindow32") == 0) {
		if (!tbOnetime) {
			windowHandles.openSaveTBhwnd = cwps->hwnd;
			++tbOnetime;
			if (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) {
				bChangeHiddenState = ShowWindow( windowHandles.openSaveTBhwnd, SW_HIDE);
			}
		}
	}
	if (strcmp(_strlwr(szClassName), "syslistview32") == 0) {
		if ( (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) | (FD_Flags & FD_HIDE_UP_BUTTON) ) {
			tbInfo.cbSize = sizeof(TBBUTTONINFO);
			tbInfo.dwMask = TBIF_STATE;
			tbInfo.fsState = TBSTATE_HIDDEN | TBSTATE_INDETERMINATE;
			if (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) {
				buttonToDisable = (HANDLE)NEWBUTTONFOLDER;
				SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM) &tbInfo);
			} //else { // 08/13/02 was either or.  Couldn't use both
			if (FD_Flags & FD_HIDE_UP_BUTTON) {
				buttonToDisable = (HANDLE)UPONELEVELBUTTON;
				SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM) &tbInfo);
			}
			//SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM) &tbInfo);
		}

		switch (cwps->message)
		{
			case WM_NCPAINT :
			case LAST_LISTVIEW_MSG :
				if ( FD_Flags & FD_FILES_ONLY ) {  // 4/14/04 Only perform filter if FD_FILES_ONLY is set.
					count = ListView_GetItemCount(cwps->hwnd);
					for( i = 0; i < count; i++)
					{
						item.mask = LVIF_TEXT | LVIF_PARAM;
						item.iItem = i;
						item.iSubItem = 0;
						item.pszText = szItemName;
						item.cchTextMax = 255;
						ListView_GetItem(cwps->hwnd, &item);
						if (GetFileAttributes(szItemName) & FILE_ATTRIBUTE_DIRECTORY) {
							//if ( FD_Flags & FD_FILES_ONLY ) {
							ListView_DeleteItem(cwps->hwnd, i);
							//}
						}
					}  //end for
				}
				//break;

			
			 case WM_NOTIFY :
				bSelectedItem = FALSE;
				strcpy(szPathName, "");

				if ( FD_Flags & FD_SELECT_DIRECTORY) {  // 4/14/04 Only perform search if FD_SELECT_DIRECTORY is selected

					// 4/14/04 Modified the code to directly get the selected item instead of looping
					// through each item in the list.
					i = ListView_GetNextItem (cwps->hwnd, -1, LVNI_ALL | LVNI_SELECTED);

					//count = ListView_GetItemCount(cwps->hwnd);
					//for( i = 0; i < count; i++)
					if (i != -1)
					{
						strcpy(szItemName, "");
						item.mask = LVIF_TEXT | LVIF_STATE;
						item.iItem = i;
						item.iSubItem = 0;
						item.stateMask = LVIS_SELECTED;
						item.pszText = szItemName;
						item.cchTextMax = 255;
						ListView_GetItem(cwps->hwnd, &item);
						if (GetFileAttributes(szItemName) & FILE_ATTRIBUTE_DIRECTORY) {
							//if ( FD_Flags & FD_SELECT_DIRECTORY) {
							if (item.state & LVIS_SELECTED) {
								strcpy(szPathName, intrProcStr1);
								if (szPathName[strlen(szPathName) - 1] != '\\') {
									strcat(szPathName, "\\");
								}
								strcat(szPathName, szItemName);
								SetDlgItemText(g_parentHndl, IDE_SELECTED, szPathName);
								bSelectedItem = TRUE;
								//break;
							}
							//}
						}
						
					}  //end if

					if (!bSelectedItem) {
						strcpy(szPathName, intrProcStr2);
						if (strlen(szPathName) > 0) {
							SetDlgItemText(g_parentHndl, IDE_SELECTED, intrProcStr1); 
						}
					}
				}
				
		}  // end switch
	} // if (strcmp(_strlwr(szClassName), "syslistview32") == 0)

	return CallNextHookEx(hookHandles.openSaveHookHndl, hCode, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
//
//  PURPOSE:	Disables Lookin and/or Edit controls in open/save dialogs
//
//  COMMENTS: Called in hook procedure of open/save dialogs
//						Global FD_Flags used to determine which option
//	DATE:			dcc 07/10/01
//
BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
{
	INT_PTR			ctrlID;
	BOOL		bWindowEnabled;
	ctrlID = GetDlgCtrlID(hWnd);

	switch(ctrlID)
	{
		case LOOK_IN_COMBO:
			if (FD_Flags & FD_DISABLE_LOOKIN_FIELD) {
				bWindowEnabled = EnableWindow(hWnd, FALSE);
			}
			break;
		case EDIT_FIELD:
			if (FD_Flags & FD_DISABLE_EDIT_FIELD) {
				bWindowEnabled = EnableWindow(hWnd, FALSE);
			}
			break;
	}

	return TRUE;
}


// ------------------------------------------------
// 
//  FUNCTION: TestNotify(HWND hDlg, LPOFNOTIFY pofn)
//
//  PURPOSE:  Used when Directory Selection is in play
//
//  COMMENTS:
//   
//	DATE:			dcc 07/23/01
//
BOOL NEAR PASCAL TestNotify(HWND hDlg, LPOFNOTIFY pofn)
{

	switch (pofn->hdr.code)
	{
		case CDN_SELCHANGE :
		case CDN_FOLDERCHANGE : // A new folder has been opened.
		{
			char szFile[MAX_PATH];

			// Get the path of the selected file.
			if (CommDlg_OpenSave_GetFilePath(GetParent(hDlg),
				szFile, sizeof(szFile)) <= sizeof(szFile))
			{
				strcpy(intrProcStr2, szFile);
			}
			if (CommDlg_OpenSave_GetFolderPath(GetParent(hDlg), szFile, sizeof(szFile)) 
				<= sizeof(szFile)) {
				strcpy(intrProcStr1, szFile);
			}
		}
		break;
	}

	return TRUE;
}



// ------------------------------------------------
// 
//  FUNCTION: GetPlugInFullName( char *PlugInFullName)
//
//  PURPOSE:  Gets full path for WIN32API.4dx file.
//
//  COMMENTS: Needed to determine where to look for extra resources
//						Open file dialog etc  
//						     
//	DATE: dcc 07/27/01
//
void GetPlugInFullName( char *PlugInFullName)
{
// MWD 10/21/05 #9246
// Use path name to 4DX obtained from entry point as opposed to Client/Server differentiation scheme.

	//char		tmpString[255];
	//check for client or stand-alone
/*
	if ( PA_Is4DClient() ) {
		// get 4d folder, append structure name, append win4dx\Win32API.4dx
		PA_Get4Dfolder(PlugInFullName);
		PA_GetStructureName(tmpString);
		strcat(PlugInFullName, tmpString);
		strcat(PlugInFullName, "\\win4dx\\win32api.4dx");
	} else {
		PA_GetStructureFullPath(PlugInFullName);
		strcat(PlugInFullName, "win4dx\\win32api.4dx");
	}
*/
  strcpy(PlugInFullName, pathName);
	return;
}

//  RETAIN FOR DEBUGGING
//  FUNCTION: ProcessCDError(DWORD) 
//
//  PURPOSE: Processes errors from the common dialog functions.
//
//  COMMENTS:
//
//        This function is called whenever a common dialog function
//        fails.  The CommonDialogExtendedError() value is passed to
//        the function which maps the error value to a string table.
//        The string is loaded and displayed for the user. 

void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
	WORD			wStringID;
  TCHAR			buf[MAX_PATH];
	HMODULE		hMod;
	char			plugInPath[255];

	GetPlugInFullName(plugInPath);
	hMod = GetModuleHandle(plugInPath);
  switch(dwErrorCode)
      {
	 case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break;
	 case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break;
	 case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break;
	 case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break;
	 case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break;
	 case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break;
	 case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break;
	 case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break;
	 case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break;
	 case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break;
	 case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break;
	 case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break;
	 case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break;
	 case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break;
	 case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break;
	 case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break;
	 case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break;
	 case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break;
	 case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break;
	 case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break;
	 case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break;
	 case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break;
	 case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break;
	 case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break;
	 case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break;
	 case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break;
	 case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break;

	 case 0:   //User may have hit CANCEL or we got a *very* random error
	    return;

	 default:
	    wStringID=IDS_UNKNOWNERROR;
      }

   LoadString(hMod, wStringID, buf, sizeof(buf));
   MessageBox(hWnd, buf, NULL, MB_OK);
   return;
}

void	FormatIP(char *rStr, LPARAM dwIP)
{
	char			addrSegment[4];
	BYTE			firstAddr, secondAddr, thirdAddr, fourthAddr;


	strcpy(rStr, "");
	firstAddr = FIRST_IPADDRESS(dwIP);
	secondAddr = SECOND_IPADDRESS(dwIP);
	thirdAddr = THIRD_IPADDRESS(dwIP);
	fourthAddr = FOURTH_IPADDRESS(dwIP);
	_itoa(fourthAddr, addrSegment, 10);
	strcat(rStr, addrSegment);
	strcat(rStr, ".");
	_itoa(thirdAddr, addrSegment, 10);
	strcat(rStr, addrSegment);
	strcat(rStr, ".");
	_itoa(secondAddr, addrSegment, 10);
	strcat(rStr, addrSegment);
	strcat(rStr, ".");
	_itoa(firstAddr, addrSegment, 10);
	strcat(rStr, addrSegment);

	return;
}


HWND getWindowHandle(char* windowTitle, HWND hWnd)
{
	HWND			MDIhWnd, MainhWnd, ChildhWnd, NexthWnd, returnValue = 0;
	char			WindowName[255];
	char			szClassName[255];
	LONG_PTR			windowTitle_len;
	
	windowTitle_len = strlen(windowTitle);
	if(IsWindow(hWnd)) {
		NexthWnd = hWnd;
		GetClassName(NexthWnd, szClassName, 255);
		do {
			if (strcmp(_strlwr(szClassName), "mdiclient") == 0) {
				windowHandles.MDIhWnd = NexthWnd;
				MDIhWnd = NexthWnd;
				if (strcmp(_strlwr(windowTitle), "mdi") == 0) {
					return NexthWnd;
				} else {
					break;
				}
			}
			MDIhWnd = NexthWnd;
			NexthWnd = GetParent(MDIhWnd);
			GetClassName(NexthWnd, szClassName, 255);
		} while (NexthWnd != NULL);

	} else {
	  returnValue = 0;
		return returnValue;
	}

	if(IsWindow(MDIhWnd)) {
		// Now if the caller wants the main window the
		// windowTitle will be blank
		if (windowTitle_len == 0) {
			// Get the parent of the MDI Window
			 // REB 4/14/11 #25290 If we already have the main window handle make sure
			 // we use it.
			if(IsWindow(GetParent(MDIhWnd))){
				MainhWnd = GetParent(MDIhWnd);
			}else{
				MainhWnd = MDIhWnd; 
			}

			if(IsWindow(MainhWnd)) {
			  returnValue = MainhWnd;
			  return returnValue;
			} else {
			  returnValue = 0;
			  return returnValue;
			}
		} else {
			// Search all the child windows for the window 
			// with a Title matching windowTitle
			NexthWnd = GetWindow(MDIhWnd,GW_CHILD);
			do {
				ChildhWnd = NexthWnd;
				if (IsChild(MDIhWnd,ChildhWnd)) {
					GetWindowText(ChildhWnd,WindowName,256);
					GetClassName(ChildhWnd, szClassName, 255);
					if ((strcmp(_strlwr(szClassName), "mdiclient") == 0) && (strcmp(_strlwr(windowTitle), "mdi") == 0)){
						return ChildhWnd;
					}
					NexthWnd = GetNextWindow(ChildhWnd,GW_HWNDNEXT);
				} else {
					returnValue = 0;
					return returnValue;
				}
			} while (strcmp(_strlwr(windowTitle),_strlwr(WindowName)) != 0);
			// Match found
			returnValue = ChildhWnd;
		}
	} else {
	  returnValue = 0;
	}
	return returnValue;
}


//  FUNCTION: newProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept procedure for 4D window
//
//  COMMENTS:	Used with sys_GetPrintJob and gui_SetTrayIcon functions
//
//	DATE:		dcc 11/17/01

LRESULT APIENTRY newProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND					printWndHndl = NULL, childhWnd = NULL, nexthWnd = NULL;
	LONG_PTR					command; // 01/22/03
	static LONG_PTR		count = 1;
	char					windowName[255];
	char					dlgCaption[15];

	switch (uMsg)
	{
			
		case (WM_USER + 0x0021) :
			if ((lParam == WM_LBUTTONDOWN) || (lParam == WM_RBUTTONDOWN) || (lParam == WM_LBUTTONDBLCLK) || (lParam == WM_RBUTTONDBLCLK)) {
		
				processWindowMessage(TRAY_ICON_FUNCTION, (LONG_PTR)hwnd, wParam, lParam);
			}
			break;
		// 01/22/03 added check for maximize
		case WM_SYSCOMMAND : //this tells a subsequent WM_GETMINMAXINFO command
				// that it is okay to proceed if we are in the process of a maximize command.
			if (toolBarRestrictions.toolBarOnDeck) {
				command = wParam & 0xFFF0;
				if ((SC_MAXIMIZE == command) || (SC_SIZE == command) || (SC_RESTORE == command)) {
					//get frontmost window
					childhWnd = GetTopWindow(windowHandles.MDIhWnd);
					if (IsZoomed(childhWnd)) {
						switch (command)
						{
							case SC_MAXIMIZE :
								toolBarRestrictions.appBeingMaxed = APP_MAXIMIZING;
								break;

							case SC_RESTORE :
								toolBarRestrictions.appBeingMaxed = APP_RESTORING;
								//ShowWindowAsync (childhWnd, SW_SHOWMAXIMIZED);
								break;

							case SC_SIZE :
								toolBarRestrictions.appBeingMaxed = APP_SIZING_W_CHLDMAX;
								if (IsZoomed(windowHandles.fourDhWnd)) {
									toolBarRestrictions.appWindowState = APP_MAXIMIZED;
								} else {
									toolBarRestrictions.appWindowState = APP_NORM;
								}
								//PostMessage(childhWnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
								break;

						}
						//command = (LONG_PTR)childhWnd;
						//command *= -1;
					} else {
						processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, command, 0L, 0L);
					}
				}
			}
			break;

		case WM_EXITSIZEMOVE : // 01/27/03
			if (toolBarRestrictions.appBeingMaxed == APP_SIZING_W_CHLDMAX) {
				toolBarRestrictions.appBeingMaxed = 0;
				processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, WM_EXITSIZEMOVE, 0L, 0L);
			}
			break;

		case WM_SIZE :
			if ((toolBarRestrictions.appBeingMaxed == APP_MAXIMIZING) || (toolBarRestrictions.appBeingMaxed == APP_RESTORING)) {
				processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, toolBarRestrictions.appBeingMaxed, 0L, 0L);
			}
			break;

		default :
			// g_intrProcMsg will be PS_IDLE unless print dialogs have been requested
			if ((g_intrProcMsg != PS_IDLE) && (count % 5 == 0) && (g_intrProcMsg < 2)) {
				if (g_intrProcMsg == 0) { // 12/12/01
					strcpy(dlgCaption,"Print Setup");
				} else {
					strcpy(dlgCaption,"Print");
				}
				if ((g_intrProcMsg == 0) || ((g_intrProcMsg == 1) && (strcmp(dlgCaption, "Print") == 0))) {
					nexthWnd = GetWindow(hwnd,GW_HWNDPREV);
					do {
						childhWnd = nexthWnd;
						GetWindowText(childhWnd,windowName,256);
						if (strcmp("Print", windowName) == 0){  // AMS2 11/19/14 #40697 Fixed detection of Print Job window, previously the method assumed that it would always see Print Setup before Print Job. 
							strcpy(dlgCaption, "Print");
							g_intrProcMsg = 1;
						}
						nexthWnd = GetNextWindow(childhWnd,GW_HWNDPREV);
						if (nexthWnd == NULL) {
							count += 1;
							return CallWindowProc(processHandles.wpFourDOrigProc, hwnd, uMsg, wParam, lParam);
						}
					} while (strcmp(dlgCaption,windowName) != 0);
 					// Match found
					printWndHndl = childhWnd;

					if (printWndHndl > 0) {
						strcpy(dlgCaption, "Print");
						g_intrProcMsg += 1;
						switch (g_intrProcMsg)
						{
							case 1 :
								windowHandles.prthWnd = 0;
								// REB 3/18/11 #25290
								processHandles.wpPrintSettingsDlgOrigProc = (WNDPROC) SetWindowLongPtr(printWndHndl, DWLP_DLGPROC, (LONG_PTR) newPrtSettingsDlgProc);
								//processHandles.wpPrintSettingsDlgOrigProc = (WNDPROC) SetWindowLong(printWndHndl, DWL_DLGPROC, (LONG) newPrtSettingsDlgProc);
								windowHandles.prtSettingshWnd = printWndHndl;
								break;

							case 2 :
								// REB 3/18/11 #25290
								processHandles.wpPrintDlgOrigProc = (WNDPROC) SetWindowLongPtr(printWndHndl, DWLP_DLGPROC, (LONG_PTR) newPrtDlgProc);
								//processHandles.wpPrintDlgOrigProc = (WNDPROC) SetWindowLong(printWndHndl, DWL_DLGPROC, (LONG) newPrtDlgProc);
								//restoreOrig4DWindowProcess(); // 01/21/03 // MJG 3/26/04 The 4D window will remain subclassed until the plug-in is unloaded.
								//if (activeCalls.bTrayIcons == FALSE) {
									//SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) processHandles.wpFourDOrigProc);
								//}
								windowHandles.prthWnd = printWndHndl;
								break;
						} // end switch
					} //(printWndHndl > 0)
				} //((g_intrProcMsg == 1) && (strcmp(dlgCaption, "Print") == 0))
			} //((count % 10 == 0) && (g_intrProcMsg < 2)) 

			count += 1;
	} // end switch
	
	return CallWindowProc(processHandles.wpFourDOrigProc, hwnd, uMsg, wParam, lParam);

}


//  FUNCTION: newDlgPrtSettingsProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept print setup dialog 
//
//  COMMENTS:	
//
//	DATE:			dcc 11/17/01

LRESULT APIENTRY newPrtSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	if (hookHandles.printSettingsHookHndl == NULL) {
		hookHandles.printSettingsHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC) printSettingsDlgHook, (HINSTANCE) NULL, (DWORD)GetCurrentThreadId());		
	}
	return CallWindowProc(processHandles.wpPrintSettingsDlgOrigProc, hwnd, uMsg, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: printSettingsDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Get change of printer if combo box accessed
//
//	DATE:			dcc 11/17/01
//
LRESULT CALLBACK printSettingsDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{
	CWPRETSTRUCT	*cwrps	= (CWPRETSTRUCT*)lParam;

	if (cwrps->message == WM_COMMAND) {
		EnumChildWindows( windowHandles.prtSettingshWnd, EnumChildProc2, (LPARAM)PS_PRTSETTINGSDLG );
	}
	return CallNextHookEx(hookHandles.printSettingsHookHndl, hCode, wParam, lParam);
}


//  FUNCTION: newPrtDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept print dialog 
//
//  COMMENTS:	
//
//	DATE:			dcc 11/17/01

LRESULT APIENTRY newPrtDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	if (hookHandles.printHookHndl == NULL) {
		UnhookWindowsHookEx(hookHandles.printSettingsHookHndl);
		hookHandles.printSettingsHookHndl = NULL;
		hookHandles.printHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC) printDlgHook, (HINSTANCE) NULL, (DWORD)GetCurrentThreadId());		
	}
	return CallWindowProc(processHandles.wpPrintDlgOrigProc, hwnd, uMsg, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: printDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Get change of printer if combo box accessed
//
//	DATE:			dcc 11/17/01
//
LRESULT CALLBACK printDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{
	
	CWPRETSTRUCT	*cwrps	= (CWPRETSTRUCT*)lParam;

	if (cwrps->message == WM_COMMAND) {
		EnumChildWindows( windowHandles.prthWnd, EnumChildProc2, (LPARAM)PS_PRTDLG );
	}

	return CallNextHookEx(hookHandles.printHookHndl, hCode, wParam, lParam);
}

// ------------------------------------------------
// 
//  FUNCTION: CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam)
//
//  PURPOSE:	Find combo box ID with printer names
//
//  COMMENTS: Possible chg this later to constant control ID of 1136
//						
//	DATE:			dcc 10/23/01
//
//  MODIFICATIONS: 11/05/02 Added ID var to better debug.  Also added control ID 1136 for 
//									comboBox on PrintSettings dialog. (3.5.2)
BOOL CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam)
{
	char						szClassName[255];
	char						comboText[80];
	char						printerName[255];
	LPCTSTR						capabilities[255];
	LONG_PTR						comboText_len = strlen(comboText), ID;
	LRESULT						ndx;
	BOOL						bTrans = FALSE, bSigned = FALSE;
	DEVMODE						*printerInfo;
	DEVMODE						*printInput;
	LPCTSTR						deviceName, pPort;
	LPBYTE						printerBuffer;
	PRINTER_INFO_2				*pInfo;
	HANDLE						hPrintHandle = NULL;
	DWORD						dwPrinterSize;
	DWORD						dwLevel = 2;
	DWORD						dwBuffer = sizeof(PRINTER_INFO_2);

	GetClassName(hWnd, szClassName, 255);

	if (strcmp(_strlwr(szClassName), "combobox") == 0) {
		ID = GetDlgCtrlID(hWnd);
		switch (ID)
		{
			case ID_CB_PRINTER :
			case 1136:
				ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
				SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.printerSelection);
				break;
			case ID_CB_PAPERSIZE :
				ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
				SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.size);
				break;
			case ID_CB_SOURCE :
				ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
				SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.source);
				break;
		}
	}
	if (strcmp(_strlwr(szClassName), "button") == 0) {
		ID = GetDlgCtrlID(hWnd);
	
		switch (ID)
		{
			case ID_BTN_PORTRAIT :
				if (lParam == PS_PRTSETTINGSDLG) {
					if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
						printerSettings.portraitLandscape = PS_PORTRAIT;
					} else {
						printerSettings.portraitLandscape = PS_LANDSCAPE;
					}
				}
				break;

			case ID_BTN_PRINTTOFILE :
				if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
					printerSettings.printToFile = TRUE;
				} else {
					printerSettings.printToFile = FALSE;
				}
				break;
			case ID_BTN_PRINTPREVIEW :
				if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
					printerSettings.printPreview = TRUE;
				} else {
					printerSettings.printPreview = FALSE;
				}
				break;
			
		}
	}
	if (strcmp(_strlwr(szClassName), "edit") == 0) {
		// REB 5/13/08 #16829 Storing control ID in ID now.
		ID = GetDlgCtrlID(hWnd);
		switch (ID)
		{
			case ID_EDIT_COPIES :
				ndx = SendMessage(hWnd, WM_GETTEXT, (WPARAM)4, (LPARAM)printerSettings.copies);
				printerSettings.copies[ndx] = '\0';
				break;

		}
	}
	
	// AMS2 11/26/14 #40697 Below is an attempt to get the printer information that is not visible on the print job dialog with the scanner above.
	// The part that is causing problems is the call to DocumentProperties. I'm not sure if that is the correct window handle to pass in, but the printer handle/device name and other parameters seem to be correct.
	// The issue is that the printerInfo that is returned does not match the settings that are input. I attempted to move this to sys_getPrintSettings but the PA parameter for the return array seemed to be replaced with a null address instead of the array's address. 
	/*
		if (strlen(printerSettings.printerSelection) != 0){

			strcpy(printerName, printerSettings.printerSelection);
			OpenPrinter(printerName, &hPrintHandle, NULL); // get the handle
			//printerBuffer = &pInfo;
			LONG result = GetPrinter(hPrintHandle, dwLevel, NULL, 0, &dwPrinterSize); // get the info for the printer

			PRINTER_INFO_2	*pInfo = (PRINTER_INFO_2*)malloc(dwPrinterSize);
			GetPrinter(hPrintHandle, 2, (LPBYTE)pInfo, dwPrinterSize, &dwPrinterSize);

			deviceName = pInfo->pPrinterName;
			pPort = pInfo->pPortName;
			//DeviceCapabilities(deviceName, pPort, DC_SIZE, capabilities, NULL);
			//DocumentProperties(hWnd, hPrintHandle, deviceName, printerInfo, printInput, DM_OUT_BUFFER); //windowHandles.prthWnd
			ClosePrinter(hPrintHandle);
	
		}
	*/
	return TRUE;
}

// ------------------------------------------------
// 
//  FUNCTION: enumPrintersUsingRegistry( PA_Variable *printerArray )
//
//  PURPOSE:	Alternative function for enum printers
//
//  COMMENTS: Uses registry for NT/2000/XP 
//						Returns positon of default printer in array
//						
//	DATE:			dcc 04/20/02
//

LONG_PTR enumPrintersUsingRegistry( PA_Variable *printerArray )
{
	LONG_PTR					returnValue = 0, errorCode;
	HKEY					hKeyWindows, hKeyDevices, rootKey;
	char					subKey[100];
	DWORD					dwIndex = 0;
	DWORD					dwType = REG_SZ;
	DWORD					resultSize = 150, dataSize = 150;
	char					sz[150], szData[150], defPrinter[150];

	// get default printer
	strcpy ( subKey, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows");

	rootKey = HKEY_CURRENT_USER; //HKEY_LOCAL_MACHINE;
	hKeyWindows = HKEY_CURRENT_USER; // will get new handle of open key
	hKeyDevices = HKEY_CURRENT_USER;
	errorCode = RegOpenKeyEx ( rootKey, subKey, 0, KEY_READ, &hKeyWindows );
	if (errorCode != ERROR_SUCCESS) {
		return returnValue;;
	}
	
	errorCode = RegQueryValueEx ( hKeyWindows, "Device", NULL, &dwType, szData, &resultSize );
	if (errorCode != ERROR_SUCCESS) {
	} else {
		strcpy(defPrinter, szData);
	} //(errorCode != ERROR_SUCCESS) 
	errorCode = RegCloseKey( hKeyWindows );

	strcpy ( subKey, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Devices");
	errorCode = RegOpenKeyEx ( rootKey, subKey, 0, KEY_READ, &hKeyDevices );
	if (errorCode != ERROR_SUCCESS) {
		return returnValue;;
	}
	resultSize = 150;
	errorCode = RegEnumValue( hKeyDevices, dwIndex, sz, &resultSize, NULL, &dwType, szData, &dataSize);
	while(errorCode != ERROR_NO_MORE_ITEMS)
	{
		if (errorCode == ERROR_SUCCESS) {
			// get data for device (printer)	
				PA_ResizeArray(printerArray, (LONG_PTR) dwIndex + 1);
				strcat(sz, ",");
				strcat(sz, szData);
				if (strcmp(sz, defPrinter) == 0) {
					returnValue = dwIndex + 1;
				}
				PA_SetTextInArray (*printerArray, dwIndex + 1, sz, strlen(sz));
		}
		dwIndex++;
		resultSize = 150;
		dataSize = 150;
		errorCode = RegEnumValue( hKeyDevices, dwIndex, sz, &resultSize, NULL, &dwType, szData, &dataSize);
	}

	errorCode = RegCloseKey( hKeyDevices );
	return returnValue;
}

// ------------------------------------------------
// 
//  FUNCTION: enumPrintersUsingINI( PA_Variable *printerArray )
//
//  PURPOSE:	Alternative function for enum printers
//
//  COMMENTS: Uses Win.ini file for 95/98/Me
//						Returns positon of default printer in array
//						
//	DATE:			dcc 04/20/02
//

LONG_PTR enumPrintersUsingINI( PA_Variable *printerArray )
{
	LONG_PTR					returnValue = 0, count = 0, pSectionBuf_len = 0;
	char					szSectionName[80], szKeyName[80], szDefault[80];
	char					defPrinter[80], szSectionBuf[1000], szDevice[80], sep[3]; // increased sep from 2 to 3
	char					*pToken = NULL, *pSectionBuf = NULL;
	DWORD					dwSize = 80, dwReturn;


	// get default printer
	strcpy( szSectionName, "Windows");
	strcpy( szKeyName, "Device");
	dwReturn = GetProfileString( szSectionName, szKeyName, szDefault, defPrinter, dwSize );

	//now get all printers registered
	strcpy(szSectionName, "Devices");
	dwSize = 1000;

	dwReturn = GetProfileSection( szSectionName, szSectionBuf, dwSize );
	strcpy(sep, ",=");
	pSectionBuf = szSectionBuf;
	pToken = strtok(szSectionBuf, sep);
	pSectionBuf = pToken;
	strcpy(szDevice, "");
	count = 0;
	while (pToken != NULL)
	{
		if (szDevice[0] == '\0') {
			strcpy(szDevice, pToken);
			count++;
		} else {
			strcat(szDevice, ",");
			strcat(szDevice, pToken);
		}
		pToken = strtok(NULL, sep);
		// write info to array and then look for next device
		if (pToken == NULL) {
			if (strcmp(szDevice, defPrinter) == 0) {
				returnValue = count;
			}
			PA_ResizeArray(printerArray, count);
			PA_SetTextInArray (*printerArray, count, szDevice, strlen(szDevice));
			pSectionBuf_len = strlen(pSectionBuf);
			pSectionBuf = pSectionBuf + (pSectionBuf_len + 1);
			if (*pSectionBuf != '\0') {
				strcpy(szDevice, "");
				pToken = strtok(pSectionBuf, sep);
			}
		} else {
			pSectionBuf = pToken;
		}
	}
	return returnValue;
}




// ------------------------------------------------
// 
//  FUNCTION: sys_GetTimeZoneList( PA_PluginParameters params )
//
//  PURPOSE:  Returns an array containing time zone information for all time zones
//				defined on the system.  Each element is in the form:
//				TimeZoneName;Current Time;Current Date
//  
//
//  REB 4/6/09 #19472  
//



void sys_GetTimeZoneList( PA_PluginParameters params )
{
	PA_Variable		atTZ; 
	char			standardName[255];
	char			daylightName[255];
	char			displayName[255];
	LONG_PTR			displayName_len;
	LONG_PTR			returnValue, errorCode;
	HKEY			hkTimeZone, hkRootKey;
	char			TimeStr[255];
	char			hours[2];
	char			mins[2];
	char			secs[2];
	char			DateStr[255];
	char			month[2];
	char			day[2];
	char			year[10];
	char			TZ[512];
	DWORD			dwSubKeys, dwValues, dwDataSize;
	REG_TZI_FORMAT	TZInfoFormat;
	DWORD			index = 1;
	char			rootTimeZoneKey[60] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";
	DWORD			dwIndex = 0;
    TCHAR			tcKeyName[512];
    DWORD			dwcbName = 512 * sizeof( TCHAR );
    FILETIME		ftLastWrite;
	TIME_ZONE_INFORMATION TimeZoneInformation;
	SYSTEMTIME		SystemTimeNow, LocalTime;	

	// For some reason we are unable to return 3 arrays to 4D.  Instead we'll return
	// a single array with all three data items in semicolon delimited elements.

	atTZ = PA_GetVariableParameter( params, 1);
	PA_ResizeArray( &atTZ, 0);
	
	returnValue = -1; // Assume we fail, this is set to the number of time zones once we successfully open the root TZ key.

	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,rootTimeZoneKey,0,KEY_READ,&hkRootKey) == ERROR_SUCCESS )
	{
		if(RegQueryInfoKey(hkRootKey, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
		{
			PA_ResizeArray( &atTZ, dwSubKeys );
			
			returnValue = dwSubKeys; // Return the number of time zones we've found.
			
			while( RegEnumKeyEx(hkRootKey,dwIndex++,tcKeyName,&dwcbName,NULL,NULL,NULL,&ftLastWrite) != ERROR_NO_MORE_ITEMS )
			{
			    if( RegOpenKeyEx(hkRootKey,tcKeyName,0,KEY_READ,&hkTimeZone) == ERROR_SUCCESS )
			    {
		            // Get TZI Upper Bytes
	                dwDataSize = sizeof( TZInfoFormat );
	               	errorCode = RegQueryValueEx(hkTimeZone,"TZI",NULL,NULL,(BYTE*)&TZInfoFormat,&dwDataSize);
					
					TimeZoneInformation.Bias = TZInfoFormat.Bias ;
					TimeZoneInformation.DaylightBias = TZInfoFormat.DaylightBias ;
					TimeZoneInformation.DaylightDate = TZInfoFormat.DaylightDate ;
					TimeZoneInformation.StandardBias = TZInfoFormat.StandardBias ;
					TimeZoneInformation.StandardDate = TZInfoFormat.StandardDate ;
					
	                // Get Text Values
					dwDataSize = 255;
					if(RegQueryValueEx(hkTimeZone,"Display",NULL,NULL,(LPBYTE)&displayName,&dwDataSize) != ERROR_SUCCESS)
					{
						strcpy(displayName, "n/a");
					}
					displayName_len = strlen(displayName);
					
					strcpy(TZ, displayName);
			
					dwDataSize = 255;
					if(RegQueryValueEx(hkTimeZone,"Dlt",NULL,NULL,(LPBYTE)&daylightName,&dwDataSize) != ERROR_SUCCESS)
					{
						strcpy(daylightName, "n/a");
					}

					mbstowcs(TimeZoneInformation.DaylightName, daylightName, dwDataSize);
					
					dwDataSize = 255;
	                if(RegQueryValueEx(hkTimeZone,"Std",NULL,NULL,(LPBYTE)&standardName,&dwDataSize) != ERROR_SUCCESS)
					{
						strcpy(standardName, "n/a");
					}
					mbstowcs(TimeZoneInformation.StandardName, standardName, dwDataSize);

					RegCloseKey( hkTimeZone );
					
					// Get the current time in UTC
					GetSystemTime(&SystemTimeNow); 
					
					// Get the current time in the specified time zone.
					SystemTimeToTzSpecificLocalTime(&TimeZoneInformation, &SystemTimeNow, &LocalTime);
					
					_itoa(LocalTime.wHour, hours, 10);
					_itoa(LocalTime.wMinute, mins, 10);
					_itoa(LocalTime.wSecond, secs, 10);

					strcpy (TimeStr,hours);
					strcat (TimeStr,":");
					strcat (TimeStr,mins);
					strcat (TimeStr,":");
					strcat (TimeStr,secs);
					
					strcat (TZ, ";");
					strcat (TZ, TimeStr);
					
					_itoa(LocalTime.wDay, day, 10);
					_itoa(LocalTime.wMonth, month, 10);
					_itoa(LocalTime.wYear, year, 10);
					
					strcpy (DateStr,month);
					strcat (DateStr,"/");
					strcat (DateStr,day);
					strcat (DateStr,"/");
					strcat (DateStr,year);
					
					strcat (TZ, ";");
					strcat (TZ, DateStr);
					
					strcpy (TZ, displayName);
					strcat (TZ, ";");
					strcat (TZ, TimeStr);
					strcat (TZ, ";");
					strcat (TZ, DateStr);
					
					PA_SetTextInArray(atTZ, index, TZ, strlen(TZ));
				}
				dwcbName = 512 * sizeof( TCHAR );
				++index;
			}
		}
		RegCloseKey( hkRootKey );

	}
	
	PA_SetVariableParameter( params, 1, atTZ, 0);	

	PA_ReturnLong( params, returnValue );
	
}



void TWAIN_GetSources ( PA_PluginParameters params )
{

	LONG_PTR			returnValue, OK, state, debug;
	DWORD			index = 1;
	PA_Variable		atSources;
	TW_IDENTITY		NewSourceId;

	atSources = PA_GetVariableParameter( params, 1 );
	PA_ResizeArray( &atSources, 0 );

	debug = PA_GetLongParameter( params, 2 );

	returnValue = -1;
	
	if (debug) returnValue = TWAIN_SelectImageSource(windowHandles.fourDhWnd);	

    memset(&NewSourceId, 0, sizeof NewSourceId);

	state = TWAIN_State();

	if (state >= TWAIN_SM_OPEN || TWAIN_OpenSourceManager(windowHandles.fourDhWnd)) {
		OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETFIRST, &NewSourceId);
		if(!(debug)){
			returnValue = OK;
		}
		while (OK){
			PA_ResizeArray( &atSources, index);
			PA_SetTextInArray(atSources, index, NewSourceId.ProductName, strlen(NewSourceId.ProductName));
			++index;
			OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETNEXT, &NewSourceId);
		}
	}

	PA_SetVariableParameter( params, 1, atSources, 0);
	PA_ReturnLong( params, returnValue );
}


void TWAIN_SetSource ( PA_PluginParameters params )
{
	LONG_PTR			returnValue, OK, state;
	TW_IDENTITY		NewSourceId;
	LONG_PTR			source_len;
	char			sourceName[255];

	source_len = PA_GetTextParameter( params, 1, sourceName );
    sourceName[source_len] = '\0'; 

	returnValue = 0;

    memset(&NewSourceId, 0, sizeof NewSourceId);

	// If the source is already open, close it to reset the connection.
	state = TWAIN_State();
	if (state >= TWAIN_SOURCE_ENABLED){
		OK = TWAIN_EndXfer();
		OK = TWAIN_AbortAllPendingXfers();
		OK = TWAIN_CloseSource();
	}

	if (state >= TWAIN_SM_OPEN || TWAIN_OpenSourceManager(windowHandles.fourDhWnd)) {
		OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETFIRST, &NewSourceId);
		while (OK){
			if (strcmp(sourceName, NewSourceId.ProductName) == 0){
				OK = 0;
				returnValue = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_OPENDS, &NewSourceId);
			}else{
				OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETNEXT, &NewSourceId);
			}
		}
	}
	
	PA_ReturnLong( params, returnValue );
}




// REB 2/26/13 #35165 Intermediary method we can call as a new thread.
unsigned __stdcall TWAIN_GetImage (void *arg)
{
	LONG_PTR		returnValue = 0;
	TWAIN_CAPTURE*	TWAINCapture;

	TWAINCapture = (TWAIN_CAPTURE*)arg;
	TWAIN_UnloadSourceManager();  // REB 2/26/13 #35165 We have to reset our source before trying to acquire an image.
	TWAINCapture->DIBHandle = TWAIN_AcquireNative( NULL, TWAIN_ANYTYPE, &returnValue);

	TWAINCapture->done = TRUE;
	TWAINCapture->returnValue = returnValue;
	
}

void TWAIN_AcquireImage ( PA_PluginParameters params )
{

	LONG_PTR		returnValue = 0, showDialog, threadID;
	char*			charPos;
	char			fileName[255] = "";
	char			fileName2[255] = "";
	char*			pathName, *pch = NULL;
	char			command[255] = "";
	char			pathChar[1] = "\\";
	HANDLE			DIBHandle = NULL;
	HANDLE			CaptureThread;
	PA_Unistring	Unistring;
	TWAIN_CAPTURE	TWAINCapture; // REB 2/26/13 #35165
	char *BLOB = NULL; // AMS 7/3/14 #39391
	LONG_PTR len = 0; // AMS 7/3/14 #39391

	showDialog = PA_GetLongParameter( params, 1 );

	// AMS 7/3/14 #39391 Get the blob parameter
	BLOB = NULL;
	len = PA_GetBlobParameter(params, 2, NULL);
	BLOB = malloc(len);
	len = PA_GetBlobParameter(params, 2, BLOB);

	Unistring = PA_GetApplicationFullPath(); // REB 4/20/11 #27322
	pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322 #27490 Fixed method call.
	charPos = strrchr(pathName,'\\');
	strncpy (fileName, pathName,(charPos-pathName+1));
	strcat(fileName, "\TWNIMG.bmp");

	pch = fileName;

	charPos = strchr(fileName, '\\');
	while(charPos != NULL){
		strncat(fileName2, pch, (charPos-pch));
		pch = charPos;
		charPos = strchr((charPos + 1), '\\');
		if(charPos != NULL){
			strcat(fileName2, "\\");
		}else{
			// add the remainder of fileName to fileName2.
			strcat(fileName2, "\\");
			strcat(fileName2, pch);
		}
	}

	// Allow the image dialog to display if so desired.
	if (showDialog){
		TWAIN_SetHideUI(0); 
	}else{
		TWAIN_SetHideUI(1); 
	}	

	// REB 2/26/13 #35165 Load our variables into the structure we can pass to the new thread
	TWAINCapture.returnValue = 0;
	TWAINCapture.DIBHandle = DIBHandle;
	TWAINCapture.done = FALSE;
	
	//DIBHandle = TWAIN_AcquireNative( windowHandles.fourDhWnd, TWAIN_ANYTYPE, &returnValue);
	// REB 2/26/13 #35165 Start a new thread to handle the image acquisition so that we can yield time
	// back to 4D to prevent an application timeout.
	CaptureThread = (HANDLE)_beginthreadex(NULL, 0, TWAIN_GetImage, &TWAINCapture, 0, &threadID);

	// REB 2/26/13 #35165 4D says to call this at least three times when starting an external process.
	// That's not exactly what we're doing but I'll err on the side of caution.
	PA_YieldAbsolute();
	PA_YieldAbsolute();
	PA_YieldAbsolute();

	// Yield time back to 4D until the capture is finished.
	while(TWAINCapture.done == FALSE){
		PA_YieldAbsolute();
	}

	// REB 2/26/13 #35165 Now get the values from the structure
	DIBHandle = TWAINCapture.DIBHandle;
	returnValue = TWAINCapture.returnValue;


	// Updated so that return code is 1 for success, 0 for cancel and negative for error codes.
	// Suppress eztwain error dialogs
	if (DIBHandle != NULL && returnValue >= 0){
		returnValue = TWAIN_WriteNativeToFilename(DIBHandle, fileName2);
	
		// TWAIN_WriteNativetoFilename returns 0 on success
		if (returnValue == 0) {

			returnValue = 1;

			if (len == 0) // AMS 7/3/14 #39391 Use ExecuteCommandById if a blob parameter was passed in
			{

				// AMS 7/10/14 #39391 Rewrote this portion of the method to use PA_GetCommandName. This allows users to not have to pass in an extra blob parameter. 
				char cmdName[256] = "";
				char cName[256] = "";

				PA_GetCommandName(525, cmdName);

				int j = 0;

				// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..). 
				// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
				for (int i = 0; i <= sizeof(cmdName); i++)
				{
					if (cmdName[i] != '\0')
					{
						cName[j] = cmdName[i];
						j++;
					}
				}

				cName[(strlen(cName))] = '\0';

				//strcpy(command, "DOCUMENT TO BLOB(\"");
				strncpy(command, cName, sizeof(command));
				strcat(command, "(\"");
				strcat(command, fileName2);
				strcat(command, "\";xTWAINBLOB)");

				// REB 4/20/11 #27322 Conver the C string to a Unistring
				Unistring = CStringToUnistring(&command);
				PA_ExecuteMethod(&Unistring);
				//PA_ExecuteMethod(command, strlen(command));
			}
			else // Leaving this in place just in case a user does not want to use our xTWAINBlob variable
			{

				PA_Unistring _path = CStringToUnistring(fileName);
				PA_Variable varArray[2];

				varArray[0] = PA_CreateVariable(eVK_Unistring);
				PA_SetStringVariable(&varArray[0], &_path);

				varArray[1] = PA_CreateVariable(eVK_Blob);
				varArray[1].fFiller = 0;

				PA_ExecuteCommandByID(525, varArray, 2); 

				char *twainBlob;
				long blobSize;

				blobSize = PA_GetBlobVariable(varArray[1], NULL);
				twainBlob = malloc(blobSize);
				blobSize = PA_GetBlobVariable(varArray[1], twainBlob);

				PA_SetBlobParameter(params, 2, twainBlob, blobSize); 

				free(twainBlob); 
			}
			DeleteFile(fileName);
		}
	}

	free(BLOB); // AMS 7/10/14 #39391

	PA_ReturnLong( params, returnValue );

	TWAIN_FreeNative(DIBHandle);

}


/***************************************************************
	Determine if the frontmost window belongs to our instance
	of 4D.

	REB 4/6/09 #19472  
****************************************************************/
void sys_IsAppFrontmost ( PA_PluginParameters params )
{
	HWND			hwndFront;
	HWND			MDIhWnd, ChildhWnd, NexthWnd, returnValue = 0;
	LONG_PTR			lFound = 0;
	
	// First get the frontmost window.
	hwndFront = GetForegroundWindow();

	MDIhWnd = windowHandles.MDIhWnd; // Assigning to a variable to use later.

	// Now see if the frontmost window is one of ours.

	if(windowHandles.fourDhWnd == hwndFront){
			lFound = 1;
	}else if(MDIhWnd == hwndFront){
			lFound = 1;
	}else{
		// It's not one of the main windows, check all of our child windows

		NexthWnd = GetWindow(MDIhWnd,GW_CHILD);
		do {
			ChildhWnd = NexthWnd;
			if (IsChild(MDIhWnd,ChildhWnd)) {
				if (hwndFront == ChildhWnd){
					lFound = 1;
					break;
				}
				NexthWnd = GetNextWindow(ChildhWnd,GW_HWNDNEXT);
			} else {
				break;
			}
		} while (NexthWnd != NULL);
	};


	PA_ReturnLong( params, lFound );
	
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_MessageBox
//
// PURPOSE:		Exposes the MessageBox Win32 API function
//
// DATE:			DJD 2008-09-12
//
void gui_MessageBox( PA_PluginParameters params )
{
	LONG_PTR ownerHandle;
	LONG_PTR messageText_len;
	char messageText[32000];
	LONG_PTR dialogTitle_len;
	char dialogTitle[32000];
	LONG_PTR dialogType;
	LONG_PTR returnValue;

	ownerHandle = PA_GetLongParameter( params, 1 );
	messageText_len = PA_GetTextParameter( params, 2, messageText );
	messageText[messageText_len] = '\0';
	dialogTitle_len = PA_GetTextParameter( params, 3, dialogTitle );
	dialogTitle[dialogTitle_len] = '\0';
	dialogType = PA_GetLongParameter( params, 4 );

	returnValue = MessageBoxEx( (HWND) ownerHandle,	(LPCSTR) messageText, (LPCSTR) dialogTitle,	(UINT) dialogType,	0 );

	PA_ReturnLong( params, returnValue );
}





//----------------------------------------------------------------------
//
// FUNCTION:	gui_SetMDIOpaque
//
// PURPOSE:		Make the main MDI window background opaque.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_SetMDIOpaque (PA_PluginParameters params)
{

	LONG_PTR returnValue;
		
	returnValue = SetLayeredWindowAttributes(windowHandles.fourDhWnd, GetSysColor(COLOR_APPWORKSPACE) , 255, LWA_ALPHA);
	// REB 3/11/10 #23109 Set the window style back to the orignal value.
	if (windowStyle != 0){
		returnValue = SetWindowLongPtr(windowHandles.fourDhWnd,GWL_EXSTYLE,windowStyle);
	};

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_SetMDITransparent
//
// PURPOSE:		Make the main MDI window background transparent.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_SetMDITransparent (PA_PluginParameters params)
{

	LONG_PTR returnValue;
	// REB 3/11/10 #23109 Get the original window style before we mess around with it.
	windowStyle = GetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE);

	returnValue = SetWindowLongPtr(windowHandles.fourDhWnd,GWL_EXSTYLE,GetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE) | WS_EX_LAYERED);
	returnValue = SetLayeredWindowAttributes(windowHandles.fourDhWnd, GetSysColor(COLOR_APPWORKSPACE) , 0, LWA_COLORKEY);

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_HideTaskBar
//
// PURPOSE:		Hide the Windows taskbar.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_HideTaskBar (PA_PluginParameters params)
{
	HWND HWND_tray;
	LONG_PTR returnValue;

	HWND_tray = FindWindow("Shell_TrayWnd", NULL);
	returnValue =  ShowWindow(HWND_tray, SW_HIDE);

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}



//----------------------------------------------------------------------
//
// FUNCTION:	gui_ShowTaskBar
//
// PURPOSE:		Show the Windows taskbar.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_ShowTaskBar (PA_PluginParameters params)
{
	HWND HWND_tray;
	LONG_PTR returnValue;

	HWND_tray = FindWindow("Shell_TrayWnd", NULL);
	returnValue =  ShowWindow(HWND_tray, SW_SHOW);

	// Reverse the return values so that a return value of 0 means there was an error
	// making the taskbar visible and non-zero if there were no problems.
	if (returnValue == 0){
		returnValue = 1; 
	}else{
		returnValue = 0;
	};

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_HideTitleBar
//
// PURPOSE:		Hide the title bar of the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_HideTitleBar (PA_PluginParameters params)
{

	LONG_PTR returnValue;

	SetWindowLong (windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong (windowHandles.fourDhWnd, GWL_STYLE) | WS_POPUP);
	SetWindowLong (windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong (windowHandles.fourDhWnd, GWL_STYLE) &~ WS_CAPTION );
	SetWindowLong (windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong (windowHandles.fourDhWnd, GWL_STYLE) &~ WS_SYSMENU );
   returnValue =  SetWindowPos (windowHandles.fourDhWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED );	

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_ShowTitleBar
//
// PURPOSE:		Show the title bar of the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_ShowTitleBar (PA_PluginParameters params)
{

	LONG_PTR returnValue;

	SetWindowLong (windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong (windowHandles.fourDhWnd, GWL_STYLE) &~ WS_POPUP);
	SetWindowLong (windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong (windowHandles.fourDhWnd, GWL_STYLE) | WS_CAPTION );
	SetWindowLong (windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong (windowHandles.fourDhWnd, GWL_STYLE) | WS_SYSMENU );
    returnValue = SetWindowPos (windowHandles.fourDhWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED );

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MaximizeMDI
//
// PURPOSE:		Maximize the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_MaximizeMDI (PA_PluginParameters params)
{

	LONG_PTR returnValue;
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_SHOWMAXIMIZED;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MinimizeMDI
//
// PURPOSE:		Minimize the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_MinimizeMDI (PA_PluginParameters params)
{

	LONG_PTR returnValue;
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_SHOWMINIMIZED;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_RestoreMDI
//
// PURPOSE:		Restore the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_RestoreMDI (PA_PluginParameters params)
{

	LONG_PTR returnValue;
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_RESTORE;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect (windowHandles.fourDhWnd,NULL,TRUE); 
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong( params, returnValue );
}


//----------------------------------------------------------------------
//
// FUNCTION:	sys_DisableTaskManager
//
// PURPOSE:		Restore the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void sys_DisableTaskManager (PA_PluginParameters params)
{

	LONG_PTR returnValue;
	HKEY hk;
	DWORD val=1;
	
	if(!hookHandles.keyboardLLHook)
		hookHandles.keyboardLLHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)keyboardLLHook, (HINSTANCE)GetModuleHandle(0), 0);
	
	if (RegOpenKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr,&hk)!=ERROR_SUCCESS)
		RegCreateKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk);
	
	returnValue = RegSetValueEx(hk, VAL_DisableTaskMgr, 0, REG_DWORD, (BYTE*)&val, sizeof(val));

	if (returnValue == ERROR_SUCCESS){
		returnValue = 1;
	}else{
		returnValue = 0;
	};

	PA_ReturnLong( params, returnValue );
}



//----------------------------------------------------------------------
//
// FUNCTION:	sys_EnableTaskManager
//
// PURPOSE:		Enable task manager.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void sys_EnableTaskManager (PA_PluginParameters params)
{

	LONG_PTR returnValue;
	HKEY hk;
	
	if(hookHandles.keyboardLLHook)
	{
		UnhookWindowsHookEx(hookHandles.keyboardLLHook);
		hookHandles.keyboardLLHook = NULL;
	}
	
	if (RegOpenKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr,&hk)!=ERROR_SUCCESS)
		RegCreateKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk);
	
	returnValue = RegDeleteValue(hk,VAL_DisableTaskMgr);

	if (returnValue == ERROR_SUCCESS){
		returnValue = 1;
	}else{
		returnValue = 0;
	};

	PA_ReturnLong( params, returnValue );
}


// ------------------------------------------------
// 
//  FUNCTION: sys_SetRegKey( PA_PluginParameters params, LONG_PTR selector )
//
//  PURPOSE:  Set a registry key value.
//        
//	DATE:	  REB 11/17/10 #25402
//
void sys_SetRegKey( PA_PluginParameters params, LONG_PTR selector )
{
	LONG_PTR returnValue, regKey, retErr, dataSize, arraySize, value, expandDataSize, keyState;
	LONG_PTR i, len;
	char regSub[MAXBUF];
	char regName[MAXBUF];
	char *newDataBuffer = NULL, *element = NULL, *pos = NULL;
	HKEY hRootKey;
	HKEY hOpenKey;
	DWORD dwDataType;
	PA_Variable	paReturnArray;

	returnValue = regKey = retErr = arraySize = expandDataSize = 0;
	hRootKey = hOpenKey = 0;
	newDataBuffer = NULL;
	memset(regSub, 0, MAXBUF);
	memset(regName, 0, MAXBUF);

	// Get the function parameters.
	regKey = PA_GetLongParameter( params, 1 );
	PA_GetTextParameter( params, 2, regSub );
	PA_GetTextParameter( params, 3, regName );

	// Convert the 4d registry constant into a Windows registry key.
	hRootKey = getRootKey( regKey );

	// Open the registry key.
	retErr = RegOpenKeyEx(hRootKey, regSub, 0, KEY_ALL_ACCESS, &hOpenKey);
	
	returnValue = -99;

	// If the key does not exist create it now.
	if(retErr == ERROR_FILE_NOT_FOUND){
		returnValue = -98;
		//retErr = RegCreateKeyEx(hRootKey, regSub, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hOpenKey, &keyState);
		retErr = RegCreateKeyEx(hRootKey, regSub, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hOpenKey, &keyState);
	}

	if(retErr == ERROR_SUCCESS){

		returnValue = -97;

		// Get the value type from the registry.
		retErr = RegQueryValueEx(hOpenKey, regName, NULL, &dwDataType, NULL, &dataSize);

		// If the value was not found we'll need to determine the type based on the value passed in.
		if(retErr == ERROR_FILE_NOT_FOUND){

			switch(selector){                      

				case 90:
					dwDataType = REG_SZ;
					retErr = ERROR_SUCCESS;
					break;

				case 91:
					dwDataType = REG_DWORD;
					retErr = ERROR_SUCCESS;
					break;

				case 92:
					dwDataType = REG_MULTI_SZ;
					retErr = ERROR_SUCCESS;
					break;

				case 93:
					dwDataType = REG_BINARY;
					retErr = ERROR_SUCCESS;
					break;
			}
		}

		if(retErr == ERROR_SUCCESS){
		
			switch(dwDataType){
				case REG_BINARY:
					len = PA_GetBlobParameter( params, 4, NULL);
					newDataBuffer = malloc(len);
					len = PA_GetBlobParameter( params, 4, newDataBuffer);

					retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, newDataBuffer, len);

					free(newDataBuffer);

					if(retErr == ERROR_SUCCESS){
						returnValue = 1;
					}else{
						returnValue = retErr * -1;
					}


					break;

			case REG_DWORD:
			case REG_DWORD_BIG_ENDIAN:
				value = PA_GetLongParameter( params, 4);
				retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, &value, sizeof(value));

				if(retErr == ERROR_SUCCESS){
					returnValue = 1;
				}else{
					returnValue = retErr * -1;
				}

				break;
	

			case REG_MULTI_SZ:

				paReturnArray = PA_GetVariableParameter( params, 4 );

				if( paReturnArray.uValue.fArray.fNbElements > 0){
					//Convert the 4D array into a null delimited string to be stored
					for(i=1; i <= paReturnArray.uValue.fArray.fNbElements; i++)
					{
						arraySize += PA_GetTextInArray(paReturnArray, i, NULL) + 1 ;
					}

					newDataBuffer = malloc(arraySize+1);
					memset(newDataBuffer, 0, arraySize+1);
					pos = newDataBuffer;
					for(i=1; i <= paReturnArray.uValue.fArray.fNbElements; i++)
					{
						len = PA_GetTextInArray(paReturnArray, i, NULL);
						element = malloc(len + 1);
						len = PA_GetTextInArray(paReturnArray, i, element);
						element[len] = '\0';
							
						memcpy(pos, element, len+1);
						pos += len + 1;

						free(element);		

					}

					retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, newDataBuffer, arraySize+1);
					free(newDataBuffer);
				}

				if(retErr == ERROR_SUCCESS){
					returnValue = 1;
				}else{
					returnValue = retErr * -1;
				}

				break;

			case REG_EXPAND_SZ:
			case REG_SZ:

				len = PA_GetTextParameter( params, 4, NULL) + 1;
				newDataBuffer = malloc(len * sizeof(char));
				memset(newDataBuffer, 0, (len * sizeof(char)));
				len = PA_GetTextParameter( params, 4, newDataBuffer);
				newDataBuffer[len] = '\0';

				retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, newDataBuffer, len);

				if(retErr == ERROR_SUCCESS){
					returnValue = 1;
				}else{
					returnValue = retErr * -1;
				}

				free(newDataBuffer);

				break;
			} 
		}
	}

	RegCloseKey( hOpenKey );
	PA_ReturnLong( params, returnValue );
}






// ------------------------------------------------
// 
//  FUNCTION: sys_IsAppRunningAsService( PA_PluginParameters params, LONG_PTR selector )
//
//  PURPOSE:  Determine if the application is running as a service.
//        
//	DATE:	  REB 1/12/11 #25587, contributed by Justin Carr
//
void sys_IsAppRunningAsService( PA_PluginParameters params )
{
	short serviceInd = 0;	
	SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY; 
	PSID pServiceSid = NULL; 
	PSID pLocalSystemSid = NULL; 
	BOOL bHasServiceSid; 
	BOOL bHasLocalSystemSid; 

	if ( AllocateAndInitializeSid( &siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &pServiceSid ) ){
		if ( CheckTokenMembership( NULL, pServiceSid, &bHasServiceSid ) ) { 
			if ( bHasServiceSid ) {
				serviceInd = 1; 
			} else if ( AllocateAndInitializeSid( &siaNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pLocalSystemSid ) ) { 
				if ( CheckTokenMembership( NULL, pLocalSystemSid, &bHasLocalSystemSid ) ) { 
					if ( bHasLocalSystemSid ) { 
						serviceInd = 1; 
					} 
				} 
			} 
		} 
	} 

   if ( pLocalSystemSid ) 
     FreeSid( pLocalSystemSid ); 

   if ( pServiceSid ) 
     FreeSid( pServiceSid ); 

   PA_ReturnShort( params, serviceInd ); 

}



// ------------------------------------------------
// 
//  FUNCTION: sys_CompareBLOBs( PA_PluginParameters params )
//
//  PURPOSE:  Compare two BLOBs and return 1 if they are equal and 0 if they are not.
//        
//	DATE:	  // REB 11/9/12 TESTING
//
void sys_CompareBLOBs( PA_PluginParameters params )
{
	LONG_PTR returnValue = 0;
	LONG_PTR len1, len2;
	char *BLOB1  = NULL;
	char *BLOB2  = NULL;

	len1 = PA_GetBlobParameter( params, 1, NULL);
	BLOB1 = malloc(len1);
	len1 = PA_GetBlobParameter( params, 1, BLOB1);

	len2 = PA_GetBlobParameter( params, 2, NULL);
	BLOB2 = malloc(len2);
	len2 = PA_GetBlobParameter( params, 2, BLOB2);
	
	if(len1 == len2){
		returnValue = memcmp(BLOB1, BLOB2, len1);
	}else{
		returnValue = -1;
	}

	free(BLOB1);
	free(BLOB2);

   PA_ReturnLong( params, returnValue ); 

}


//----------------------------------------------------------------------
//
// FUNCTION:	keyboardLLHook
//
// PURPOSE:		Hook to handle low level keyboard events.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
LRESULT CALLBACK keyboardLLHook(INT_PTR code, WPARAM wParam, LPARAM lParam)
{

	KBDLLHOOKSTRUCT *pkh = (KBDLLHOOKSTRUCT *) lParam;
	BOOL bCtrlKeyDown = FALSE;
	BOOL bAltKeyDown = FALSE;
	BOOL bShiftKeyDown = FALSE;	
	
	if (code==HC_ACTION) {
		bCtrlKeyDown = GetAsyncKeyState(VK_CONTROL)>>((sizeof(SHORT) * 8) - 1);
		bShiftKeyDown = GetAsyncKeyState(VK_SHIFT)>>((sizeof(SHORT) * 8) - 1);		
		bAltKeyDown = pkh->flags & LLKHF_ALTDOWN;
		
		if ((pkh->vkCode==VK_ESCAPE && bCtrlKeyDown) ||					// Ctrl+Esc
			(pkh->vkCode==VK_TAB && bAltKeyDown) ||						// Alt+Tab
			(pkh->vkCode==VK_ESCAPE && bAltKeyDown) ||					// Alt+Esc
			(pkh->vkCode==VK_ESCAPE && bCtrlKeyDown && bShiftKeyDown)|| // Ctrl+Shift+Esc			
			(pkh->vkCode==VK_F4 && bAltKeyDown)||						// Alt+F4			
			(pkh->vkCode==VK_LWIN || pkh->vkCode==VK_RWIN))				// Start Menu
		{ 
			return 1;
		}
	}
	return CallNextHookEx( hookHandles.keyboardLLHook, code, wParam, lParam );
}


//----------------------------------------------------------------------
//
// FUNCTION:	sys_GetFileVersionInfo
//
// PURPOSE:		Return file version information 
//
// AMS 2/14/10 #36899
//
void sys_GetFileVersionInfo( PA_PluginParameters params )
{
	char *verData = NULL;
	char *file = NULL;
	DWORD verHandle = NULL;
	DWORD verSize = NULL;	

	LONG_PTR ret=0;
	LONG_PTR major = 0;
	LONG_PTR minor = 0;
	LONG_PTR rev  = 0;
	LONG_PTR build = 0;

	UINT size = 0;
	LPBYTE *lpBuffer = NULL;

	file = getTextParameter( params, 1 );

	verSize = GetFileVersionInfoSize( file, &verHandle );

	if( 0 != verSize )
	{
		verData = malloc(verSize);
		if( GetFileVersionInfo( file, verHandle, verSize, verData) )
		{
			ret = 1;
			if( VerQueryValue(verData, "\\", (VOID FAR* FAR*)&lpBuffer, &size) )
			{
				if(size)
				{
					VS_FIXEDFILEINFO *verInfo = (VS_FIXEDFILEINFO *)lpBuffer;
					if(verInfo->dwSignature == 0xfeef04bd)
					{
						major = HIWORD(verInfo->dwFileVersionMS);
					    minor = LOWORD(verInfo->dwFileVersionMS);
						build = HIWORD(verInfo->dwFileVersionLS);
						rev   = LOWORD(verInfo->dwFileVersionLS);
					}

				}

			}

		}
	
		else
		{
			ret = GetLastError();
		}

		free( verData );	
	
	}

	free( file ); 

	PA_SetLongParameter( params, 2, (LONG)major );
	PA_SetLongParameter( params, 3, (LONG)minor );
	PA_SetLongParameter( params, 4, (LONG)build );
	PA_SetLongParameter( params, 5, (LONG)rev );

	PA_ReturnLong( params, (LONG)ret);

}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_GetOSVersionEX
//
// PURPOSE:		Get version of operating system. This uses the Version Helpers API that Windows wants to use in replacement of GetVersionInfo
//
//  BOOL bInternalCall, PA_PluginParameters params
//
//  AMS2 12/5/10 #37816

LONG_PTR sys_GetOSVersionEX(BOOL bInternalCall, PA_PluginParameters params)
{
	LONG_PTR			returnValue = 0;

	// AMS2 9/26/14 #37816 Because GetVersionEx is deprecated, new versions of windows need to use version helper API functions to detect the OS version along with defining the new version number.
	// Version numbers for current and new versions of windows are located at http://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx.
	if (IsWindowsXPOrGreater())
	{
		returnValue = OS_XP;  
	}

	if (IsWindowsVistaOrGreater())
	{
		returnValue = OS_VISTA_LONGHORN;
	}

	if (IsWindows7OrGreater())
	{
		returnValue = OS_WIN7;
	}

	if (IsWindows8OrGreater())
	{
		returnValue = OS_WIN8;
	}

	if (IsWindows8Point1OrGreater())
	{
		returnValue = OS_WIN81;
	}

	if (IsWindowsServer())
	{
		returnValue = returnValue + 1; // Server version numbers are the same as the OS version number but have a 1 added to them
	}
	
	if (!bInternalCall) {
		PA_SetLongParameter(params, 1, returnValue);
		PA_ReturnLong(params, returnValue);
	}
	return returnValue;
}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_SendRawPrinterData
//
// PURPOSE:		Sends raw printer data directly to a printer
//
//
// AMS2 12/5/10 #37816
//

void sys_SendRawPrinterData(PA_PluginParameters params)
{
	// 4D Parameters
	LPTSTR szPrinterName;  // Text printer name
	LPBYTE lpData;  // Long printer data
	DWORD dwCount;  // Long printer data length
	LPTSTR szDocName;  // Text document name

	BOOL       bStatus = FALSE;
	HANDLE     hPrinter = NULL;
	DOC_INFO_1 DocInfo;
	DWORD      dwJob = 0L;
	DWORD      dwBytesWritten = 0L;


	PA_GetTextParameter(params, 1, szPrinterName);
	PA_GetLongParameter(params, 2, lpData);
	PA_GetLongParameter(params, 3, dwCount);
	PA_GetTextParameter(params, 4, szDocName);

	// Open a handle to the printer. 
	bStatus = OpenPrinter(szPrinterName, &hPrinter, NULL);
	if (bStatus) {
		// Fill in the structure with info about this "document." 
		DocInfo.pDocName = szDocName;
		DocInfo.pOutputFile = NULL;
		DocInfo.pDatatype = (LPTSTR)("RAW");

		// Inform the spooler the document is beginning. 
		dwJob = StartDocPrinter(hPrinter, 1, (LPBYTE)&DocInfo);
		if (dwJob > 0) {
			// Start a page. 
			bStatus = StartPagePrinter(hPrinter);
			if (bStatus) {
				// Send the data to the printer. 
				bStatus = WritePrinter(hPrinter, lpData, dwCount, &dwBytesWritten);
				EndPagePrinter(hPrinter);
			}
			// Inform the spooler that the document is ending. 
			EndDocPrinter(hPrinter);
		}
		// Close the printer handle. 
		ClosePrinter(hPrinter);
	}
	// Check to see if correct number of bytes were written. 
	if (!bStatus || (dwBytesWritten != dwCount)) {
		bStatus = FALSE;
	}
	else {
		bStatus = TRUE;
	}
	PA_ReturnLong(params, (LONG_PTR)bStatus);
}