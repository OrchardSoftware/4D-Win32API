/* --------------------------------------------------------------------------------
#
#	4DPlugin.c
#	source skeleton generated by 4D Plugin Wizard
#	Project : Win32API
#	author :  dcompton & dschilling
#	6/21/2001
#
# --------------------------------------------------------------------------------*/

//
//	04/16/02 Replaced Plugin API 671 with 672.  Made modifications to
//						672 for compatibility with 4D 6.5
//
//	08/23/02 Replaced Plugin API 672 with 681.  Made modifications for
//						compatibility with 4D 6.5 (Win32API release version 3.5)
//	09/04/02 Corrected version flag in 4DPluginAPI.c.  Added sys_IsAppLoaded for
//						version release 3.5.1
//
//	IMPORTANT: The 4DPluginAPI.c code has been modified to be backwards compatible with pre 6.7
//	IMPORTANT		4D.  Only functions that necaessry for the Win32API plugin have been modified.
//	IMPORTANT		Other functions may require modification if used in Win32API.
//	IMPORTANT		If compatibility with pre-6.7 4D is required, DO NOT replace 4DPluginAPI.c
//	IMPORTANT		without first comparing and copying code modifications from the modified 672.

#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include <string.h>
#include <stdio.h>
#include <commdlg.h>
#include <commctrl.h>
#include <rpc.h>
#include <IphlpApi.h> //req'd for sys_GetRoutes
#include <time.h> // req'd for sys_GetOCTOffset
#include <sys/timeb.h> // req'd for sys_GetOCTOffset
#include <winspool.h>
#include "PrivateTypes.h"
#include "EntryPoints.h"
// WJF 9/14/15 #43727 No longer needed
//#include "EZTWAIN.h" // REB 6/23/09 #14151
//#include "TWAIN.h" // REB 6/23/09 #14151
#include "utilities.h" // REB 3/28/11 #25290
#include "process.h" // REB 2/25/13 #35165

char		g_methodText[255]; // holds method name to execute on tool tip action
char		intrProcStr1[MAX_PATH], intrProcStr2[MAX_PATH];
BOOL		g_bDragFull;
pLL			startOfList = NULL; // unordered linked list for restictWindow
HANDLE		hSubclassMutex;  // MJG 3/26/04
BOOL		g_FolderSelected;  // MJG 6/15/05
char		pathName[512]; // MWD 10/21/05 #9246 holds path to Win32API.4DX
LPCSTR		KEY_DisableTaskMgr = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"; // WJF 6/24/16 Win-21 LPCWSTR -> LPCSTR
LPCSTR		VAL_DisableTaskMgr = "DisableTaskMgr"; // WJF 6/24/16 Win-21 LPCWSTR -> LPCSTR
LONG_PTR	windowStyle = 0; // REB 3/11/10 #23109 To hold the default window style.

struct		HOOKHANDLES
{
	HHOOK		openSaveHookHndl;
	HHOOK		printSettingsHookHndl;
	HHOOK		printHookHndl;
	HHOOK		postProcHookHndl;
	HHOOK		systemMsgHook; // used to hook window for tool tips
	HHOOK		keyboardLLHook; // REB 1/8/10 #22389 Handles low level keyboard events.
} hookHandles;

HANDLE		g_parentHndl;// dialog handle used in Open/Save functions

struct		WINDOWHANDLES
{
	HWND		fourDhWnd; // 4D main window
	HWND		prtSettingshWnd; // handle your print settings dialog
	HWND		prthWnd; // handle to print dialog
	HWND		MDIhWnd;
	HWND		hwndTT; // used for tool tips
	HWND		displayedTTOwnerhwnd; // used for tool tips
	HWND		openSaveTBhwnd; // used in Open/Save dialog
	HWND		MDIs_4DhWnd; // window to get class for all 4D windows (ProToolsSubMDIWndClass)
} windowHandles;

struct		PROCESSHANDLES
{
	WNDPROC		wpFourDOrigProc; // used for tray icon subclass
	WNDPROC		wpPrintSettingsDlgOrigProc; // used for subclassing Print Settings Dialog
	WNDPROC		wpPrintDlgOrigProc; // used for subclassing Print Dialog
	WNDPROC		wpProToolsOrigProc; // used for subclassing ALL 4D windows
} processHandles;

INT_PTR				FD_Flags; // used for open file dialog
INT_PTR				g_intrProcMsg = PS_IDLE;

struct		PRINTSETTINGS
{
	char		printerSelection[80];
	char		size[80];
	char		source[80];
	LONG_PTR		portraitLandscape;
	char		copies[10];
	BOOL		printPreview;
	BOOL		printToFile;
} printerSettings;

// various flags used to know what feature/functions are living call to call
struct		ACTIVECALLS
{
	BOOL		bPrinterCapture;
	BOOL		bTrayIcons;
	BOOL		b4DMaximize; //01/21/03
} activeCalls;

//added 01/17/03 see 4DPlugin082102.c

// REB 4/7/09 #19472
typedef struct _REG_TZI_FORMAT
{
	LONG Bias;
	LONG StandardBias;
	LONG DaylightBias;
	SYSTEMTIME StandardDate;
	SYSTEMTIME DaylightDate;
} REG_TZI_FORMAT;

extern struct		TOOLBARRESTRICT
{
	LONG			toolBarOnDeck; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG			top; // WJF 6/24/16 Win-21 LONG_PTR -> LONG
	LONG			left; // WJF 6/24/16 Win-21 LONG_PTR -> LONG
	LONG			right; // WJF 6/24/16 Win-21 LONG_PTR -> LONG
	LONG			bottom; // WJF 6/24/16 Win-21 LONG_PTR -> LONG
	LONG			topProcessNbr; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG			leftProcessNbr; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG			rightProcessNbr; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG			bottomProcessNbr; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG			trackingRestriction; // WJF 6/24/16 Win-21 LONG_PTR -> LONG
	LONG_PTR		appBeingMaxed;
	LONG_PTR		appWindowState;
	RECT		origWindowRect;
	LONG		clientOffsetx; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG		clientOffsety;  // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char		minimizedWindows[SMLBUF][SMLBUF]; // REB 8/11/08 #16207
	RECT		previousWindowRect; // REB 3/26/10
} toolBarRestrictions;

// REB 2/26/13 #35165 Structure to communicate with the helper thread
typedef struct	_TWAIN_CAPTURE
{
	long		returnValue; // WJF 9/14/15 #43727 Changed to long from LONG_PTR
	// HANDLE		DIBHandle; // WJF 9/10/15 #43727 No longer needed
	BOOL		done;
	char		*filePath; // WJF 9/10/15 #43727 File path to save the image to
	BOOL		showUI; // WJF 9/10/15 #43727 True to show TWAIN UI, false to hide
	BOOL		get64; // WJF 9/10/15 #43727 True to load 64-bit TWAIN drivers, false to load 32-bit
	BOOL		wiaMode; // WJF 9/21/15 #43940 True to get/acquire WIA
	BOOL		getMultiple; // WJF 9/21/15 #43940 True to acquire multiple images at once
	long		numPictures; // WJF 9/21/15 #43940 Number of pictures returned
} TWAIN_CAPTURE;

// WJF 7/11/16 Win-20 Hold all the command names for logging
const char * const win32Commands[] = {
	"gui_GetWindow",
	"gui_GetWndRect",
	"gui_SetWndRect",
	"gui_ShowWindow",
	"sys_GetUserName",
	"gui_SetWindowTitle",
	"sys_IsMultiByte",
	"gui_DisableCloseBox",
	"gui_SetWindowLong",
	"gui_FlashWindow",
	"gui_WinHelp",
	"sys_GetDefPrinter",
	"sys_SetDefPrinter",
	"sys_EnumPrinters",
	"gui_DelMenuItem",
	"gui_GetOpenFileName",
	"gui_GetSaveFileName",
	"gui_LoadIcon",
	"gui_SetIcon",
	"gui_GetWindowFrom4DWin",
	"sys_GetRegionSettings",
	"sys_GetTimeZone",
	"sys_GetUTCOffset",
	"gui_GetDisplayFontDPI",
	"sys_GetOneRegionSetting",
	"sys_GetPrintJob",
	"sys_GetGUID",
	"sys_GetRoutes",
	"sys_GetNetworkInfo",
	"sys_GetOSVersion",
	"sys_PlayWav",
	"sys_GetWindowMetrics",
	"gui_LoadBackground",
	"sys_SetClientTime",
	"sys_SetClientDate",
	"gui_ToolTipCreate",
	"gui_ToolTipShowOnObject",
	"gui_ToolTipShowOnCoord",
	"gui_ToolTipHide",
	"gui_ToolTipDestroyControl",
	"gui_SetTrayIcon",
	"sys_FileCheck",
	"sys_GetCommandLine",
	"gui_RestrictWindow",
	"gui_GetWindowStyle",
	"gui_GetWindowState",
	"gui_SubClassInit",
	"sys_ShellExecute",
	"sys_IsAppLoaded",
	"gui_SelectColor",
	"gui_RespectToolbar",
	"sys_IsConnectedToInternet",
	"gui_GetSysColor",
	"gui_SetSysColor",
	"sys_GetEnv",
	"sys_SetEnv",
	"sys_GetRegText",
	"sys_GetRegLongint",
	"sys_GetRegArray",
	"sys_GetRegBlob",
	"sys_GetRegType",
	"sys_GetRegEnum",
	"sys_GetDocumentList",
	"sys_SetPluginLanguage",
	"gui_SetWindowStyle",
	"sys_FileExists",
	"sys_DirectoryExists",
	"sys_PrintDirect2Driver",
	"sys_KillProcessByName",
	"sys_KillProcessByID",
	"sys_EnumProcesses",
	"sys_LogonUser",
	"sys_GetTimeZoneList",
	"TWAIN_GetSources",
	"TWAIN_SetSource",
	"TWAIN_AcquireImage",
	"sys_IsAppFrontmost",
	"gui_MessageBox",
	"gui_SetMDIOpaque",
	"gui_SetMDITransparent",
	"gui_HideTaskBar",
	"gui_ShowTaskBar",
	"gui_HideTitleBar",
	"gui_ShowTitleBar",
	"gui_MaximizeMDI",
	"gui_RestoreMDI",
	"gui_MinimizeMDI",
	"sys_DisableTaskManager",
	"sys_EnableTaskManager",
	"sys_SetRegText",
	"sys_SetRegLongint",
	"sys_SetRegArray",
	"sys_SetRegBLOB",
	"sys_IsAppRunningAsService",
	"sys_CompareBLOBs",
	"sys_GetFileVersionInfo",
	"sys_DeleteRegKey",
	"sys_DeleteRegValue",
	"sys_SendRawPrinterData",
	"sys_EncryptAES",
	"sys_DecryptAES",
	"gui_TakeScreenshot",
	"gui_ServerUnloadBackground",
	"sys_SetRegQWORD",
	"gui_FreeHandle",
	"gui_FreeAllHandles",
	"gui_GetWindowEx",
	"gui_GetWindowFrom4DWinEx",
	"gui_SetForegroundWindow",
	"gui_GetWndRectEx",
	"gui_SetWndRectEx",
	"gui_ShowWindowEx",
	"gui_SetWindowTitleEx",
	"gui_DisableCloseBoxEx",
	"gui_SetWindowLongEx",
	"gui_DelMenuItemEx",
	"gui_LoadIconEx",
	"gui_SetIconEx",
	"gui_MessageBoxEx",
	"gui_TakeScreenshotEx",
	"gui_SetForegroundWindowEx",
	"gui_GetWIndowStyleEx",
	"gui_RestrictWindowEx",
	"gui_GetWindowStateEx",
	"gui_SetWindowStyleEx",
	"gui_ToolTipCreateEx",
	"gui_ToolTipShowOnObjectEx",
	"gui_FlashWindowEx",
	"gui_SetFocusEx",
	"sys_EncryptFile",
	"sys_DecryptFile",
	"sys_HashText",
	"sys_GetDiskFreeSpace",
	"sys_ProcessStart",
	"sys_LoggingStart",
	"sys_LoggingStop",
	"sys_IsWow64Process",
	"sys_CryptGenRandom",
	"gui_SetTrayIconEx"
};

// MWD 10/21/05 #9246
// Use the DllMain function to get the path to the calling DLL and store it in a global for further use.
#if WIN32
#ifdef _cplusplus
extern "C" __declspec(dllexport) {
#endif
	BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
	{
		BOOL result = TRUE;
		char fullpath[512] = "";
		GetModuleFileName(hinstDLL, fullpath, sizeof (fullpath)); // Get the path to the 4DX
		strcpy_s((char *)pathName, sizeof(pathName), (char *)fullpath);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		return result;
	}
#ifdef _cplusplus
}
#endif
#endif

// WJF 6/24/16 Win-21 LONG_PTR -> PA_LONG32
void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	HWND				hWnd, NexthWnd;
	PA_Unistring		Unistring;
	char				*pathName, *charPos;
	char				WindowName[255];
	char				szClassName[255];
	char				szCommandID[128];

	// WJF 6/17/16 Win-18
	if ((selector > 0) && (selector < NUM_COMMANDS)) { // WJF 7/11/16 Win-20 200 -> NUM_COMMANDS, <= -> <
		strcpy_s(szCommandID, sizeof(szCommandID), win32Commands[selector-1]); // WJF 7/11/16 Win-20 szCommandConst -> win32Commands[selector-1]  // ZRW 3/23/17 WIN-39 128 -> sizeof(szCommandID)
		
		// WJF 7/11/16 Win-20 Removed
		//_itoa_s(selector, szSelector, 128, 10);
		//strcat_s(szCommandID, 128, szSelector);
		
		strcat_s(szCommandID, sizeof(szCommandID), "\r\n"); // ZRW 4/5/17 WIN-39 128 -> sizeof(szCommandID)
		writeLogFile(szCommandID);
	}

	switch (selector)
	{
		// --- Win32API Commands
	case kInitPlugin:
	case kServerInitPlugin:
		// WJF 6/24/16 Win-21 No longer needed
		//#ifdef _WIN64 // WJF 9/1/15 #43731/#43732 64-bit was returning a value not defined in the API
		//	case k64Init:
		//#endif
		// get MDI & parent window on init 4/15/02
		// REB 2/20/09 #19122 Use new method to get handles.  PA_GetHWND(0) does not work in v11 like it did in previous version.
		// REB 3/24/10 It appears that PA_GetHWND(0) works again, at least in Win7, but I'm leaving this change in place.
		// REB 4/20/11 #27322 Support for the GetMainWindow and GetMDIClientWindow commands is no longer available in the new 4D API. Also PA_GetHWND seems to not work when
		//    there is no focused window in 4D.  Instead I'll use the server workaround.

		// This logic fails if there is a separate application running that returns the same value from GetClassLongPtr as PA_Get4DHInstance returns.
		/*
		h = (HINSTANCE)PA_Get4DHInstance();
		hWnd = NULL;

		w = FindWindow(NULL, NULL);

		do {
		if(!GetParent(w)){
		if(h == (HINSTANCE)GetClassLongPtr(w, GCLP_HMODULE)){
		hWnd = w;
		break;
		}
		}

		w = GetWindow(w, GW_HWNDNEXT);
		} while (w);

		windowHandles.MDIs_4DhWnd = w;

		*/

		// REB 11/2/12 #34333
		Unistring = PA_GetApplicationFullPath();
		pathName = UnistringToCString(&Unistring);
		charPos = strrchr(pathName, '\\');
		*charPos = 0;
		windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);

		free(pathName); // WJF 6/25/15 #42792

		NexthWnd = GetWindow(windowHandles.fourDhWnd, GW_CHILD);
		do {
			if (IsWindow(NexthWnd)){
				GetWindowText(NexthWnd, WindowName, 255);
				GetClassName(NexthWnd, szClassName, 255);

				  // ZRW 4/12/17 WIN-39 Modified to use _strlwr_s instead
				_strlwr_s(szClassName, sizeof(szClassName));
				if (strcmp(szClassName, "mdiclient") == 0){
					//windowHandles.MDIs_4DhWnd =  NexthWnd; // AMS 8/12/14 #39693 This was not the correct handle to use for the MDI Client. It was causing toolbars to work incorrectly.
					windowHandles.MDIhWnd = NexthWnd; // AMS 8/12/14 #39693 This is the correct handle for the MDI Client.
					break;
				}
				NexthWnd = GetNextWindow(NexthWnd, GW_HWNDNEXT);
			}
		} while (IsWindow(NexthWnd));

		//windowHandles.fourDhWnd = GetMainWindow();
		//windowHandles.MDIhWnd = GetMDIClientWindow();
		// REB 8/30/11 #28504 We already have this handle now.
		windowHandles.MDIs_4DhWnd = GetWindow(windowHandles.MDIhWnd, GW_CHILD); //REB 3/26/10 #22878 Get the correct child handle so toolbars work correctly. // AMS 8/12/14 #39693 Uncommented this line. This line is still needed in order for tollbars to work correctly.

		SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &g_bDragFull, 0);
		hSubclassMutex = CreateMutex(NULL, FALSE, "Win32APIMutexToProtect4DProc");  // MJG 3/26/04

		handleArray_init(); // WJF 9/1/15 #43731

		twainSource = NULL; // WJF 9/11/15 #43727

		// openLogFile(); // WJF 6/17/16 Win-18 // WJF 7/8/16 Win-20 This is now controlled programmatically

		break;

	case kDeinitPlugin:
		if (!PA_Is4DServer()) {
			gui_LoadBackground(params, TRUE); // true signifies closing subclassed window
			SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, g_bDragFull, NULL, 0);
			if (hookHandles.systemMsgHook != NULL) {
				UnhookWindowsHookEx(hookHandles.systemMsgHook);
			}
			clear_list(&startOfList);
			restoreOrig4DWindowProcess(); // MJG 3/26/04
		}
		CloseHandle(hSubclassMutex); // MJG 3/26/04
		// REB 1/8/10 #22389
		// REB 12/10/12 #34565
		//sys_EnableTaskManager( params );
		//gui_ShowTaskBar( params );
		//gui_ShowTitleBar( params );
		//gui_SetMDIOpaque( params );

		// closeLogFile(); // WJF 6/17/16 Win-18 // WJF 7/8/16 Win-20 This is now controlled programmatically

		break;

	case 1:
		//Blk4D.fHandle = NULL;  OBSOLETE
		//Call4D (EX_GET_HWND, &Blk4D);
		//hWnd = (HWND)Blk4D.fHandle;
		hWnd = (HWND)PA_GetHWND(NULL); // the current frontmost window // WJF 6/24/16 Win-21 Casting to HWND
		if (!(IsWindow(hWnd))){
			// Always get the frontmost window in this way.
			//Unistring = PA_GetApplicationFullPath();
			//pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
			//charPos = strrchr(pathName,'\\');
			//*charPos = 0;
			//hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
			if (!(IsWindow(windowHandles.MDIs_4DhWnd))){
				Unistring = PA_GetApplicationFullPath();
				pathName = UnistringToCString(&Unistring);
				charPos = strrchr(pathName, '\\');
				*charPos = 0;
				windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);

				free(pathName); // WJF 6/25/15 #42792

				NexthWnd = GetWindow(windowHandles.fourDhWnd, GW_CHILD);
				do {
					if (IsWindow(NexthWnd)){
						GetWindowText(NexthWnd, WindowName, 255);
						GetClassName(NexthWnd, szClassName, 255);
						
						// ZRW 4/12/17 WIN-39 Modified to use _strlwr_s instead
						_strlwr_s(szClassName, sizeof(szClassName));
						if (strcmp(szClassName, "mdiclient") == 0){
							windowHandles.MDIs_4DhWnd = NexthWnd;
							break;
						}
						NexthWnd = GetNextWindow(NexthWnd, GW_HWNDNEXT);
					}
				} while (IsWindow(NexthWnd));
			}
			hWnd = windowHandles.MDIs_4DhWnd;
		}//else{
		//hWnd = PA_GetHWND(NULL); // the current frontmost window
		//}

		// while this is all we need to get frontmost window, we are probably looking for a titled window
		gui_GetWindow(params, hWnd);

		break;

	case 2:
		gui_GetWndRect(params, FALSE);
		break;

	case 3:
		gui_SetWndRect(params, FALSE);
		break;

	case 4:
		gui_ShowWindow(params, FALSE);
		break;

	case 5:
		sys_GetUserName(params);
		break;

	case 6:
		gui_SetWindowTitle(params, FALSE);
		break;

	case 7:
		sys_IsMultiByte(params);
		break;

	case 8:
		gui_DisableCloseBox(params, FALSE);
		break;

	case 9:
		gui_SetWindowLong(params, FALSE);
		break;

	case 10:
		gui_FlashWindow(params, FALSE);
		break;

	case 11:
		gui_WinHelp(params);
		break;

	case 12:
		sys_GetDefPrinter(params);
		break;

	case 13:
		sys_SetDefPrinter(params);
		break;

	case 14:
		sys_EnumPrinters(params);
		break;

	case 15:
		gui_DelMenuItem(params, FALSE);
		break;

	case 16:
		gui_GetOpenFileName(params);
		break;

	case 17:
		gui_GetSaveFileName(params);
		break;

	case 18:
		gui_LoadIcon(params, FALSE);
		break;

	case 19:
		gui_SetIcon(params, FALSE);
		break;

	case 20:
		gui_GetWindowFrom4DWin(params);
		break;

	case 21:
		sys_GetRegionSettings(params, TRUE);
		break;

	case 22:
		sys_GetTimeZone(params);
		break;

	case 23:
		sys_GetUTCOffset(params);
		break;

	case 24:
		gui_GetDisplayFontDPI(params);
		break;

	case 25:
		sys_GetRegionSettings(params, FALSE); // sys_GetOneRegionSetting -- uses same code as GetRegionSettings
		break;

	case 26:
		sys_GetPrintJob(params);
		break;

	case 27:
		sys_GetGUID(params);
		break;

	case 28:
		sys_GetRoutes(params);
		break;

	case 29:
		sys_GetNetworkInfo(params);
		break;

	case 30:
		sys_GetOSVersion(0, params); // first param is 0 if called as plugin call
		break;

	case 31:
		sys_PlayWav(params);
		break;

	case 32:
		sys_GetWindowMetrics(params);
		break;

	case 33:
		gui_LoadBackground(params, FALSE);
		break;

	case 34:
		sys_SetClientTime(params);
		break;

	case 35:
		sys_SetClientDate(params);
		break;

	case 36:
		gui_ToolTipCreate(params, FALSE);
		break;

	case 37:
		gui_ToolTipShowOnObject(params, FALSE);
		break;

	case 38:
		gui_ToolTipShowOnCoord(params);
		break;

	case 39:
		gui_ToolTipHide(params);
		break;

	case 40:
		gui_ToolTipDestroyControl(params);
		break;

	case 41:
		gui_SetTrayIcon(params, FALSE);  // ITH 10/25/19 H-10802 Added 2nd parameter
		break;

	case 42:
		sys_FileCheck(params);
		break;

	case 43:
		sys_GetCommandLine(params);
		break;

	case 44:
		gui_RestrictWindow(params, FALSE);
		break;

	case 45:
		gui_GetWindowStyle(params, FALSE);
		break;

	case 46:
		gui_GetWindowState(params, FALSE);
		break;

	case 47:
		gui_SubClassInit(params);
		break;

	case 48:
		sys_ShellExecute(params);
		break;

	case 49:
		sys_IsAppLoaded(params);
		break;

	case 50:
		gui_SelectColor(params);
		break;

	case 51:
		gui_RespectToolBar(params);
		break;

	case 52:
		sys_IsConnectedToInternet(params);
		break;

	case 53:
		gui_GetSysColor(params);
		break;

	case 54:
		gui_SetSysColor(params);
		break;

	case 55:
		sys_GetEnv(params);
		break;

	case 56:
		sys_SetEnv(params);
		break;

	case 57:
	case 58:
	case 59:
	case 60:
		sys_GetRegKey(params);
		break;

	case 61:
		sys_GetRegType(params);
		break;

	case 62:
		sys_GetRegEnum(params);
		break;

	case 63:
		// SDL 11/16/17 Win-54 This function requires a stack size of about 323kb to run 
		if (PA_CheckFreeStack(0) >= (330*1024)) {  
			sys_GetDocumentList(params);
		}
		else {
			PA_ReturnLong(params, STATUS_STACK_OVERFLOW);
		}
		break;

	case 64:
		sys_SetPluginLanguage(params);
		break;

	case 65:
		gui_SetWindowStyle(params, FALSE);
		break;

	case 66:
		sys_FileExists(params);
		break;

	case 67:
		sys_DirectoryExists(params);
		break;

		// MWD 8/15/06 #10250
		// Enable USB Label Printing
	case 68:
		sys_PrintDirect2Driver(params);
		break;

	case 69:
		sys_KillProcessByName(params);
		break;

	case 70:
		sys_KillProcessByID(params);
		break;

	case 71:
		sys_EnumProcesses(params);
		break;

	case 72:
		sys_LogonUser(params);
		break;

	case 73:
		sys_GetTimeZoneList(params); // REB 4/6/09 #19472
		break;

	case 74:
		TWAIN_GetSources(params); // REB 6/23/09 #14151
		break;

	case 75:
		TWAIN_SetSource(params); // REB 6/23/09 #14151
		break;

	case 76:
		TWAIN_AcquireImage(params); // REB 6/23/09 #14151
		break;

	case 77:
		sys_IsAppFrontmost(params); // REB 8/21/09
		break;

	case 78:
		gui_MessageBox(params, FALSE); // REB 12/3/09
		break;

	case 79:
		gui_SetMDIOpaque(params); // REB 1/8/10 #22389
		break;

	case 80:
		gui_SetMDITransparent(params); // REB 1/8/10 #22389
		break;

	case 81:
		gui_HideTaskBar(params); // REB 1/8/10 #22389
		break;

	case 82:
		gui_ShowTaskBar(params); // REB 1/8/10 #22389
		break;

	case 83:
		gui_HideTitleBar(params); // REB 1/8/10 #22389
		break;

	case 84:
		gui_ShowTitleBar(params); // REB 1/8/10 #22389
		break;

	case 85:
		gui_MaximizeMDI(params); // REB 1/8/10 #22389
		break;

	case 86:
		gui_RestoreMDI(params); // REB 1/8/10 #22389
		break;

	case 87:
		gui_MinimizeMDI(params); // REB 1/8/10 #22389
		break;

	case 88:
		sys_DisableTaskManager(params); // REB 1/8/10 #22389
		break;

	case 89:
		sys_EnableTaskManager(params); // REB 1/8/10 #22389
		break;

	case 90:
	case 91:
	case 92:
	case 93:
		sys_SetRegKey(params, selector); // REB 11/17/10 #25402
		break;

	case 94:
		sys_IsAppRunningAsService(params); // REB 1/12/11 #25587
		break;

	case 95:
		sys_CompareBLOBs(params); // REB 11/9/12 TESTING
		break;

	case 96:
		sys_GetFileVersionInfo(params); // AMS 2/10/14 #36899
		break;

	case 97:
		sys_DeleteRegKey(params); // WJF 4/14/15 #27474
		break;

		/*case 98:
			sys_DeleteRegKey64(params); // WJF 4/14/15 #27474
			break;*/

	case 98:
		sys_DeleteRegValue(params); // WJF 4/14/15 #27474
		break;

	case 99: // WJF 4/20/15 #40598 Redid paramaters
		sys_SendRawPrinterData(params);  // AMS2 12/9/14 #40598
		break;

	case 100:
		textEncryption(params, FALSE); // WJF 5/6/15 #42665 // WJF 10/29/15 Win-4 sys_EncryptAES -> textEncryption
		break;

	case 101:
		textEncryption(params, TRUE); // WJF 5/6/15 #42665 // WJF 10/29/15 Win-4 sys_DecryptAES -> textEncryption
		break;

	case 102:
		gui_TakeScreenshot(params, FALSE); // WJF 7/7/15 #43138
		break;

	case 103:
		gui_LoadBackground(params, TRUE); // WJF 7/24/15 #43311
		break;

	case 104:
		sys_SetRegKey(params, selector); // WJF 8/31/15 #43731
		break;

	case 105:
		handleArray_remove(params); // WJF 9/1/15 #43731
		break;

	case 106:
		handleArray_free(params); // WJF 9/1/15 #43731
		break;

	case 107: // WJF 9/15/15 #43731
		hWnd = (HWND)PA_GetHWND(NULL); // the current frontmost window // WJF 6/24/16 Win-21 Casting to HWND
		if (!(IsWindow(hWnd))){
			if (!(IsWindow(windowHandles.MDIs_4DhWnd))){
				Unistring = PA_GetApplicationFullPath();
				pathName = UnistringToCString(&Unistring);
				charPos = strrchr(pathName, '\\');
				*charPos = 0;
				windowHandles.fourDhWnd = PA_GetMainWindowHWND(); // ITH 7/25/19 WIN-46 FindWindowEx(NULL, NULL, pathName, NULL)->PA_GetMainWindowHWND(). Updated SDK to version 17.0.1

				free(pathName);

				NexthWnd = GetWindow(windowHandles.fourDhWnd, GW_CHILD);
				do {
					if (IsWindow(NexthWnd)){
						GetWindowText(NexthWnd, WindowName, 255);
						GetClassName(NexthWnd, szClassName, 255);
						
						// ZRW 4/12/17 WIN-39 Modified to use _strlwr_s instead
						_strlwr_s(szClassName, sizeof(szClassName));
						if (strcmp(szClassName, "mdiclient") == 0){
							windowHandles.MDIs_4DhWnd = NexthWnd;
							break;
						}
						NexthWnd = GetNextWindow(NexthWnd, GW_HWNDNEXT);
					}
				} while (IsWindow(NexthWnd));
			}
			hWnd = windowHandles.MDIs_4DhWnd;
		}

		gui_GetWindowEx(params, hWnd);
		break;

	case 108:
		gui_GetWindowFrom4DWinEx(params); // WJF 9/15/15 #43731
		break;

	case 109:
		gui_SetForegroundWindow(params, FALSE); // WJF 9/16/15 #43929
		break;

		// WJF 9/16/15 #43731 Ex Function calls
	case 110:
		gui_GetWndRect(params, TRUE);
		break;

	case 111:
		gui_SetWndRect(params, TRUE);
		break;

	case 112:
		gui_ShowWindow(params, TRUE);
		break;

	case 113:
		gui_SetWindowTitle(params, TRUE);
		break;

	case 114:
		gui_DisableCloseBox(params, TRUE);
		break;

	case 115:
		gui_SetWindowLong(params, TRUE);
		break;

	case 116:
		gui_DelMenuItem(params, TRUE);
		break;

	case 117:
		gui_LoadIcon(params, TRUE);
		break;

	case 118:
		gui_SetIcon(params, TRUE);
		break;

	case 119:
		gui_MessageBox(params, TRUE);
		break;

	case 120:
		gui_TakeScreenshot(params, TRUE);
		break;

	case 121:
		gui_SetForegroundWindow(params, TRUE);
		break;

	case 122:
		gui_GetWindowStyle(params, TRUE);
		break;

	case 123:
		gui_RestrictWindow(params, TRUE);
		break;

	case 124:
		gui_GetWindowState(params, TRUE);
		break;

	case 125:
		gui_SetWindowStyle(params, TRUE);
		break;

	case 126:
		gui_ToolTipCreate(params, TRUE);
		break;

	case 127:
		gui_ToolTipShowOnObject(params, TRUE);
		break;

	case 128:
		gui_FlashWindow(params, TRUE);
		break;

		// WJF 9/16/15 #43731 End Ex function calls

	case 129:
		gui_SetFocusEx(params); // WJF 10/19/15 Win-3
		break;

	case 130:
		fileEncryption(params, FALSE); // WJF 10/28/15 Win-4
		break;

	case 131:
		fileEncryption(params, TRUE); // WJF 10/28/15 Win-4
		break;

	case 132:
		sys_HashText(params); // WJF 10/28/15 Win-4
		break;

	case 133:
		sys_GetDiskFreeSpace(params); // WJF 11/2/15 Win-6
		break;

	case 134:
		sys_ProcessStart(params); // WJF 4/20/16 Win-14
		break;

	case 135:
		sys_LoggingStart(params); // WJF 7/8/16 Win-20
		break;

	case 136:
		sys_LoggingStop(params); // WJF 7/8/16 Win-20
		break;

	case 137:
		sys_IsWow64Process(params); // WJF 7/22/16 Win-26
		break;

	case 138:
		sys_CryptGenRandom(params); // WJF 8/30/16 Win-30
		break;
	case 139:
		gui_SetTrayIcon(params, TRUE);  // ITH 10/25/19 H-10802 gui_setTrayIconEx
		break;
	}
}

// ------------------------------- Win32API Commands ------------------------------

// ------------------------------------------------
//
//  FUNCTION: sys_EnumPrinters( PA_PluginParameters params )
//
//  PURPOSE:	Find all printers that a workstation has available
//
//  COMMENTS:	Code modified from a method written by Tomas Restrepo.
//						 http://www.mvps.org/windev/ptk/enumprint.html
//						This module is also called by GetPrintJob.
//						Gets local and remote printers
//						Returns info in a format suitable for using to set default printer
//
//	MODIFICATIONS: 04/20/02 added optional second param from 4D to
//									select what is returned, i.e.,
//									0 = complete string based upon OpenPrinter and GetPrinter functions
//									1 = printer names only (not suitable for using with sys_SetDefPrinter.
//									2 = printer string built from registry entries for NT/2000/XP and
//											from Win.ini file for 95/98/Me
//					08/11/09	Removed logic that checks for versions of Windows before 2000.
//
//	DATE:			dcc 07/03/01
//
void sys_EnumPrinters(PA_PluginParameters params)
{
	PA_Variable				printerArray;
	LONG					returnValue = 0, action = 0, lSize = 0, defPrinterPosition = 0; // WJF 6/29/16 Win-21 LONG_PTR -> LONG
	DWORD					dwSizeNeeded, cByteNeeded, cByteUsed;
	DWORD					dwNumItems, dwTotalNumPrinters;
	DWORD					dwItem;
	LPPRINTER_INFO_1		lpInfo1 = NULL;
	LPPRINTER_INFO_2		lpInfo2 = NULL;
	char					printer_driver_port[255];
	char					printerName[255];
	HANDLE					hPrinter;
	PRINTER_DEFAULTS		ptrDef;
	BOOL					bPrinterSuccess, bNamesOnly = FALSE;

	printerArray = PA_GetVariableParameter(params, 1);
	PA_ResizeArray(&printerArray, 0); //09/21/01

	action = PA_GetLongParameter(params, 2);
	switch (action)
	{
	case EP_NAMES_ONLY:
		bNamesOnly = TRUE;
		break;

	case EP_USE_OPEN:
		break;

	case EP_USE_REGISTRY:
		defPrinterPosition = enumPrintersUsingRegistry(&printerArray);

		PA_SetVariableParameter(params, 1, printerArray, 0);
		PA_ReturnLong(params, defPrinterPosition);
		return;
	}

	// Get buffer size for local printers  PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS
	// Combining the two calls to EnumPrinters into a single call.
	EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 1, NULL, 0, &dwSizeNeeded, &dwNumItems);

	// allocate memory
	lpInfo1 = (LPPRINTER_INFO_1)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeNeeded);
	if (lpInfo1 == NULL)
	{
		returnValue = 0;
		return;
	}

	if (EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 1, (LPBYTE)lpInfo1, dwSizeNeeded, &dwSizeNeeded, &dwNumItems) == 0)	{
		// free memory
		HeapFree(GetProcessHeap(), 0, lpInfo1);
		returnValue = 0;
		PA_ReturnLong(params, returnValue);
		return;
	}

	PA_ResizeArray(&printerArray, dwNumItems);

	//localPrinters = PA_CreateVariable( eVK_ArrayString, 255);
	//PA_ResizeArray (&localPrinters, dwNumItems);
	for (dwItem = 0; dwItem < dwNumItems; dwItem++)
	{
		strcpy_s(printerName, sizeof(printerName), lpInfo1[dwItem].pName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		printerName[strlen(printerName)] = '\0';
		PA_SetTextInArray(printerArray, dwItem + 1, printerName, strlen(printerName));
	}
	// free memory
	HeapFree(GetProcessHeap(), 0, lpInfo1);
	dwTotalNumPrinters = dwNumItems;
	//dwLocalNumItems = dwNumItems;

	/*
	// Get buffer size for remote printers
	EnumPrinters ( PRINTER_ENUM_CONNECTIONS, NULL, 1, NULL, 0, &dwSizeNeeded, &dwNumItems );

	// allocate memory
	lpInfo1 = (LPPRINTER_INFO_1)HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, dwSizeNeeded );
	if ( lpInfo1 == NULL )
	{
	returnValue = 0;
	return;
	}

	if ( EnumPrinters ( PRINTER_ENUM_CONNECTIONS,		// what to enumerate
	NULL,			// printer name (NULL for all)
	1,				// level
	(LPBYTE)lpInfo1,		// buffer
	dwSizeNeeded,		// size of buffer
	&dwSizeNeeded,		// returns size
	&dwNumItems			// return num. items
	) == 0 )	{
	// free memory
	HeapFree ( GetProcessHeap (), 0, lpInfo1 );
	returnValue = 0;
	PA_ReturnLong( params, returnValue );
	return;
	}

	dwRemoteNumItems = dwNumItems;
	if (dwRemoteNumItems) {
	remotePrinters = PA_CreateVariable(eVK_ArrayString, 255);
	PA_ResizeArray (&remotePrinters, dwRemoteNumItems);
	for ( dwItem = 0; dwItem < dwRemoteNumItems; dwItem++ )
	{
	strcpy(printerName, lpInfo1[dwItem].pName);
	printerName[strlen(printerName)] = '\0';
	PA_SetStringInArray (remotePrinters, dwItem + 1, printerName);
	}
	// free memory
	HeapFree ( GetProcessHeap (), 0, lpInfo1 );
	dwTotalNumPrinters += dwRemoteNumItems;
	}
	*/
	//PA_ResizeArray (&printerArray, dwTotalNumPrinters);
	//sprintf(debugStr,"Number of elements: %d",PA_GetArrayNbElements (printerArray));
	//MessageBox(NULL,debugStr,"Debugging",MB_OK);

	// get complete info on each printer

	ptrDef.pDatatype = NULL;
	ptrDef.pDevMode = NULL;
	ptrDef.DesiredAccess = PRINTER_ACCESS_USE;
	/*
	if (dwLocalNumItems ==0) { // 09/19/01
	ptrPA_Var = &remotePrinters;
	bRemoteOnly = TRUE;
	} else {
	ptrPA_Var = &localPrinters;
	bRemoteOnly = FALSE;
	}
	*/
	//loopOffset = 0;

	for (dwItem = 0; dwItem < dwTotalNumPrinters; dwItem++)
	{
		lSize = PA_GetTextInArray(printerArray, dwItem + 1, printerName);
		printerName[lSize] = '\0';
		strcpy_s(printer_driver_port, sizeof(printer_driver_port), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

		bPrinterSuccess = OpenPrinter(printerName, &hPrinter, NULL); //&ptrDef );

		if (bPrinterSuccess){
			if (!bNamesOnly) {
				// Get the buffer size needed
				if (!GetPrinter(hPrinter, 2, NULL, 0, &cByteNeeded))
				{
					if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
						returnValue = 0;
						bPrinterSuccess = ClosePrinter(hPrinter);
						return;
					}
				}

				lpInfo2 = malloc(cByteNeeded); // WJF 7/13/16 Win-21 Removed typecasting per C best practices
				if (!(lpInfo2)) {
					// failure to allocate memory
					returnValue = 0;
					bPrinterSuccess = ClosePrinter(hPrinter);
					return;
				}

				// get the printer info
				if (!GetPrinter(hPrinter, 2, (LPBYTE)lpInfo2, cByteNeeded, &cByteUsed)) // WJF 6/24/16 Win-21 Casting to LPBYTE
				{
					// failure to access the printer
					free(lpInfo2);
					lpInfo2 = NULL;
					returnValue = 0;
					bPrinterSuccess = ClosePrinter(hPrinter);
					return;
				}

				strcpy_s(printer_driver_port, sizeof(printer_driver_port), lpInfo2[0].pPrinterName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
				
				  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
				strcat_s(printer_driver_port, sizeof(printer_driver_port), ",");
				strcat_s(printer_driver_port, sizeof(printer_driver_port), lpInfo2[0].pDriverName);
				strcat_s(printer_driver_port, sizeof(printer_driver_port),  ",");
				strcat_s(printer_driver_port, sizeof(printer_driver_port),  lpInfo2[0].pPortName);
			}
			else {
				strcpy_s(printer_driver_port, sizeof(printer_driver_port), printerName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			}

			bPrinterSuccess = ClosePrinter(hPrinter); // REB 10/29/09 #21643 This was not getting closed.
		}
		else {
			strcpy_s(printer_driver_port, sizeof(printer_driver_port), printerName); // chg made to populate array with name if add'l info can't be retrieved  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			if (!bNamesOnly) {
				strcat_s(printer_driver_port, sizeof(printer_driver_port),  ": Could Not Open");  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
			}
		}

		PA_SetTextInArray(printerArray, dwItem + 1, printer_driver_port, strlen(printer_driver_port));
		/*
		if ((dwRemoteNumItems > 0) && (dwItem == (dwLocalNumItems - 1)) && (!bRemoteOnly)) {
		PA_ClearVariable(&localPrinters);
		ptrPA_Var = &remotePrinters;
		loopOffset = (LONG_PTR)dwLocalNumItems * -1; // offset so new array will start at beginning
		}
		*/
		free(lpInfo2);
		lpInfo2 = NULL;
	} //(i = 0, i < dwTotalNumPrinters, i++)

	//free memory
	HeapFree(GetProcessHeap(), 0, lpInfo2);
	/*
	if (dwTotalNumPrinters > dwLocalNumItems) {
	PA_ClearVariable(ptrPA_Var);
	}
	*/
	returnValue = dwTotalNumPrinters;

	PA_SetVariableParameter(params, 1, printerArray, 0);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetPrintJob( PA_PluginParameters params)
//
//  PURPOSE:	Primarily to get what printer was selected for printing
//
//  COMMENTS:
//	IMPORTANT	NOTE: This an gui_SetTrayIcon use the same subclassed window procedure.
//									You cannot arbitrarily delete the function newProc
//									without breaking tray icons.
//
//	DATE:			dcc 10/23/01
//
//	MODIFICATIONS: Rewritten 10/23/01 to improve reliability.  Previous use
//						of spooler had several inadequacies depending on
//						local, network printers, or print servers.
//						04/15/02 fixed problem when called from dialog box code rather than a form window
//						11/25/02 fixed problem when Print dialog cancelled and then function called a second time (3.5.3)
// WJF 6/30/16 Win-21 Initialized variables
void sys_GetPrintJob(PA_PluginParameters params)
{
	DWORD								ret = 0;
	LONG								returnValue = 0; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HANDLE								prntHndle = 0;
	PA_Variable				        	printer;
	char								printerName[255], executeCommand[255];
	char								*pComma = NULL;
	char								returnString[20];
	DWORD								printerName_len = 255, execCommand_len = 255; // WJF 6/30/16 Win-21 LONG_PTR -> DWORD
	PA_Unistring						Unistring;
	DWORD								bytesRequired = 0;
	LPDEVMODE							pDevMode;

	activeCalls.bPrinterCapture = TRUE;

	hookHandles.printSettingsHookHndl = NULL;
	hookHandles.printHookHndl = NULL;
	processHandles.wpPrintDlgOrigProc = NULL; // 08/08/02
	processHandles.wpPrintSettingsDlgOrigProc = NULL; // 08/08/02

	execCommand_len = (DWORD)PA_GetTextParameter(params, 2, executeCommand); // WJF 6/30/16 Win-19 Cast to DWORD
	executeCommand[execCommand_len] = '\0';
	if (execCommand_len == 0) { // the default is Print Settings
		strcpy_s(executeCommand, sizeof(executeCommand), "Print Settings");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		execCommand_len = (DWORD)strlen(executeCommand); // WJF 6/30/16 Win-19 Cast to DWORD
	}

	//if ((activeCalls.bTrayIcons == FALSE) && (processHandles.wpFourDOrigProc == NULL)) { // same subclassed procedure used for trayIcons
	//	processHandles.wpFourDOrigProc = (WNDPROC) SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) newProc);
	//}

	subclass4DWindowProcess(); // MJG 3/26/04 Replaced code above with function call.

	g_intrProcMsg = PS_SEARCH;

	// REB 4/20/11 #27322 Conver the C string to a Unistring
	Unistring = CStringToUnistring(executeCommand); // WJF 6/21/16 Win-21 Removed unneccessary addressof operator
	PA_ExecuteMethod(&Unistring);

	PA_DisposeUnistring(&Unistring); // WJF 6/25/15 #42792

	//PA_ExecuteMethod(executeCommand, execCommand_len);

	printer = PA_GetVariableParameter(params, 1);

	if (strlen(printerSettings.printerSelection) == 0) {
		PA_ResizeArray(&printer, 10); // WJF 4/7/15 #41184 Changed from 1 -> 10
		ret = GetProfileString("windows", "device", ",,,", printerName, printerName_len);
		pComma = strstr(printerName, ",");
		printerName[pComma - printerName] = '\0';
		strcpy_s(printerSettings.printerSelection, sizeof(printerSettings.printerSelection), printerName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		PA_SetTextInArray(printer, 1, printerSettings.printerSelection,
			strlen(printerSettings.printerSelection));
		returnValue = 1;

		// WJF 8/11/15 #43416 Reverted changes as crashes were occurring for certain users
		/*	// WJF 4/7/15 # 41184 Fill other members with info from the DevMode and PRINTER_INFO_2 structs
		if (OpenPrinter(&printerSettings.printerSelection, &prntHndle, NULL) == TRUE) { // Get the printer handle
		bytesRequired = DocumentProperties(NULL, prntHndle, &printerSettings.printerSelection, NULL, NULL, 0); // Get size required for DevMode struct
		pDevMode = (LPDEVMODE)malloc(bytesRequired);
		DocumentProperties(NULL, prntHndle, &printerSettings.printerSelection, pDevMode, NULL, DM_OUT_BUFFER); // Get DevMode struct
		PA_SetTextInArray(printer, 2, pDevMode->dmFormName, strlen(pDevMode->dmFormName)); // Store paper size (Letter, A4, etc)
		// Store the orientation
		if (pDevMode->dmOrientation = DMORIENT_PORTRAIT){
		PA_SetTextInArray(printer, 5, "Portrait", strlen("Portrait"));
		}
		else {
		PA_SetTextInArray(printer, 5, "Landscape", strlen("Landscape"));
		}

		GetPrinter(prntHndle, 2, 0, 0, &size); // Determine size required for printerInfo
		pPrinterInfo = (PRINTER_INFO_2*)malloc(size);
		GetPrinter(prntHndle, 2, (LPBYTE)pPrinterInfo, size, &size); // Get printerInfo (printerport)
		size = DeviceCapabilities(&printerSettings.printerSelection, pPrinterInfo->pPortName, DC_BINNAMES, bins, NULL); // Get all tray names
		size = DeviceCapabilities(&printerSettings.printerSelection, pPrinterInfo->pPortName, DC_BINS, binNums, NULL); // Get all tray numbers
		for (int i = 0; i<size; i++) {
		if (binNums[i] == pDevMode->dmDefaultSource){
		index = i; // Find the index of the default tray since there is no way to determine selected tray
		i = size + 1;
		}
		}

		PA_SetTextInArray(printer, 3, bins[index],
		strlen(bins[index])); // Set to default bin

		// Cleanup
		free(pDevMode);
		free(pPrinterInfo);
		ClosePrinter(prntHndle);
		}
		else {
		PA_SetTextInArray(printer, 2, emptyString,
		strlen(emptyString));
		PA_SetTextInArray(printer, 3, emptyString,
		strlen(emptyString));
		PA_SetTextInArray(printer, 5, emptyString,
		strlen(emptyString));
		}
		PA_SetTextInArray(printer, 4, "1", strlen("1"));  // Assume 1 copy
		PA_SetTextInArray(printer, 6, emptyString, strlen(emptyString));
		PA_SetTextInArray(printer, 7, emptyString, strlen(emptyString));
		returnValue = 1; */
	}
	else {
		PA_ResizeArray(&printer, 10);

		PA_SetTextInArray(printer, 1, printerSettings.printerSelection,
			strlen(printerSettings.printerSelection));
		// WJF 4/6/15 #40697 If printerSettings.size is empty, we need to find the information another way (Happens when passed "PRINT SETTINGS(2)"
		if (strcmp(printerSettings.size, "") == 0) {
			if (OpenPrinter(printerSettings.printerSelection, &prntHndle, NULL) == TRUE) { // Get the printer handle // WJF 6/21/16 Win-21 Removed unneccessary addressof operator
				bytesRequired = DocumentProperties(NULL, prntHndle, printerSettings.printerSelection, NULL, NULL, 0); // Get size required for DevMode struct // WJF 6/24/16 Win-21 Removed unneccessary addressof operator
				pDevMode = malloc(bytesRequired); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
				DocumentProperties(NULL, prntHndle, printerSettings.printerSelection, pDevMode, NULL, DM_OUT_BUFFER); // Get DevMode struct // WJF 6/24/16 Win-21 Removed unneccessary addressof operator
				PA_SetTextInArray(printer, 2, (char *)pDevMode->dmFormName, strlen((char *)pDevMode->dmFormName)); // Store paper size (Letter, A4, etc) // WJF 6/24/16 Win-21 Casting to char *

				// Cleanup
				free(pDevMode);
				ClosePrinter(prntHndle);
			}
		} // End WJF 4/6/15 #40697 Changes
		else {
			PA_SetTextInArray(printer, 2, printerSettings.size,
				strlen(printerSettings.size));
		}
		PA_SetTextInArray(printer, 3, printerSettings.source,
			strlen(printerSettings.source));

		PA_SetTextInArray(printer, 4, printerSettings.copies,
			strlen(printerSettings.copies));
		if (printerSettings.portraitLandscape == PS_PORTRAIT) {
			strcpy_s(returnString, sizeof(returnString), "Portrait");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}
		else {
			strcpy_s(returnString, sizeof(returnString), "Landscape");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}
		PA_SetTextInArray(printer, 5, returnString,
			strlen(returnString));

		if (printerSettings.printToFile == TRUE) {
			strcpy_s(returnString, sizeof(returnString), "Printed To File");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}
		else {
			strcpy_s(returnString, sizeof(returnString), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}
		PA_SetTextInArray(printer, 6, returnString,
			strlen(returnString));

		if (printerSettings.printPreview == TRUE) {
			strcpy_s(returnString, sizeof(returnString), "Print Preview");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}
		else {
			strcpy_s(returnString, sizeof(returnString), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}
		PA_SetTextInArray(printer, 7, returnString, strlen(returnString));

		returnValue = (LONG)strlen(printerSettings.printerSelection); // WJF 6/30/16 Win-21 Cast to LONG
	}

	// restoreOrig4DWindowProcess(); // 01//21/03  // MJG 3/26/04 The 4D window will remain subclassed until the plug-in is unloaded.
	//if (activeCalls.bTrayIcons == FALSE) { // 11/26/02 moved this below if statement
	//SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) processHandles.wpFourDOrigProc);
	//processHandles.wpFourDOrigProc = NULL;
	//}
	if (hookHandles.printSettingsHookHndl != NULL) {
		UnhookWindowsHookEx(hookHandles.printSettingsHookHndl);
		hookHandles.printSettingsHookHndl = NULL; // 08/08/02
	}
	if (hookHandles.printHookHndl != NULL) {
		UnhookWindowsHookEx(hookHandles.printHookHndl);
		hookHandles.printHookHndl = NULL; // 08/08/02
	}

	windowHandles.prthWnd = 0;
	windowHandles.prtSettingshWnd = NULL;
	processHandles.wpPrintDlgOrigProc = NULL; // 08/08/02
	processHandles.wpPrintSettingsDlgOrigProc = NULL; // 08/08/02
	g_intrProcMsg = PS_IDLE;
	activeCalls.bPrinterCapture = FALSE;

	strcpy_s(printerSettings.printerSelection, sizeof(printerSettings.printerSelection), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	PA_SetVariableParameter(params, 1, printer, 0);
	PA_ReturnLong(params, returnValue);
}

//
//  FUNCTION: sys_GetNetworkInfo( PA_PluginParameters params )
//
//  PURPOSE:	Returns network info
//
//  COMMENTS:	Only availabel in Windows 98 and Win2K and later
//						NOT NT 3.51 or NT 4
//
//	DATE:			dcc 08/09/01
//
//  MODIFICATIONS:  04/10/02 made function call into pointer to
//						avoid problems with Win95/NT that may not have IphlpAPI.dll installed.
//						4D cannot resolve this when a direct reference and dll is missing
//
void	sys_GetNetworkInfo(PA_PluginParameters params)
{
	DWORD					dwFuncReturn;
	LONG					returnValue = 0; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char					infoString[255];
	LONG_PTR				infoString_len = strlen(infoString);
	FIXED_INFO				*fixedInfo;
	IP_ADDR_STRING			*pIPAddr;
	ULONG					ulOutBufLen;
	LPFNDLLFUNC2			lpfnDllFunc2;
	HINSTANCE				hDLL;

	hDLL = LoadLibrary("IphlpAPI.dll");

	if (hDLL != NULL) {
		lpfnDllFunc2 = (LPFNDLLFUNC2)GetProcAddress(hDLL, "GetNetworkParams");

		if (lpfnDllFunc2) {
			infoString_len = PA_GetTextParameter(params, 1, infoString);
			infoString[infoString_len] = '\0';  // Explicitly set the length

			fixedInfo = (FIXED_INFO *)GlobalAlloc(GPTR, sizeof(FIXED_INFO));
			ulOutBufLen = sizeof(FIXED_INFO);

			if (ERROR_BUFFER_OVERFLOW == lpfnDllFunc2(fixedInfo, &ulOutBufLen)) {
				GlobalFree(fixedInfo);
				fixedInfo = GlobalAlloc(GPTR, ulOutBufLen);
			}

			if (dwFuncReturn = lpfnDllFunc2(fixedInfo, &ulOutBufLen)) {
				returnValue = 0;
				PA_ReturnLong(params, returnValue);
				return;
			}
			else {
				returnValue = 1;
				strcpy_s(infoString, sizeof(infoString), fixedInfo->HostName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
				
				// ZRW 4/5/17 WIN-39 strcat -> strcat_s
				strcat_s(infoString, sizeof(infoString),  ",");
				strcat_s(infoString, sizeof(infoString),  fixedInfo->DomainName);
				strcat_s(infoString, sizeof(infoString),  ",");
				switch ((UINT)fixedInfo->NodeType)
				{
				case BROADCAST_NODETYPE:
					strcat_s(infoString, sizeof(infoString), "Broadcast");
					break;
				case PEER_TO_PEER_NODETYPE:
					strcat_s(infoString, sizeof(infoString), "Peer-to-peer");
					break;
				case MIXED_NODETYPE:
					strcat_s(infoString, sizeof(infoString),  "Mixed");
					break;
				case HYBRID_NODETYPE:
					strcat_s(infoString, sizeof(infoString),  "Hybrid");  // SDL 1/2/18 WIN-56 Was Hybid
				}
				strcat_s(infoString, sizeof(infoString),  ",");
				switch (fixedInfo->EnableDns)
				{
				case 0:
					strcat_s(infoString, sizeof(infoString),  "DNS No");
					break;
				default:
					strcat_s(infoString, sizeof(infoString), "DNS Enabled");
				}

				strcat_s(infoString, sizeof(infoString), ",");
				switch (fixedInfo->EnableRouting)
				{
				case 0:
					strcat_s(infoString, sizeof(infoString), "Routing No");
					break;
				default:
					strcat_s(infoString, sizeof(infoString), "Routing Enabled");
				}

				strcat_s(infoString, sizeof(infoString), ",");
				switch (fixedInfo->EnableProxy)
				{
				case 0:
					strcat_s(infoString, sizeof(infoString), "Proxy No");
					break;
				default:
					strcat_s(infoString, sizeof(infoString), "Proxy Enabled");
				}
				if (strlen(fixedInfo->DnsServerList.IpAddress.String) > 0) {
					strcat_s(infoString, sizeof(infoString), ",");
					strcat_s(infoString, sizeof(infoString), fixedInfo->DnsServerList.IpAddress.String);
					pIPAddr = fixedInfo->DnsServerList.Next;
					while (pIPAddr) {
						strcat_s(infoString, sizeof(infoString), ",");
						strcat_s(infoString, sizeof(infoString), pIPAddr->IpAddress.String);
						pIPAddr = pIPAddr->Next;
					}
				}
			} //(dwFuncReturn = lpfnDllFunc2(fixedInfo, &ulOutBufLen))

			GlobalFree(fixedInfo);
			PA_SetTextParameter(params, 1, infoString, strlen(infoString));
		} // (lpfnDllFunc2)
		FreeLibrary(hDLL);
	} //(hDLL != NULL)
	PA_ReturnLong(params, returnValue);
}

//
//  FUNCTION: sys_GetRoutes( PA_PluginParameters params )
//
//  PURPOSE:	Return IP Route Info
//
//  COMMENTS:
//
//	DATE:			dcc 08/08/01
//
//  MODIFICATIONS:  04/10/02 made function call into pointer to
//						avoid problems with Win95/NT that may not have IphlpAPI.dll installed.
//						4D cannot resolve this when a direct reference and dll is missing
//

void	sys_GetRoutes(PA_PluginParameters params)
{
	DWORD					dwFuncReturn;
	LONG					returnValue = 0, i, tableEntries; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	PA_Variable		table;
	char					routeString[255], numToString[25];
	ULONG					buffer_len = 0;
	MIB_IPFORWARDTABLE		rtTable;
	PMIB_IPFORWARDTABLE		pTable = &rtTable;
	BOOL					bOrder = FALSE;
	PULONG				pSize = &buffer_len;
	LPFNDLLFUNC3	lpfnDllFunc3;
	HINSTANCE			hDLL;

	hDLL = LoadLibrary("IphlpAPI.dll");

	if (hDLL != NULL) {
		lpfnDllFunc3 = (LPFNDLLFUNC3)GetProcAddress(hDLL, "GetIpForwardTable");

		if (lpfnDllFunc3) {
			table = PA_GetVariableParameter(params, 1);

			dwFuncReturn = lpfnDllFunc3(pTable, pSize, bOrder);

			// allocate memory
			pTable = malloc(*pSize); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
			if (pTable == NULL)
			{
				returnValue = 0;
				PA_ReturnLong(params, returnValue);
				return;
			}

			dwFuncReturn = lpfnDllFunc3(pTable, pSize, bOrder);
			if (dwFuncReturn != NO_ERROR) {
				// free memory
				free(pTable);
				returnValue = 0;
				PA_ReturnLong(params, returnValue);
				return;
			}

			tableEntries = (LONG_PTR)pTable->dwNumEntries;

			returnValue = tableEntries;
			PA_ResizeArray(&table, tableEntries);

			strcpy_s(routeString, sizeof(routeString), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			for (i = 0; i < tableEntries; i++)
			{
				// ZRW 4/5/17 WIN-39 strcat -> strcat_s
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardDest);
				strcat_s(routeString, sizeof(routeString), ",");
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardMask);
				strcat_s(routeString, sizeof(routeString), ",");
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardNextHop);
				strcat_s(routeString, sizeof(routeString), ",");
				switch ((INT_PTR)pTable->table[i].dwForwardType)
				{
				case 1:
					strcat_s(routeString, sizeof(routeString), "Not specified");
					break;
				case 2:
					strcat_s(routeString, sizeof(routeString), "Logically deleted");
					break;
				case 3:
					strcat_s(routeString, sizeof(routeString), "Local - next hop final");
					break;
				case 4:
					strcat_s(routeString, sizeof(routeString), "Remote");
				}
				strcat_s(routeString, sizeof(routeString), ",");
				_ultoa(pTable->table[i].dwForwardAge, numToString, 10);
				strcat_s(routeString, sizeof(routeString), numToString);

				PA_SetTextInArray(table, i + 1, routeString, strlen(routeString));
				strcpy_s(routeString, sizeof(routeString), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			}

			// free memory
			free(pTable);

			PA_SetVariableParameter(params, 1, table, 0);
		} //(lpfnDllFunc3)
		FreeLibrary(hDLL);
	} //(hDLL != NULL)
	PA_ReturnLong(params, returnValue);
}

//
//  FUNCTION: sys_GetGUID( PA_PluginParameters params )
//
//  PURPOSE:	Gets a UUID in string format
//
//  COMMENTS:	Second string parameter contains text on UUID qualifier.
//						 May be OK, Local Only, Error
//
//	DATE:			dcc 07/30/01
//
void sys_GetGUID(PA_PluginParameters params)
{
	UUID				uGuid;
	RPC_STATUS			rpc_status;
	PUCHAR				cGuid;
	char				guidString[MAXBUF];
	LONG_PTR				guidString_len, guidStatus_len;
	LONG				returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char				guidStatus[MAXBUF];

	guidString_len = PA_GetTextParameter(params, 1, guidString);
	guidString[guidString_len] = '\0';  // Explicitly set the length
	guidStatus_len = PA_GetTextParameter(params, 2, guidStatus);
	guidStatus[guidStatus_len] = '\0';

	returnValue = 1; //unless not OK or local
	rpc_status = UuidCreate(&uGuid);
	switch (rpc_status)
	{
	case RPC_S_OK:
		strcpy_s(guidStatus, sizeof(guidStatus), "OK");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		break;

	case RPC_S_UUID_LOCAL_ONLY:
		strcpy_s(guidStatus, sizeof(guidStatus), "Local Only"); // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		break;

	case RPC_S_UUID_NO_ADDRESS:
		strcpy_s(guidStatus, sizeof(guidStatus), "Cannot get Ethernet hardware address");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		returnValue = 0;
		break;

	default:
		strcpy_s(guidStatus, sizeof(guidStatus), "Unknown status");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		returnValue = 0;
	}

	rpc_status = UuidToString(&uGuid, &cGuid);
	strncpy_s(guidString, sizeof(guidString), (LPSTR)cGuid, MAXBUF); // WJF 6/24/16 Win-21 Casting to LPSTR  // ZRW 4/7/17 WIN-39 strncpy -> strncpy_s
	RpcStringFree(&cGuid);

	guidString_len = strlen(guidString);
	guidStatus_len = strlen(guidStatus);

	PA_SetTextParameter(params, 1, guidString, guidString_len);
	PA_SetTextParameter(params, 2, guidStatus, guidStatus_len);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_GetWindow( PA_PluginParameters params, HWND hWnd )
//
//  PURPOSE:	Obtain Windows window handle for window with specific title
//
//  COMMENTS:	Modified 08/17/01 dcc:  Replaced all except param refs with call
//						to getWindowHandle -- an internal function that returns hndl
//						Allows use for function gui_GetWindowProcess(windowTitle)
//	DATE:
//
//	MODIFICATIONS: Added a check for window title="*".  This retreives
//									frontmost window (active window)

void gui_GetWindow(PA_PluginParameters params, HWND hWnd)
{
	LONG_PTR			windowTitle_len;
	char				*windowTitle;
	long				returnValue = 0;
	LONG_PTR			windowHandle = 0;

	//windowTitle_len = PA_GetTextParameter( params, 1, windowTitle );
	//windowTitle[windowTitle_len] = '\0';  // Explicitly set the length

	windowTitle_len = PA_GetTextParameter(params, 1, NULL) + 1;
	windowTitle = malloc(windowTitle_len * sizeof(char));
	memset(windowTitle, 0, (windowTitle_len * sizeof(char)));
	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';

	if (strcmp(windowTitle, "*") == 0) { // return the frontmost window
		windowHandle = (LONG_PTR)hWnd;
	}
	else {

		_strlwr_s(windowTitle, MAXBUF);  // ZRW 4/12/17 WIN-39 Use the more secure lowercase method here; using MAXBUF since windowTitle is a pointer

		if ((strlen(windowTitle) == 0) && (windowHandles.MDIs_4DhWnd != NULL)) {
			windowHandle = (LONG_PTR)windowHandles.fourDhWnd;
		}
		else if ((strcmp(windowTitle, "mdi") == 0) && (windowHandles.MDIhWnd != NULL)) {  // ZRW 4/12/17 WIN-39 _strlwr(windowTitle) -> windowTitle
			windowHandle = (LONG_PTR)windowHandles.MDIhWnd;
		}
		else {
			windowHandle = (LONG_PTR)getWindowHandle(windowTitle, hWnd);
		}
		if (!returnValue) {
			returnValue = -3;
		}
	}

	if (windowHandle){
		returnValue = (long)windowHandle;
	}

	free(windowTitle);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_GetWndRect( PA_PluginParameters params )
//

void gui_GetWndRect(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;

	// WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG x;
	LONG y;
	LONG w;
	LONG h;
	LONG returnValue;

	LONG_PTR mode;                            // MWD 1/12/07 #12852
	HWND WindowhWnd;
	HMONITOR hMon4D;
	MONITORINFO monitorInfo;
	RECT wRect;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array
	x = PA_GetLongParameter(params, 2);
	y = PA_GetLongParameter(params, 3);
	w = PA_GetLongParameter(params, 4);
	h = PA_GetLongParameter(params, 5);
	mode = PA_GetLongParameter(params, 6);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		// Allowing a return to the original functionality
		// As the new functionality broke at least one developer's code
		if (mode == 1) {
			// Old functionality
			// Get the coordinates relative the actual virtual desktop
			if (GetWindowRect(WindowhWnd, &wRect)) {
				x = wRect.left;
				y = wRect.top;
				w = wRect.right - wRect.left;
				h = wRect.bottom - wRect.top;
				returnValue = 1;
			}
			else {
				returnValue = 0;
			}
		}
		else {
			// New functionality
			// Get the coordinates within the actual monitor that it's in
			hMon4D = MonitorFromWindow(WindowhWnd, MONITOR_DEFAULTTONEAREST);
			monitorInfo.cbSize = sizeof(MONITORINFO);
			if (GetMonitorInfo(hMon4D, &monitorInfo)) {
				if (GetWindowRect(WindowhWnd, &wRect)) {
					x = wRect.left - monitorInfo.rcMonitor.left;
					y = wRect.top - monitorInfo.rcMonitor.top;
					w = wRect.right - wRect.left;
					h = wRect.bottom - wRect.top;
					returnValue = 1;
				}
				else {
					returnValue = 0;
				}
				returnValue = 1;
			}
			else {
				returnValue = (LONG_PTR)GetLastError();
			} // end if
		} // end if
	}
	else {
		returnValue = 0;
	}

	PA_SetLongParameter(params, 2, x);
	PA_SetLongParameter(params, 3, y);
	PA_SetLongParameter(params, 4, w);
	PA_SetLongParameter(params, 5, h);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_SetWndRect( PA_PluginParameters params )
//

void gui_SetWndRect(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;

	// WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG x;
	LONG y;
	LONG w;
	LONG h;
	LONG returnValue, tbHeight, tbWidth, respectTB = 0;

	HWND WindowhWnd, hWndTaskBar;
	RECT taskBarCoords;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array
	x = PA_GetLongParameter(params, 2);
	y = PA_GetLongParameter(params, 3);
	w = PA_GetLongParameter(params, 4);
	h = PA_GetLongParameter(params, 5);
	respectTB = PA_GetLongParameter(params, 6);

	// REB 11/10/11 #28503 Prevent them from making the window so large that it
	// hides the task bar.  I'm hesitant to change this because people may rely on
	// this command to work as is.
	if (respectTB > 0){
		hWndTaskBar = FindWindow("Shell_TrayWnd", NULL); // Get a handle to the taskbar.
		if (GetWindowRect(hWndTaskBar, &taskBarCoords)){
			// We're going to assume that if height < width the taskbar is at the top or bottom.
			tbHeight = (taskBarCoords.bottom - taskBarCoords.top);
			tbWidth = (taskBarCoords.right - taskBarCoords.left);

			// Adjust the specified window size to prevent it from covering the taskbar.
			if ((taskBarCoords.top == 0)&(taskBarCoords.left == 0)){
				if (tbHeight < tbWidth){ // Top
					if (y < taskBarCoords.bottom)
						y = taskBarCoords.bottom;
				}
				else{ // Left
					if (x < taskBarCoords.right)
						x = taskBarCoords.right;
				}
			}
			else if (taskBarCoords.top == 0){ // Right
				if ((x + w) > taskBarCoords.left)
					w = taskBarCoords.left - x;
			}
			else { // Bottom
				if ((y + h) > taskBarCoords.top)
					h = taskBarCoords.top - y;
			}
		}
	}

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		if (SetWindowPos(WindowhWnd, HWND_TOP, x, y, w, h,
			SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOZORDER)) {
			returnValue = 1;
		}
		else {
			returnValue = 0;
		}
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_ShowWindow( PA_PluginParameters params )
//

void gui_ShowWindow(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG showState; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HWND WindowhWnd;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array
	showState = PA_GetLongParameter(params, 2);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		// REB 2/26/09 #16207 Handle this slightly differently if we are using a toolbar.
		if (toolBarRestrictions.toolBarOnDeck == 1){
			switch (showState)
			{
			case SW_MAXIMIZE:
				toolBarRestrictions.appBeingMaxed = APP_MAXIMIZING;
				ShowWindowAsync(WindowhWnd, showState);
				break;
			case SW_RESTORE:
				SendMessage(WindowhWnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
				break;
			case SW_MINIMIZE:
				SendMessage(WindowhWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0L); // REB 3/29/10 #22878
				break;
			default:
				ShowWindowAsync(WindowhWnd, showState);
				break;
			}
		}
		else{
			ShowWindowAsync(WindowhWnd, showState);
		}
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetUserName( PA_PluginParameters params )
//

void sys_GetUserName(PA_PluginParameters params)
{
	DWORD userName_len; // WJF 6/24/16 Win-21 LONG_PTR -> DWORD
	char userName[255];
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG

	userName_len = (DWORD)PA_GetTextParameter(params, 1, userName); // WJF 6/30/16 Win-21 Cast to DWORD
	userName[userName_len] = '\0';  // Explicitly set the length

	userName_len = 255;  // This holds the maximum size of userName variable

	if (GetUserName(userName, &userName_len)) {
		returnValue = 1;
	}
	else {
		strcpy_s(userName, sizeof(userName), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		returnValue = 0;
	}

	// At this point, the user name field is either empty or filled
	// with a valid value.  Return this value to the user in either case.
	userName_len = (DWORD)strlen(userName); // WJF 6/30/16 Win-21 Cast to DWORD
	PA_SetTextParameter(params, 1, userName, userName_len);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_SetWindowTitle( PA_PluginParameters params )
//

void gui_SetWindowTitle(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR windowTitle_len;
	char windowTitle[255];
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HWND WindowhWnd;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal handle array
	windowTitle_len = PA_GetTextParameter(params, 2, windowTitle);
	windowTitle[windowTitle_len] = '\0';  // Explicitly set the length

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		SetWindowText(WindowhWnd, windowTitle);
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_IsMultiByte( PA_PluginParameters params )
//

void sys_IsMultiByte(PA_PluginParameters params)
{
	LONG_PTR byte_len;
	char byte[255];
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG

	byte_len = PA_GetTextParameter(params, 1, byte);

	returnValue = IsDBCSLeadByte(*byte);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_DisableCloseBox( PA_PluginParameters params )
//
//
//	MODIFICATIONS: 09/09/02 Added functionality to restore the close box.
//								 Pass in the window handle as a negative to restore.

void gui_DisableCloseBox(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR			hWndIndex;
	LONG				returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HWND				WindowhWnd;
	HMENU				hSysMenu;
	BOOL				bUndo = FALSE;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 Changed to Index

	if (hWndIndex < 0) {
		bUndo = TRUE;
	}

	if (isEx){ // WJF 9/16/15 #43731 Added Ex version to use internal handle Array
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		hSysMenu = GetSystemMenu(WindowhWnd, 0);
		if (!bUndo) {
			EnableMenuItem(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
		}
		else {
			EnableMenuItem(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
		}
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_SetWindowLong( PA_PluginParameters params )
//
//  PURPOSE:  Multipurpose function to set window styles etc
//

void gui_SetWindowLong(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR s;
	LONG_PTR mode;
	LONG_PTR level;
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HWND WindowhWnd;
	LONG style;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 8/31/15 #43731 Changed to index from handle to make 64-bit safe
	s = PA_GetLongParameter(params, 2);
	mode = PA_GetLongParameter(params, 3);
	level = PA_GetLongParameter(params, 4);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		if (level == 0)
			style = GetWindowLong(WindowhWnd, GWL_STYLE);
		else
			style = GetWindowLong(WindowhWnd, GWL_EXSTYLE);

		if (mode == 1)
			style |= (s);
		else
			style &= ~(s);

		if (level == 0)
			SetWindowLong(WindowhWnd, GWL_STYLE, style);
		else
			SetWindowLong(WindowhWnd, GWL_EXSTYLE, style);

		SetWindowPos(WindowhWnd, HWND_TOP, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_WinHelp( PA_PluginParameters params )
//
void gui_WinHelp(PA_PluginParameters params)
{
	LONG_PTR hWnd;
	LONG_PTR fileName_len;
	char fileName[255];
	UINT helpCommand; // WJF 6/30/16 Win-21 LONG_PTR -> UINT
	ULONG_PTR helpData; // WJF 6/30/16 Win-21 LONG_PTR -> ULONG_PTR
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HWND WindowhWnd;
	BOOL ret; // WJF 6/30/16 Win-21 INT_PTR -> BOOL

	hWnd = PA_GetLongParameter(params, 1);
	fileName_len = PA_GetTextParameter(params, 2, fileName);
	fileName[fileName_len] = '\0';  // Explicitly set the length
	helpCommand = PA_GetLongParameter(params, 3);
	helpData = PA_GetLongParameter(params, 4);

	WindowhWnd = (HWND)hWnd;
	if (IsWindow(WindowhWnd)) {
		ret = WinHelp(WindowhWnd, fileName, helpCommand, helpData);
		returnValue = ret; // WJF 6/30/16 Win-21 Removed casting
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_DelMenuItem( PA_PluginParameters params )
//

void gui_DelMenuItem(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG menuNum; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	UINT menuItem; // WJF 6/30/16 Win-21 LONG_PTR -> UINT
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HWND WindowhWnd;
	HMENU hSubMenu, hMenu;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 Changed to get index of internal handle array
	menuNum = PA_GetLongParameter(params, 2);
	menuItem = PA_GetLongParameter(params, 3);

	returnValue = 0;

	if (isEx){ // WJF 9/16/15 #43731 Added ex version to use internal handle array
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		hMenu = GetMenu(WindowhWnd);
		if (IsMenu(hMenu)) {
			hSubMenu = GetSubMenu(hMenu, menuNum);
			if (IsMenu(hSubMenu)) {
				RemoveMenu(hSubMenu, (menuItem)-1, MF_BYPOSITION);
				DrawMenuBar(WindowhWnd);
				returnValue = 1;
			}
		}
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_GetOpenFileName( PA_PluginParameters params )
//
//  PURPOSE:  display open file common dialog for selecting a file
//
//  COMMENTS: several optins are allowed which hide various
//						buttons or disable entry controls.
//						Uses a hook procedure and a template for folder
//						selection.
//						Does not open file - only retieves name and path
//	DATE:			07/27/01
//
void gui_GetOpenFileName(PA_PluginParameters params)
{
	LONG_PTR			windowTitle_len;
	char				windowTitle[100];
	LONG_PTR			filePattern_len;
	char				filePattern[100];
	LONG_PTR			fileDescription_len;
	char				fileDescription[100];
	LONG_PTR			startFolder_len;
	char				startFolder[255];
	LONG_PTR			fileNameShort_len;
	char				fileNameShort[255];
	char				fileNameSuggested[255];
	LONG_PTR			fileNameSuggested_len;
	LONG_PTR			fileNameFull_len;
	char				fileNameFull[255];
	LONG				returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	OPENFILENAME		ofn;
	char				fileOpenPattern[80]; // WJF 6/24/16 Win-21 unsigned char[] -> char[]
	LONG_PTR			mustExistOption = 0;
	BOOL				bUnhookSuccess;
	HWND				hWnd;
	char				plugInPath[255];
	PA_Unistring		Unistring;
	char				*pathName, *charPos;
	char				cCurrentPath[FILENAME_MAX];
	PA_long32			parentWindowFlag = 0; // WJF 1/6/17 Win-45
	PA_long32			windowReference = 0; // WJF 1/6/17 Win-45
	// DWORD				dwHandleIndex = -1; // WJF 10/26/16 Win-40 // WJF 1/6/17 Win-45 Removed

	_getcwd(cCurrentPath, sizeof(cCurrentPath)); // WJF 2/20/15 #41921 Back up the current working directory
	g_FolderSelected = FALSE;  // MJG 6/15/05
	windowHandles.openSaveTBhwnd = NULL;

	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';  // Explicitly set the length
	filePattern_len = PA_GetTextParameter(params, 2, filePattern);
	filePattern[filePattern_len] = '\0';  // Explicitly set the length
	fileDescription_len = PA_GetTextParameter(params, 3, fileDescription);
	fileDescription[fileDescription_len] = '\0';  // Explicitly set the length
	startFolder_len = PA_GetTextParameter(params, 4, startFolder);
	startFolder[startFolder_len] = '\0';  // Explicitly set the length
	fileNameSuggested_len = PA_GetTextParameter(params, 5, fileNameSuggested);
	fileNameSuggested[fileNameSuggested_len] = '\0';  // Explicitly set the length
	fileNameFull_len = PA_GetTextParameter(params, 6, fileNameFull);
	fileNameFull[fileNameFull_len] = '\0';  // Explicitly set the length

	mustExistOption = PA_GetLongParameter(params, 7);
	FD_Flags = mustExistOption;

	parentWindowFlag = PA_GetLongParameter(params, 8); // WJF 10/26/16 Win-40 // WJF 1/6/17 Win-45 dwHandleIndex -> parentWindowFlag

	windowReference = PA_GetLongParameter(params, 9); // WJF 1/6/17 Win-45

	// WJF 10/26/16 Win-40 Moved below parameter processing
	if (PA_Is4DServer()){
		Unistring = PA_GetApplicationFullPath();
		pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
		charPos = strrchr(pathName, '\\');
		*charPos = 0;
		hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
		free(pathName); // WJF 6/9/15 #42792
	}
	else {

		// WJF 1/6/17 Win-45 Rewrote below as switch and changed fucntionality
		switch (parentWindowFlag)
		{
		case 1: // 4D Window Reference
			hWnd = (HWND)PA_GetHWND((PA_WindowRef)windowReference);
			break;
		case 2: // Win32API Window Handle Index
			hWnd = (HWND)handleArray_retrieve(windowReference);
			break;
		default:
			hWnd = (HWND)NULL;
			break;
		}

		//if (dwHandleIndex >= 0) // WJF 10/26/16 Win-40 Allow the parent window handle to be passed in
		//{
		//	hWnd = handleArray_retrieve(dwHandleIndex);
		//}
		//else {
		//	hWnd = (HWND)PA_GetHWND(NULL); // the current frontmost window // WJF 6/24/16 Win-21 Casting to HWND
		//}
	}
	//hWnd = (HWND)PA_GetHWND(0);

	// The pattern consists of two strings, each terminated with a null character
	sprintf_s(fileOpenPattern, sizeof(fileOpenPattern), "%s%c%s%c", fileDescription, '\0', filePattern, '\0');  // ZRW 4/24/17 WIN-39 sprintf -> sprintf_s

	GetPlugInFullName(plugInPath);

	memset(&ofn, 0, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = GetModuleHandle(plugInPath);
	ofn.lpstrFilter = fileOpenPattern;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = fileNameSuggested;
	ofn.nMaxFile = 255;
	ofn.lpstrFileTitle = fileNameShort;
	ofn.nMaxFileTitle = 255;
	ofn.lpstrInitialDir = startFolder;
	ofn.lpstrTitle = windowTitle;
	ofn.lpTemplateName = MAKEINTRESOURCE(IDD_COMDLG32);
	ofn.lpfnHook = ComDlg32DlgProc;
	ofn.Flags = OFN_EXPLORER;

	// Set the return strings to empty
	strcpy_s(fileNameShort, sizeof(fileNameShort), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	strcpy_s(fileNameFull, sizeof(fileNameFull), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	if ((FD_Flags & FD_HIDE_UP_BUTTON) | (FD_Flags & FD_DISABLE_EDIT_FIELD)
		| (FD_Flags & FD_DISABLE_LOOKIN_FIELD) | (FD_Flags & FD_FILES_ONLY)
		| (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) | (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON)
		| (FD_Flags & FD_SELECT_DIRECTORY)) {
		ofn.Flags = ofn.Flags | OFN_ENABLEHOOK;
	}

	if (FD_Flags & FD_FILE_MUST_EXIST) {
		ofn.Flags = ofn.Flags | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	}

	if (FD_Flags == FD_CREATE_PROMPT) {
		ofn.Flags = ofn.Flags | OFN_CREATEPROMPT;
	}

	if (FD_Flags == FD_SELECT_DIRECTORY) {
		strcpy_s(ofn.lpstrFile, sizeof(ofn.lpstrFile), ""); //with this option, cannot use a suggested filename  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		ofn.Flags = ofn.Flags | OFN_ENABLETEMPLATE;
	}

	if (GetOpenFileName(&ofn)) {
		returnValue = 1;
	}
	else {
		if (g_FolderSelected == TRUE){
			returnValue = 1;
		}
		else{
			ProcessCDError(CommDlgExtendedError(), hWnd);
			returnValue = 0;
		}
	}

	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.openSaveHookHndl); // success is non-zero
	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.postProcHookHndl);

	// At this point, the file name fields are either empty or filled
	// with valid values.  Return these values to the user in either case.
	if (FD_Flags & FD_SELECT_DIRECTORY) {
		strcpy_s(fileNameShort, sizeof(fileNameShort), intrProcStr1);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		strcpy_s(fileNameFull, sizeof(fileNameFull), intrProcStr1);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	}
	else {
		strcpy_s(fileNameFull, sizeof(fileNameFull), fileNameSuggested);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	}

	fileNameShort_len = strlen(fileNameShort);
	fileNameFull_len = strlen(fileNameFull);
	PA_SetTextParameter(params, 5, fileNameShort, fileNameShort_len);
	PA_SetTextParameter(params, 6, fileNameFull, fileNameFull_len);

	_chdir(cCurrentPath); // WJF 2/20/15 #41921 Restoring the current working directory will prevent folders from becoming incorrectly locked

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_GetSaveFileName( PA_PluginParameters params )
//
//  PURPOSE: Save File Common Dialog -- for saving a file
//
//  COMMENTS:  see comments for OpenFileName
//
//	DATE:	07/21/01
//
void gui_GetSaveFileName(PA_PluginParameters params)
{
	LONG_PTR			windowTitle_len;
	char				windowTitle[100];
	LONG_PTR			filePattern_len;
	char				filePattern[100];
	LONG_PTR			fileDescription_len;
	char				fileDescription[100];
	LONG_PTR			startFolder_len;
	char				startFolder[255];
	LONG_PTR			fileNameShort_len;
	char				fileNameShort[255];
	char				fileNameSuggested[255];
	LONG_PTR			fileNameSuggested_len;
	LONG_PTR			fileNameFull_len;
	char				fileNameFull[255];
	LONG				returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	OPENFILENAME		ofn;
	char				fileOpenPattern[80]; // WJF 6/24/16 Win-21 unsigned char[] -> char[]
	LONG_PTR			mustExistOption = 0;
	BOOL				bUnhookSuccess;
	HWND				hWnd;
	char				plugInPath[255];
	PA_Unistring		Unistring;
	char				*pathName, *charPos;
	PA_long32			parentWindowFlag = 0; // WJF 1/6/17 Win-45
	PA_long32			windowReference = 0; // WJF 1/6/17 Win-45
	// DWORD				dwHandleIndex = -1; // WJF 10/26/16 Win-40 // WJF 1/6/17 Win-45 Removed

	g_FolderSelected = FALSE;  // MJG 6/15/05
	windowHandles.openSaveTBhwnd = NULL;

	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';  // Explicitly set the length
	filePattern_len = PA_GetTextParameter(params, 2, filePattern);
	filePattern[filePattern_len] = '\0';  // Explicitly set the length
	fileDescription_len = PA_GetTextParameter(params, 3, fileDescription);
	fileDescription[fileDescription_len] = '\0';  // Explicitly set the length
	startFolder_len = PA_GetTextParameter(params, 4, startFolder);
	startFolder[startFolder_len] = '\0';  // Explicitly set the length
	fileNameSuggested_len = PA_GetTextParameter(params, 5, fileNameSuggested);
	fileNameSuggested[fileNameSuggested_len] = '\0';  // Explicitly set the length
	fileNameFull_len = PA_GetTextParameter(params, 6, fileNameFull);
	fileNameFull[fileNameFull_len] = '\0';  // Explicitly set the length

	mustExistOption = PA_GetLongParameter(params, 7);
	FD_Flags = mustExistOption;

	parentWindowFlag = PA_GetLongParameter(params, 8); // WJF 10/26/16 Win-40 // WJF 1/6/17 Win-45 dwHandleIndex -> parentWindowFlag

	windowReference = PA_GetLongParameter(params, 9); // WJF 1/6/17 Win-45

	// WJF 10/26/16 Win-40 Moved below parameter assignment
	if (PA_Is4DServer()){
		Unistring = PA_GetApplicationFullPath();
		pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
		charPos = strrchr(pathName, '\\');
		*charPos = 0;
		hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
		free(pathName); // WJF 6/25/15 #42792
	}
	else{
		// WJF 1/6/17 Win-45 Rewrote below as switch and changed fucntionality
		switch (parentWindowFlag)
		{
		case 1: // 4D Window Reference
			hWnd = (HWND)PA_GetHWND((PA_WindowRef)windowReference);
			break;
		case 2: // Win32API Window Handle Index
			hWnd = (HWND)handleArray_retrieve(windowReference);
			break;
		default:
			hWnd = (HWND)NULL;
			break;
		}


		//if (dwHandleIndex >= 0) // WJF 10/26/16 Win-40 Allow the parent window handle to be passed in
		//{
		//	hWnd = handleArray_retrieve(dwHandleIndex);
		//}
		//else {
		//	hWnd = (HWND)PA_GetHWND(NULL); // the current frontmost window // WJF 6/24/16 Win-21 Casting to HWND
		//}
	}
	//hWnd = (HWND)	PA_GetHWND(0);

	// The pattern consists of two strings, each terminated with a null character
	sprintf_s(fileOpenPattern, sizeof(fileOpenPattern), "%s%c%s%c", fileDescription, '\0', filePattern, '\0');  // ZRW 4/24/17 WIN-39 sprintf -> sprintf_s

	// Set the return strings to empty
	strcpy_s(fileNameShort, sizeof(fileNameShort), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	strcpy_s(fileNameFull, sizeof(fileNameFull), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	GetPlugInFullName(plugInPath);

	memset(&ofn, 0, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = GetModuleHandle(plugInPath);
	ofn.lpstrFilter = fileOpenPattern;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = fileNameSuggested;
	ofn.nMaxFile = 255;
	ofn.lpstrFileTitle = fileNameShort;
	ofn.nMaxFileTitle = 255;
	ofn.lpstrInitialDir = startFolder;
	ofn.lpstrTitle = windowTitle;
	ofn.lpTemplateName = MAKEINTRESOURCE(IDD_COMDLG32);
	ofn.lpfnHook = ComDlg32DlgProc;
	ofn.Flags = OFN_EXPLORER;

	if ((FD_Flags & FD_HIDE_UP_BUTTON) | (FD_Flags & FD_DISABLE_EDIT_FIELD)
		| (FD_Flags & FD_DISABLE_LOOKIN_FIELD) | (FD_Flags & FD_FILES_ONLY)
		| (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) | (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON)
		| (FD_Flags & FD_SELECT_DIRECTORY)) {
		ofn.Flags = ofn.Flags | OFN_ENABLEHOOK;
	}

	if (FD_Flags & FD_FILE_MUST_EXIST) {
		ofn.Flags = ofn.Flags | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	}

	if (FD_Flags == FD_OVERWRITE_PROMPT) {
		ofn.Flags = ofn.Flags | OFN_OVERWRITEPROMPT;
	}

	if (FD_Flags == FD_SELECT_DIRECTORY) {
		strcpy_s(ofn.lpstrFile, ofn.nMaxFile, ""); //with this option, cannot use a suggested filename  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		ofn.Flags = ofn.Flags | OFN_ENABLETEMPLATE;
	}

	if (GetSaveFileName(&ofn)) {
		returnValue = 1;
	}
	else {
		if (g_FolderSelected == TRUE){
			returnValue = 1;
		}
		else{
			ProcessCDError(CommDlgExtendedError(), hWnd); // primarily for debugging
			returnValue = 0;
		}
	}

	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.openSaveHookHndl); // success is non-zero
	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.postProcHookHndl);

	// At this point, the file name fields are either empty or filled
	// with valid values.  Return these values to the user in either case.
	if (FD_Flags & FD_SELECT_DIRECTORY) {
		strcpy_s(fileNameShort, sizeof(fileNameShort), intrProcStr1);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		strcpy_s(fileNameFull, sizeof(fileNameFull), intrProcStr1);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	}
	else {
		strcpy_s(fileNameFull, sizeof(fileNameFull), fileNameSuggested);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	}

	fileNameShort_len = strlen(fileNameShort);
	fileNameFull_len = strlen(fileNameFull);
	PA_SetTextParameter(params, 5, fileNameShort, fileNameShort_len);
	PA_SetTextParameter(params, 6, fileNameFull, fileNameFull_len);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_LoadIcon( PA_PluginParameters params )
//

void gui_LoadIcon(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR iconName_len;
	char iconName[255];  //complete path of icon file
	LONG_PTR hIcon;
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HICON tmpIcon;
	DWORD iconIndex = 0;

	iconName_len = PA_GetTextParameter(params, 1, iconName);
	iconName[iconName_len] = '\0';  // Explicitly set the length

	hIcon = PA_GetLongParameter(params, 2);

	// Load the icon
	hIcon = 0;
	tmpIcon = (HICON)LoadImage(0, iconName, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);

	if (tmpIcon != 0) {
		hIcon = (LONG_PTR)tmpIcon;
		returnValue = 1;
	}
	else {
		hIcon = -1; // WJF 7/6/16 Win-9
		returnValue = 0;
	}

	if ((isEx) && (returnValue))  { // WJF 9/16/15 #43731 // WJF 7/6/16 Win-9 Check to make sure the icon is valid before storing it in the array
		iconIndex = handleArray_add(hIcon); 
		PA_SetLongParameter(params, 2, iconIndex); 
	}
	else {
		PA_SetLongParameter(params, 2, (LONG)hIcon); // WJF 6/30/16 Win-21 Cast to LONG
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_SetIcon( PA_PluginParameters params )
//

void gui_SetIcon(PA_PluginParameters params, BOOL isEx)
{
	LONG hWndIndex; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG hIconIndex; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG_PTR hIcon;
	HWND WindowhWnd;

	// WJF 9/1/15 #43731 We are now getting indexes to an internal array
	hWndIndex = PA_GetLongParameter(params, 1);
	hIconIndex = PA_GetLongParameter(params, 2);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve(hWndIndex);
		hIcon = (LONG_PTR)handleArray_retrieve(hIconIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
		hIcon = hIconIndex;
	}

	if ((IsWindow(WindowhWnd)) && (hIcon != 0)) {
		// Tell the window to use this icon
		SendMessage(WindowhWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)(HICON)hIcon);
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_GetWindowFrom4DWin( PA_PluginParameters params )
//

void gui_GetWindowFrom4DWin(PA_PluginParameters params)
{
	LONG_PTR h4DWnd = 0;
	LONG_PTR windowHandle = 0;
	LONG_PTR serverValue = 0;
	long returnValue = 0;

	h4DWnd = PA_GetLongParameter(params, 1);
	serverValue = PA_GetLongParameter(params, 2);

	if (serverValue == 1) // AMS 5/20/14 #39556 PA_GetHWND(h4DWnd) does not work on 4D Server // AMS 6/8/14 #39789
	{
		windowHandle = PA_GetHWND(PA_GetWindowFocused());
	}
	else
	{
		windowHandle = PA_GetHWND((PA_WindowRef)h4DWnd); // WJF 6/21/16 Win-21 Casting to PA_WindowRef
	}

	returnValue = (long)windowHandle;

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetRegionSettings( PA_PluginParameters params, BOOL arraySupplied )
//
//  PURPOSE:	Gets region-specifiuc settings such as decimal char, currency symbol etc
//
//  COMMENTS: Method gets all or one depending on 2nd parameter passed from
//						entry point.

//	DATE:			dcc 07/10/01
//
void sys_GetRegionSettings(PA_PluginParameters params, BOOL arraySupplied)
{
	PA_Variable	values, valueDescr;
	char		textParam[80];
	LONG_PTR		textParam_len;
	LCTYPE	infoType[NBR_ELEMENTS];
	char*		description[] = {
		"Short Date", "Long Date", "Date Separator", "Time Format",
		"Time Separator", "AM Symbol", "PM Symbol", "Measurement System",
		"Decimal Symbol", "Leading Zeros", "Digits after Decimal",
		"Number Grouping Symbol", "Negative Symbol", "Currency Symbol",
		"Currency Decimal Symbol", "Currency Digits after Decimal",
		"Currency Grouping Symbol", "List Separator"
	};
	LONG		returnValue, i, loopStop, gliReturnValue;  //gli = GetLocaleInfo // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG		requestedSetting; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char		resultString[255];
	char		sz[255];
	INT			bufSize = 255; // WJF 6/30/16 Win-21 INT_PTR -> INT and removed resultSize

	infoType[0] = LOCALE_SSHORTDATE;
	infoType[1] = LOCALE_SLONGDATE;
	infoType[2] = LOCALE_SDATE;
	infoType[3] = LOCALE_STIMEFORMAT;
	infoType[4] = LOCALE_STIME;
	infoType[5] = LOCALE_S1159;
	infoType[6] = LOCALE_S2359;
	infoType[7] = LOCALE_IMEASURE;
	infoType[8] = LOCALE_SDECIMAL;
	infoType[9] = LOCALE_ILZERO;
	infoType[10] = LOCALE_IDIGITS;
	infoType[11] = LOCALE_STHOUSAND;
	infoType[12] = LOCALE_SNEGATIVESIGN;
	infoType[13] = LOCALE_SCURRENCY;
	infoType[14] = LOCALE_SMONDECIMALSEP;
	infoType[15] = LOCALE_ICURRDIGITS;
	infoType[16] = LOCALE_SMONTHOUSANDSEP;
	infoType[17] = LOCALE_SLIST;

	returnValue = 0;
	if (arraySupplied) {
		values = PA_GetVariableParameter(params, 1);
		PA_ResizeArray(&values, NBR_ELEMENTS);

		valueDescr = PA_GetVariableParameter(params, 2);
		PA_ResizeArray(&valueDescr, NBR_ELEMENTS);

		loopStop = PA_GetArrayNbElements(values);
		requestedSetting = 0; // start at zero in loop below to get all into the array
	}
	else {
		values = PA_CreateVariable(eVK_ArrayUnicode);
		valueDescr = PA_CreateVariable(eVK_ArrayUnicode);

		textParam_len = PA_GetTextParameter(params, 1, textParam);
		loopStop = PA_GetLongParameter(params, 2);
		requestedSetting = loopStop - 1;
	}

	for (i = requestedSetting; i < loopStop; i++)
	{
		strcpy_s(sz, sizeof(sz), resultString);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		// resultSize = strlen(sz); // WJF 6/30/16 Win-21 This wasn't used anywhere
		gliReturnValue = GetLocaleInfo(LOCALE_USER_DEFAULT, infoType[i], sz, bufSize);
		if (gliReturnValue = 0) {
			strcpy_s(sz, sizeof(sz), "n/a"); // some keyNames may be there & some may not  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		}

		if (infoType[i] == LOCALE_IMEASURE) {
			if (sz[0] == '0') {
				strcpy_s(sz, sizeof(sz), "Metric");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			}
			else {
				strcpy_s(sz, sizeof(sz), "U.S.");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			} //(sz[0] == '0')
		} //(infoType[i] == LOCALE_IMEASURE)

		if (arraySupplied) {
#pragma warning(push, 0) // WJF 6/24/16 Win-21
			PA_SetTextInArray(values, i + 1, sz, strlen(sz));
			PA_SetTextInArray(valueDescr, i + 1, description[i], strlen(description[i]));
#pragma warning(pop) // WJF 6/24/16 Win-21
			returnValue = i + 1;
		}
		else {
			PA_SetTextParameter(params, 1, sz, strlen(sz));
			PA_ReturnLong(params, (LONG)strlen(sz));  // return value string length // WJF 6/30/16 Win-21 Cast to LONG
			return;
		} //(arraySupplied)
	} //(i = requestedSetting; i < loopStop; i++)

	PA_SetVariableParameter(params, 1, values, 0);
	PA_SetVariableParameter(params, 2, valueDescr, 0);
	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetTimeZone( PA_PluginParameters params )
//
//  PURPOSE:	Gets time zone setting of cmptr
//
//  COMMENTS: Requires two text strings and a LONG_PTR
//						Returns name of standard time, name of daylight time, and
//						flag if cmptr set to auto adjust for daylight savings changes.
//
//						IMPORTANT:  It is imperative that different name & size variables be
//												used for query on standard time and daylight time.
//												The problem is in release configuration mode where the size
//												returned from first use does not get reset properly (even
//												when set explicitly).  This is alluded to in help file
//												documentation.
//	DATE:			dcc 07/16/01
//
//  REB 1/21/09 #19035  Updated how we retrieve time zone information.  Original code commented out.
//

void sys_GetTimeZone(PA_PluginParameters params)
{
	LONG_PTR		standardName_len;
	char		*standardName = (char *)malloc(255);  // ZRW 4/24/17 WIN-39 standardName[255] -> standardName = (char *)malloc(255)
	LONG_PTR		daylightName_len;
	char		*daylightName = (char *)malloc(255);  // ZRW 4/24/17 WIN-39 daylightName[255] -> daylightName = (char *)malloc(255)
	BOOL		autoDaylight = 0; // WJF 6/30/16 Win-21 LONG_PTR -> BOOL
	LONG		returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	TIME_ZONE_INFORMATION TimeZoneInformation; // REB 1/21/09 #19035
	size_t      numChars;  // ZRW 4/24/17 WIN-39 Not needed, but required by wcstombs_s

	returnValue = 1;

	GetTimeZoneInformation(&TimeZoneInformation);

	  // ZRW 4/24/17 WIN-39 Use more secure version of method
	//wcstombs(standardName, TimeZoneInformation.StandardName, 255);
	wcstombs_s(&numChars, standardName, 255, TimeZoneInformation.StandardName, 255);  // Using 255 for parameter 3 since that is the size of the memory allocation when we declare the variable

	standardName_len = strlen(standardName);

	// ZRW 4/24/17 WIN-39 Use more secure version of method
	//wcstombs(daylightName, TimeZoneInformation.DaylightName, 255);
	wcstombs_s(&numChars, daylightName, 255, TimeZoneInformation.DaylightName, 255);  // Using 255 for parameter 3 since that is the size of the memory allocation when we declare the variable

	daylightName_len = strlen((char *)daylightName);

	if (TimeZoneInformation.DaylightBias != 0){
		autoDaylight = 1;
	}
	else{
		autoDaylight = 0;
	}

	PA_SetTextParameter(params, 1, (char *)standardName, standardName_len);
	PA_SetTextParameter(params, 2, (char *)daylightName, daylightName_len);
	PA_SetLongParameter(params, 3, autoDaylight);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetUTCOffset ( PA_PluginParameters params )
//
//  REB 1/21/09 #19035 Updated to use GetTimeZoneInformation

void sys_GetUTCOffset(PA_PluginParameters params)
{
	LONG						returnValue = 1; // WJF 6/30/16 Win-21 LONG_PTR -> LONG // WJF 10/8/16 Win-33 0 -> 1
	LONG						bias = 0; // weekNum = 0; // WJF 6/30/16 Win-21 LONG_PTR -> LONG  // ZRW 2/13/17 WIN-39 weekNum initialized but not referenced
	DWORD						dwOperatingMode = 0;

	//struct _timeb tstruct;
	TIME_ZONE_INFORMATION TimeZoneInformation; // REB 1/21/09 #19035
	// SYSTEMTIME SystemTime; // WJF 10/14/16 Win-33 No longer used

	dwOperatingMode = GetTimeZoneInformation(&TimeZoneInformation); // WJF 10/8/16 Win-33 Storing the return value
	// GetLocalTime(&SystemTime); // WJF 10/14/16 Win-33 No longer used

	bias = TimeZoneInformation.Bias;

	// WJF 10/8/16 Win-33
	switch (dwOperatingMode)
	{
		case TIME_ZONE_ID_UNKNOWN:
		case TIME_ZONE_ID_STANDARD:
			bias += TimeZoneInformation.StandardBias;
			break;
		case TIME_ZONE_ID_DAYLIGHT:
			bias += TimeZoneInformation.DaylightBias;
			break;
		case TIME_ZONE_ID_INVALID:
			returnValue = 0;
			break;
	}

	// WJF 10/8/16 Win-33 Removed this mess
	////TimeZoneInformation.DaylightDate.wDayOfWeek // Sun - Sat
	////TimeZoneInformation.DaylightDate.wDay // 1 -5 occurance of above day

	//// Calculate which occurance of the current day we are on.  Basically which week in the month we are on.
	//weekNum = ((SystemTime.wDay - 1) / 7) + 1; // Between 1 and 5

	//if (SystemTime.wMonth == TimeZoneInformation.StandardDate.wMonth){
	//	// We are in the month when we change back to standard
	//	if (SystemTime.wDayOfWeek == TimeZoneInformation.StandardDate.wDayOfWeek){
	//		// We are in the Week that the time changes
	//		if (weekNum == TimeZoneInformation.StandardDate.wDay){
	//			// This is the Day the time changes
	//			if (SystemTime.wHour >= TimeZoneInformation.StandardDate.wHour){
	//				bias += TimeZoneInformation.StandardBias;
	//			}
	//			else{
	//				bias += TimeZoneInformation.DaylightBias;
	//			};
	//		}
	//		else if (weekNum > TimeZoneInformation.StandardDate.wDay){
	//			bias += TimeZoneInformation.StandardBias;
	//		}
	//		else{
	//			bias += TimeZoneInformation.DaylightBias;
	//		};
	//	}
	//	else if (SystemTime.wDayOfWeek > TimeZoneInformation.StandardDate.wDayOfWeek){
	//		if (weekNum > TimeZoneInformation.StandardDate.wDay){
	//			bias += TimeZoneInformation.StandardBias;
	//		}
	//		else{
	//			bias += TimeZoneInformation.DaylightBias;
	//		};
	//	}
	//	else{
	//		bias += TimeZoneInformation.DaylightBias;
	//	};
	//}
	//else if (SystemTime.wMonth == TimeZoneInformation.DaylightDate.wMonth){
	//	// We are in the month when we change back to standard
	//	if (SystemTime.wDayOfWeek == TimeZoneInformation.DaylightDate.wDayOfWeek){
	//		// We are in the Week that the time changes
	//		if (weekNum == TimeZoneInformation.DaylightDate.wDay){
	//			// This is the Day the time changes
	//			if (SystemTime.wHour >= TimeZoneInformation.DaylightDate.wHour){
	//				bias += TimeZoneInformation.DaylightBias;
	//			}
	//			else{
	//				bias += TimeZoneInformation.StandardBias;
	//			};
	//		}
	//		else if (weekNum > TimeZoneInformation.DaylightDate.wDay){
	//			bias += TimeZoneInformation.DaylightBias;
	//		}
	//		else{
	//			bias += TimeZoneInformation.StandardBias;
	//		};
	//	}
	//	else if (SystemTime.wDayOfWeek > TimeZoneInformation.DaylightDate.wDayOfWeek){
	//		if (weekNum > TimeZoneInformation.DaylightDate.wDay){
	//			bias += TimeZoneInformation.DaylightBias;
	//		}
	//		else{
	//			bias += TimeZoneInformation.StandardBias;
	//		};
	//	}
	//	else{
	//		bias += TimeZoneInformation.StandardBias;
	//	};
	//}
	//else if (TimeZoneInformation.StandardDate.wMonth > TimeZoneInformation.DaylightDate.wMonth){
	//	// The period of daylight savings time uccurs within a single year.
	//	if ((SystemTime.wMonth > TimeZoneInformation.DaylightDate.wMonth) && (SystemTime.wMonth < TimeZoneInformation.StandardDate.wMonth)){
	//		bias += TimeZoneInformation.DaylightBias;
	//	}
	//	else{
	//		bias += TimeZoneInformation.StandardBias;
	//	};
	//}
	//else{
	//	// The period of daylight savings time is split between 2 years (say, November to April).
	//	if ((SystemTime.wMonth > TimeZoneInformation.DaylightDate.wMonth) || (SystemTime.wMonth < TimeZoneInformation.StandardDate.wMonth)){
	//		bias += TimeZoneInformation.DaylightBias;
	//	}
	//	else{
	//		bias += TimeZoneInformation.StandardBias;
	//	};
	//};

	PA_SetLongParameter(params, 1, bias);

	// WJF 10/8/16 Win-33 Removed
	//returnValue = PA_GetLongParameter(params, 1);
	////_tzset();
	////_ftime( &tstruct );
	////PA_SetLongParameter( params, 1, tstruct.timezone );
	//if (returnValue == TIME_ZONE_ID_INVALID){
	//	returnValue = 0;
	//}
	//else{
	//	returnValue = 1;
	//};

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: gui_GetDisplayFontDPI( PA_PluginParameters params)
//
//	DATE:			dcc 07/??/01  <-- Was the calendar broken that day?
//
void gui_GetDisplayFontDPI(PA_PluginParameters params)
{
	LONG		dpi = 0; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char		subKey[100];
	LONG		returnValue, errorCode; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HKEY		hKey;
	DWORD		dwWordType = REG_DWORD;
	DWORD		dwWordSize = sizeof(DWORD);
	DWORD		dwDPI;

	returnValue = 0;

	strcpy_s(subKey, sizeof(subKey), "Software\\Microsoft\\Windows NT\\CurrentVersion\\FontDPI");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	hKey = HKEY_LOCAL_MACHINE;
	errorCode = RegOpenKeyEx(hKey, subKey, 0, KEY_READ, &hKey);
	if (errorCode != ERROR_SUCCESS) {
		returnValue = 0;
		PA_ReturnLong(params, returnValue);
		return;
	}
	errorCode = RegQueryValueEx(hKey, "LogPixels", NULL, &dwWordType, (LPBYTE)&dwDPI, &dwWordSize); // WJF 6/24/16 Win-21 Casting to LPBYTE
	if (errorCode != ERROR_SUCCESS) {
		returnValue = 0;
		PA_ReturnLong(params, returnValue);
		return;
	}
	else {
		dpi = dwDPI;
	}
	errorCode = RegCloseKey(hKey);

	PA_SetLongParameter(params, 1, dpi);
	returnValue = dpi;
	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetDefPrinter( PA_PluginParameters params )
//
//  PURPOSE:  Determines which printer is marked as default
//		REB 3/6/09 #17333 Updated to work with Windows Vista and beyond.
//		REB 8/11/09		Removed logic used in versions of Windows older than 2000.
//
void sys_GetDefPrinter(PA_PluginParameters params)
{
	LONG_PTR printerName_len;
	char printerName[255];
	char *pDefaultPrinter;				// REB 3/6/09 #17333
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	DWORD dwBytesNeeded;		// REB 3/6/09 #17333 // WJF 6/24/16 Win-21 ULONG_PTR -> DWORD

	printerName_len = PA_GetTextParameter(params, 1, printerName);
	printerName[printerName_len] = '\0';  // Explicitly set the length

	printerName_len = 255;  // This holds the maximum size of printerName variable
	dwBytesNeeded = MAXBUF;

	pDefaultPrinter = malloc(dwBytesNeeded); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
	memset(pDefaultPrinter, 0, dwBytesNeeded);

	returnValue = GetDefaultPrinter(pDefaultPrinter, &dwBytesNeeded);
	strcpy_s(printerName, sizeof(printerName), pDefaultPrinter);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	free(pDefaultPrinter); // WJF 6/4/15 #42921

	// At this point, the printer name field is either empty or filled
	// with a valid value.  Return this value to the user in either case.
	printerName_len = strlen(printerName);
	PA_SetTextParameter(params, 1, printerName, printerName_len);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_SetDefPrinter( PA_PluginParameters params )
//
//  PURPOSE:  Sets the default printer
//
void sys_SetDefPrinter(PA_PluginParameters params)
{
	LONG_PTR printerName_len;
	char printerName[255];
	char tempName[255];					// REB 3/6/09 #17333 Printer name after spooler info is removed
	char separator[] = ",";				// REB 3/6/09 #17333 Separates printer name from spooler info
	BOOL returnValue = FALSE; // WJF 6/24/16 Win-21 Initialize to FALSE

	printerName_len = PA_GetTextParameter(params, 1, printerName);
	printerName[printerName_len] = '\0';  // Explicitly set the length

	// REB 3/6/09 #17333 Remove spooler info from printer name.
	printerName_len = strcspn(printerName, separator);
	if (printerName_len > 0){
		strncpy_s(tempName, sizeof(tempName), printerName, printerName_len);  // ZRW 4/7/17 WIN-39 strncpy -> strncpy_s
		tempName[printerName_len] = '\0';
		returnValue = SetDefaultPrinter(tempName);
	}

	PA_ReturnLong(params, (LONG_PTR)returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_GetOSVersion(BOOL bInternalCall, PA_PluginParameters params)
//
//  PURPOSE:  Get version of operating system
//
//  COMMENTS: Internally returns LONG_PTR that corresponds to constant defined
//			  for each OS.  params are ignored on internal calls.
//			  External call gets version as constant and string for service pack.
//			  Some info is in win.ini file (Win95/98/Me) and some
//			  in registry.  Need to know where to go hunting
//	DATE:	  dcc 07/10/01
//
//	MODIFICATIONS: 12/1/03 Added check for Windows Server 2003.
//				   7/15/09 Added check for Windows 7
//				   10/31/12 Added support for Windows 8 and Server 2012
//			       AMS2 9/26/14 #37816 Windows 8.1 and Server 2012 R2 and newer versions of Windows should use sys_GetOSVersionEX as GetVersionEX is deprecated
//
//
LONG_PTR sys_GetOSVersion(BOOL bInternalCall, PA_PluginParameters params)
{
	OSVERSIONINFOEX		osvinfo;
	LONG				returnValue = 0; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char				servicePackInfo[255] = "";
	char				filePath[MAX_PATH] = "";
	FILE				*fp = NULL;
	char				utilitiesPath[MAX_PATH] = "";
	char				*pos = NULL;
	char				osVer[16] = "";
	SHELLEXECUTEINFO	utilities;
	BOOL				bSuccess = FALSE;
	DWORD				dwExitCode = 0;
	// WJF 10/12/16 Win-37 -ws -> -os, This was probably missed in review and testing because 
	// it wasn't tagged and we never delete the OS files. I only discovered this bug because I cleared my temp files.
	LPCSTR				lpParameters = "-os"; 

	osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
#pragma warning(push, 0) // WJF 6/24/16 Win-21
	GetVersionEx((LPOSVERSIONINFOA)&osvinfo); // WJF 6/24/16 Win-21 Casting to LPOSVERSIONINFOA
#pragma warning(pop) // WJF 6/24/16 Win-21

	if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_WIN95;
	}
	else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 10) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_WIN98;
	}
	else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 90) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_ME;
	}
	else if ((osvinfo.dwMajorVersion == 3) & (osvinfo.dwMinorVersion == 51) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_NT351;
	}
	else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_NT4;
	}
	else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_W2K;
	}
	else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_XP;
	}
	else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 2) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_WIN03;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)& (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_VISTA_LONGHORN;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)& (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2K8;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) & (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_WIN7;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) & (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2K8R2;
	}
	else
	{
		// WJF 9/22/15 #43601 Moved all version helper API calls to Orchard Utilities
		// AMS2 12/17/14 #37816 Because GetVersionEx is deprecated, new versions of windows need to use version helper API functions to detect the OS version along with defining the new version number.
		// Version numbers for current and new versions of windows are located at http://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx.
		/*if (IsWindows8OrGreater())
		{
		returnValue = OS_WIN8;
		}

		if (IsWindows8Point1OrGreater())
		{
		returnValue = OS_WIN81;
		}*/

		// WJF 9/21/15 #43601 Calling Orchard Utilities because it supports Windows 10 detection
		GetTempPath(MAX_PATH, filePath);

		// WJF 3/29/16 Win-11 Begin Changes
		strcat_s(filePath, sizeof(filePath), "osVersion.txt");  // ZRW 4/5/187 WIN-39 MAX_PATH -> sizeof(filePath)

		strcpy_s(utilitiesPath, MAX_PATH, pathName);

		pos = strrchr(utilitiesPath, '\\');

		pos++; // WJF 1/21/16 WIN-8 Move the pointer over one position so that that following strcpy_s call doesn't overwrite the slash character

		strcpy_s(pos, MAX_PATH, "orchard_utilities.exe");

		utilities.cbSize = sizeof(SHELLEXECUTEINFO);
		utilities.fMask = SEE_MASK_NOCLOSEPROCESS;
		utilities.hInstApp = NULL;
		utilities.hwnd = windowHandles.fourDhWnd;
		utilities.lpFile = utilitiesPath;
		utilities.lpParameters = lpParameters;
		utilities.lpDirectory = NULL;
		utilities.nShow = SW_HIDE;
		utilities.lpVerb = NULL;

		if (ShellExecuteEx(&utilities)) {
			PA_YieldAbsolute();
			PA_YieldAbsolute();
			PA_YieldAbsolute();

			do {
				bSuccess = GetExitCodeProcess(utilities.hProcess, &dwExitCode);
			} while ((dwExitCode == STILL_ACTIVE) && (bSuccess));

			//fp = fopen(filePath, "r");
			fopen_s(&fp, filePath, "r");  // ZRW 4/13/17 WIN-39 Using the more scure method

			if (fp){
				fgets(osVer, 16, fp);

				returnValue = atoi(osVer);

				// WJF 10/12/16 Win-37 Delete the file, also close our lock on it. That was probably causing some weirdness.
				fclose(fp);
				fp = NULL;
				DeleteFile(filePath);
			}


		}
		// WJF 3/29/16 Win-11 End changes

		// WJF 3/29/16 Win-11 Rewrote
		/*
		// WJF 2/16/16 Win-8
		strcpy_s(lockPath, MAX_PATH, filePath);
		strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");
		utilitiesLock();

		strcat_s(filePath, MAX_PATH, "osVersion.txt");

		strcpy_s(utilitiesPath, MAX_PATH, pathName);

		pos = strrchr(utilitiesPath, '\\');

		pos++; // WJF 1/21/16 WIN-8 Move the pointer over one position so that that following strcpy_s call doesn't overwrite the slash character

		strcpy_s(pos, MAX_PATH, "orchard_utilities.exe");

		ShellExecute(windowHandles.fourDhWnd, "", utilitiesPath, "-os", NULL, SW_HIDE);

		if (GetLastError() == ERROR_SUCCESS){
		if (utilitiesYield(lockPath, TRUE, FALSE) == ERROR_SUCCESS) { // WJF 12/17/15 Win-7 Added TRUE, FALSE and return value // WJF 2/16/16 Win-8 filePath -> lockPath
		fp = fopen(filePath, "r");

		if (fp){
		fgets(osVer, 16, fp);

		returnValue = atoi(osVer);
		}
		}
		}
		*/

		// WJF 9/22/15 #43601 Removed
		/*if (IsWindowsServer())
		{
		++returnValue; // Server version numbers are the same as the OS version number but are incremented by one
		}*/
	}

	if (!bInternalCall) {
		PA_SetLongParameter(params, 1, returnValue);
		strcpy_s(servicePackInfo, sizeof(servicePackInfo), osvinfo.szCSDVersion);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
		PA_SetTextParameter(params, 2, servicePackInfo, strlen(servicePackInfo));
		PA_ReturnLong(params, returnValue);
	}
	return returnValue;
}

// *******   end of plugin call modules **********

// supporting modules ---------------------------------------------

// ------------------------------------------------
//
//  FUNCTION:  ComDlg32DlgProc
//
//  PURPOSE:	Callback function for Open/Save FileName Dialog modifications
//
//  COMMENTS:  Some callback features inspired by Shanker Chandrabose's code
//							Kids -- don't try this at home :)
//
//	DATE:  07/21/01
//
// WJF 6/24/16 BOOL -> UINT_PTR
UINT_PTR CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	WORD		wNotifyCode = HIWORD(wParam);
	WORD		wID = LOWORD(wParam);
	TCHAR		szPathName[255];

	switch (uMsg)
	{
	case WM_INITDIALOG:
		EnumChildWindows((HWND)GetParent(hDlg), EnumChildProc, (LPARAM)NULL);
		hookHandles.openSaveHookHndl = SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC)theHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
		hookHandles.postProcHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)postHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
		g_parentHndl = hDlg;
		break;

	case WM_COMMAND:
		if ((wNotifyCode == BN_CLICKED) & (wID == IDC_BUTTON1)) {
			GetDlgItemText(g_parentHndl, IDE_SELECTED, szPathName, MAX_PATH);
			strcpy_s(intrProcStr1, sizeof(intrProcStr1), szPathName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

			// MJG 4/29/05 Invoke cancel button.  Don't forcibly close dialog.
			//SendMessage(g_parentHndl, WM_COMMAND, (WM_USER + 31488), 0L);
			g_FolderSelected = TRUE;
			PostMessage(GetParent(g_parentHndl), WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
		}

		break;

	case WM_NOTIFY:
		TestNotify(hDlg, (LPOFNOTIFY)lParam);

	default:
		return FALSE;
	}
	return TRUE;
}

// ------------------------------------------------
//
//  FUNCTION: postHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Exit dialog using a different control
//
//  COMMENTS: OpenFile dialog has trouble closing without using
//							IDOK, IDCANCEL or IDCLOSE.  IDOK requires
//							a file be selected.  A directory won't do.
//
//	DATE:			dcc 07/30/01
//
// WJF 6/30/16 Win-21 INT_PTR -> INT
LRESULT CALLBACK postHook(INT hCode, WPARAM wParam, LPARAM lParam)
{
	/*
	CWPRETSTRUCT	*cwprs		= (CWPRETSTRUCT*)lParam;

	if (cwprs->message == WM_COMMAND) {
	if (cwprs->wParam == (WM_USER + 31488)) {
	EndDialog(g_parentHndl, TRUE); //end the child dialog
	EndDialog(GetParent(g_parentHndl), TRUE); // now end the main dialog (parent)
	return TRUE;
	}
	}
	*/
	return CallNextHookEx(hookHandles.postProcHookHndl, hCode, wParam, lParam);
}

// ------------------------------------------------
//
//  FUNCTION: theHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Process disable and hide controls
//
//	DATE:			dcc 07/14/01
//
//	MODIFICATIONS:  08/13/02 Corrected problem where FD_HIDE_UP_BUTTON
//					and FD_HIDE_NEWDIRECTORY_BUTTON could not be used
//					together.
//					04/14/04 Improved efficiency when working with
//                  FD_SELECT_DIRECTORY.
//
// WJF 6/30/16 Win-21 INT_PTR -> INT

LRESULT CALLBACK theHook(INT hCode, WPARAM wParam, LPARAM lParam)
{
	TCHAR					szClassName[255];
	TCHAR					szItemName[255];
	TCHAR					szPathName[255];
	LVITEM					item;
	HANDLE					buttonToDisable;
	CWPSTRUCT				*cwps = (CWPSTRUCT*)lParam;
	TBBUTTONINFO			tbInfo;
	BOOL					bChangeHiddenState = TRUE, bSelectedItem = FALSE;
	static INT_PTR			tbOnetime = 0;
	INT_PTR					count;
	INT						i;

	if (windowHandles.openSaveTBhwnd == NULL) {
		tbOnetime = 0;
	}
	GetClassName(cwps->hwnd, szClassName, 255);

	_strlwr_s(szClassName, sizeof(szClassName));  // ZRW 4/12/17 WIN-39 Use the more secure lowercase method here

	if (strcmp(szClassName, "toolbarwindow32") == 0) {  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName
		if (!tbOnetime) {
			windowHandles.openSaveTBhwnd = cwps->hwnd;
			++tbOnetime;
			if (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) {
				bChangeHiddenState = ShowWindow(windowHandles.openSaveTBhwnd, SW_HIDE);
			}
		}
	}
	if (strcmp(szClassName, "syslistview32") == 0) {  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName
		if ((FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) | (FD_Flags & FD_HIDE_UP_BUTTON)) {
			tbInfo.cbSize = sizeof(TBBUTTONINFO);
			tbInfo.dwMask = TBIF_STATE;
			tbInfo.fsState = TBSTATE_HIDDEN | TBSTATE_INDETERMINATE;
			if (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) {
				buttonToDisable = (HANDLE)NEWBUTTONFOLDER;
				SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM)&tbInfo);
			} //else { // 08/13/02 was either or.  Couldn't use both
			if (FD_Flags & FD_HIDE_UP_BUTTON) {
				buttonToDisable = (HANDLE)UPONELEVELBUTTON;
				SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM)&tbInfo);
			}
			//SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM) &tbInfo);
		}

		switch (cwps->message)
		{
		case WM_NCPAINT:
		case LAST_LISTVIEW_MSG:
			if (FD_Flags & FD_FILES_ONLY) {  // 4/14/04 Only perform filter if FD_FILES_ONLY is set.
				count = ListView_GetItemCount(cwps->hwnd);
				for (i = 0; i < count; i++)
				{
					item.mask = LVIF_TEXT | LVIF_PARAM;
					item.iItem = i;
					item.iSubItem = 0;
					item.pszText = szItemName;
					item.cchTextMax = 255;
					ListView_GetItem(cwps->hwnd, &item);
					if (GetFileAttributes(szItemName) & FILE_ATTRIBUTE_DIRECTORY) {
						//if ( FD_Flags & FD_FILES_ONLY ) {
						ListView_DeleteItem(cwps->hwnd, i);
						//}
					}
				}  //end for
			}
			//break;

		case WM_NOTIFY:
			bSelectedItem = FALSE;
			strcpy_s(szPathName, sizeof(szPathName), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

			if (FD_Flags & FD_SELECT_DIRECTORY) {  // 4/14/04 Only perform search if FD_SELECT_DIRECTORY is selected
				// 4/14/04 Modified the code to directly get the selected item instead of looping
				// through each item in the list.
				i = ListView_GetNextItem(cwps->hwnd, -1, LVNI_ALL | LVNI_SELECTED);

				//count = ListView_GetItemCount(cwps->hwnd);
				//for( i = 0; i < count; i++)
				if (i != -1)
				{
					strcpy_s(szItemName, sizeof(szItemName), "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					item.mask = LVIF_TEXT | LVIF_STATE;
					item.iItem = i;
					item.iSubItem = 0;
					item.stateMask = LVIS_SELECTED;
					item.pszText = szItemName;
					item.cchTextMax = 255;
					ListView_GetItem(cwps->hwnd, &item);
					if (GetFileAttributes(szItemName) & FILE_ATTRIBUTE_DIRECTORY) {
						//if ( FD_Flags & FD_SELECT_DIRECTORY) {
						if (item.state & LVIS_SELECTED) {
							strcpy_s(szPathName, sizeof(szPathName), intrProcStr1);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
							if (szPathName[strlen(szPathName) - 1] != '\\') {
								strcat_s(szPathName, sizeof(szPathName), "\\");  // ZRW 3/22/17 WIN-39 strcat -> strcat_s
							}
							strcat_s(szPathName, sizeof(szPathName), szItemName);  // ZRW 3/22/17 WIN-39 strcat -> strcat_s
							SetDlgItemText(g_parentHndl, IDE_SELECTED, szPathName);
							bSelectedItem = TRUE;
							//break;
						}
						//}
					}
				}  //end if

				if (!bSelectedItem) {
					strcpy_s(szPathName, sizeof(szPathName), intrProcStr2);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					if (strlen(szPathName) > 0) {
						SetDlgItemText(g_parentHndl, IDE_SELECTED, intrProcStr1);
					}
				}
			}
		}  // end switch
	} // if (strcmp(_strlwr(szClassName), "syslistview32") == 0)

	return CallNextHookEx(hookHandles.openSaveHookHndl, hCode, wParam, lParam);
}

// ------------------------------------------------
//
//  FUNCTION: CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
//
//  PURPOSE:	Disables Lookin and/or Edit controls in open/save dialogs
//
//  COMMENTS: Called in hook procedure of open/save dialogs
//						Global FD_Flags used to determine which option
//	DATE:			dcc 07/10/01
//
BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
{
	INT_PTR			ctrlID;
	BOOL		bWindowEnabled;
	ctrlID = GetDlgCtrlID(hWnd);

	switch (ctrlID)
	{
	case LOOK_IN_COMBO:
		if (FD_Flags & FD_DISABLE_LOOKIN_FIELD) {
			bWindowEnabled = EnableWindow(hWnd, FALSE);
		}
		break;
	case EDIT_FIELD:
		if (FD_Flags & FD_DISABLE_EDIT_FIELD) {
			bWindowEnabled = EnableWindow(hWnd, FALSE);
		}
		break;
	}

	return TRUE;
}

// ------------------------------------------------
//
//  FUNCTION: TestNotify(HWND hDlg, LPOFNOTIFY pofn)
//
//  PURPOSE:  Used when Directory Selection is in play
//
//  COMMENTS:
//
//	DATE:			dcc 07/23/01
//
BOOL NEAR PASCAL TestNotify(HWND hDlg, LPOFNOTIFY pofn)
{
	switch (pofn->hdr.code)
	{
	case CDN_SELCHANGE:
	case CDN_FOLDERCHANGE: // A new folder has been opened.
	{
							   char szFile[MAX_PATH];

							   // Get the path of the selected file.
							   if (CommDlg_OpenSave_GetFilePath(GetParent(hDlg),
								   szFile, sizeof(szFile)) <= sizeof(szFile))
							   {
								   strcpy_s(intrProcStr2, sizeof(intrProcStr2), szFile);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
							   }
							   if (CommDlg_OpenSave_GetFolderPath(GetParent(hDlg), szFile, sizeof(szFile))
								   <= sizeof(szFile)) {
								   strcpy_s(intrProcStr1, sizeof(intrProcStr1), szFile);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
							   }
	}
		break;
	}

	return TRUE;
}

// ------------------------------------------------
//
//  FUNCTION: GetPlugInFullName( char *PlugInFullName)
//
//  PURPOSE:  Gets full path for WIN32API.4dx file.
//
//  COMMENTS: Needed to determine where to look for extra resources
//						Open file dialog etc
//
//	DATE: dcc 07/27/01
//
void GetPlugInFullName(char *PlugInFullName)
{
	// MWD 10/21/05 #9246
	// Use path name to 4DX obtained from entry point as opposed to Client/Server differentiation scheme.

	//char		tmpString[255];
	//check for client or stand-alone
	/*
	if ( PA_Is4DClient() ) {
	// get 4d folder, append structure name, append win4dx\Win32API.4dx
	PA_Get4Dfolder(PlugInFullName);
	PA_GetStructureName(tmpString);
	strcat(PlugInFullName, tmpString);
	strcat(PlugInFullName, "\\win4dx\\win32api.4dx");
	} else {
	PA_GetStructureFullPath(PlugInFullName);
	strcat(PlugInFullName, "win4dx\\win32api.4dx");
	}
	*/
	strcpy_s(PlugInFullName, 512, pathName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s, using 512 instead of sizeof(PlugInFullName) because the size of PlugInFullName is not defined, but it is filled with a variable whose size is defined to be 512
	return;
}

//  RETAIN FOR DEBUGGING
//  FUNCTION: ProcessCDError(DWORD)
//
//  PURPOSE: Processes errors from the common dialog functions.
//
//  COMMENTS:
//
//        This function is called whenever a common dialog function
//        fails.  The CommonDialogExtendedError() value is passed to
//        the function which maps the error value to a string table.
//        The string is loaded and displayed for the user.

void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
	WORD			wStringID;
	TCHAR			buf[MAX_PATH];
	HMODULE		hMod;
	char			plugInPath[255];

	GetPlugInFullName(plugInPath);
	hMod = GetModuleHandle(plugInPath);
	switch (dwErrorCode)
	{
	case CDERR_DIALOGFAILURE:   wStringID = IDS_DIALOGFAILURE;   break;
	case CDERR_STRUCTSIZE:      wStringID = IDS_STRUCTSIZE;      break;
	case CDERR_INITIALIZATION:  wStringID = IDS_INITIALIZATION;  break;
	case CDERR_NOTEMPLATE:      wStringID = IDS_NOTEMPLATE;      break;
	case CDERR_NOHINSTANCE:     wStringID = IDS_NOHINSTANCE;     break;
	case CDERR_LOADSTRFAILURE:  wStringID = IDS_LOADSTRFAILURE;  break;
	case CDERR_FINDRESFAILURE:  wStringID = IDS_FINDRESFAILURE;  break;
	case CDERR_LOADRESFAILURE:  wStringID = IDS_LOADRESFAILURE;  break;
	case CDERR_LOCKRESFAILURE:  wStringID = IDS_LOCKRESFAILURE;  break;
	case CDERR_MEMALLOCFAILURE: wStringID = IDS_MEMALLOCFAILURE; break;
	case CDERR_MEMLOCKFAILURE:  wStringID = IDS_MEMLOCKFAILURE;  break;
	case CDERR_NOHOOK:          wStringID = IDS_NOHOOK;          break;
	case PDERR_SETUPFAILURE:    wStringID = IDS_SETUPFAILURE;    break;
	case PDERR_PARSEFAILURE:    wStringID = IDS_PARSEFAILURE;    break;
	case PDERR_RETDEFFAILURE:   wStringID = IDS_RETDEFFAILURE;   break;
	case PDERR_LOADDRVFAILURE:  wStringID = IDS_LOADDRVFAILURE;  break;
	case PDERR_GETDEVMODEFAIL:  wStringID = IDS_GETDEVMODEFAIL;  break;
	case PDERR_INITFAILURE:     wStringID = IDS_INITFAILURE;     break;
	case PDERR_NODEVICES:       wStringID = IDS_NODEVICES;       break;
	case PDERR_NODEFAULTPRN:    wStringID = IDS_NODEFAULTPRN;    break;
	case PDERR_DNDMMISMATCH:    wStringID = IDS_DNDMMISMATCH;    break;
	case PDERR_CREATEICFAILURE: wStringID = IDS_CREATEICFAILURE; break;
	case PDERR_PRINTERNOTFOUND: wStringID = IDS_PRINTERNOTFOUND; break;
	case CFERR_NOFONTS:         wStringID = IDS_NOFONTS;         break;
	case FNERR_SUBCLASSFAILURE: wStringID = IDS_SUBCLASSFAILURE; break;
	case FNERR_INVALIDFILENAME: wStringID = IDS_INVALIDFILENAME; break;
	case FNERR_BUFFERTOOSMALL:  wStringID = IDS_BUFFERTOOSMALL;  break;

	case 0:   //User may have hit CANCEL or we got a *very* random error
		return;

	default:
		wStringID = IDS_UNKNOWNERROR;
	}

	LoadString(hMod, wStringID, buf, sizeof(buf));
	MessageBox(hWnd, buf, NULL, MB_OK);
	return;
}

void	FormatIP(char *rStr, LPARAM dwIP)
{
	char			addrSegment[4];
	BYTE			firstAddr, secondAddr, thirdAddr, fourthAddr;

	strcpy_s(rStr, 255, "");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s setting to 255 since routeString, the only variable passed to this method, is defined with a size of 255
	firstAddr = FIRST_IPADDRESS(dwIP);
	secondAddr = SECOND_IPADDRESS(dwIP);
	thirdAddr = THIRD_IPADDRESS(dwIP);
	fourthAddr = FOURTH_IPADDRESS(dwIP);
	_itoa(fourthAddr, addrSegment, 10);

    // ZRW 4/5/17 WIN-39 strcat -> strcat_s setting to 255 since routeString, the only variable passed to this method, is defined with a size of 255
	strcat_s(rStr, 255, addrSegment);
	strcat_s(rStr, 255, ".");
	_itoa(thirdAddr, addrSegment, 10);
	strcat_s(rStr, 255, addrSegment);
	strcat_s(rStr, 255, ".");
	_itoa(secondAddr, addrSegment, 10);
	strcat_s(rStr, 255, addrSegment);
	strcat_s(rStr, 255, ".");
	_itoa(firstAddr, addrSegment, 10);
	strcat_s(rStr, 255, addrSegment);

	return;
}

HWND getWindowHandle(char* windowTitle, HWND hWnd)
{
	HWND			MDIhWnd, MainhWnd, ChildhWnd, NexthWnd, returnValue = 0;
	char			WindowName[255];
	char			szClassName[255];
	LONG_PTR			windowTitle_len;

	windowTitle_len = strlen(windowTitle);

	_strlwr_s(windowTitle, MAXBUF);  // ZRW 4/12/17 WIN-39 Added here since we only need to do this once; Using MAXBUF since windowTitle is a pointer

	if (IsWindow(hWnd)) {
		NexthWnd = hWnd;
		GetClassName(NexthWnd, szClassName, 255);
		do {
			
			_strlwr_s(szClassName, sizeof(szClassName));  // ZRW 4/12/17 WIN-39 
						
			if (strcmp(szClassName, "mdiclient") == 0){  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName
				windowHandles.MDIhWnd = NexthWnd;
				MDIhWnd = NexthWnd;
				
				if (strcmp(windowTitle, "mdi") == 0){  // ZRW 4/12/17 WIN-39 _strlwr(windowTitle) -> windowTitle
					return NexthWnd;
				}
				else {
					break;
				}
			}
			MDIhWnd = NexthWnd;
			NexthWnd = GetParent(MDIhWnd);
			GetClassName(NexthWnd, szClassName, 255);
		} while (NexthWnd != NULL);
	}
	else {
		returnValue = 0;
		return returnValue;
	}

	if (IsWindow(MDIhWnd)) {
		// Now if the caller wants the main window the
		// windowTitle will be blank
		if (windowTitle_len == 0) {
			// Get the parent of the MDI Window
			// REB 4/14/11 #25290 If we already have the main window handle make sure
			// we use it.
			if (IsWindow(GetParent(MDIhWnd))){
				MainhWnd = GetParent(MDIhWnd);
			}
			else{
				MainhWnd = MDIhWnd;
			}

			if (IsWindow(MainhWnd)) {
				returnValue = MainhWnd;
				return returnValue;
			}
			else {
				returnValue = 0;
				return returnValue;
			}
		}
		else {
			// Search all the child windows for the window
			// with a Title matching windowTitle
			NexthWnd = GetWindow(MDIhWnd, GW_CHILD);
			do {
				ChildhWnd = NexthWnd;
				if (IsChild(MDIhWnd, ChildhWnd)) {
					GetWindowText(ChildhWnd, WindowName, 256);
					GetClassName(ChildhWnd, szClassName, 255);

					_strlwr_s(WindowName, (sizeof(WindowName))); // SDL 8/25/17 WIN-39
					_strlwr_s(szClassName, (sizeof(szClassName)));  // ZRW 4/12/17 WIN-39
					
					if ((strcmp(szClassName, "mdiclient") == 0) && (strcmp(windowTitle, "mdi") == 0)){  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName, _strlwr(windowTitle) -> windowTitle
						return ChildhWnd;
					}
					NexthWnd = GetNextWindow(ChildhWnd, GW_HWNDNEXT);
				}
				else {
					returnValue = 0;
					return returnValue;
				}
			} while (strcmp(windowTitle, WindowName) != 0);  // ZRW 4/12/17 WIN-39 _strlwr(WindowName) -> WindowName, _strlwr(windowTitle) -> windowTitle
			// Match found
			returnValue = ChildhWnd;
		}
	}
	else {
		returnValue = 0;
	}
	return returnValue;
}

//  FUNCTION: newProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept procedure for 4D window
//
//  COMMENTS:	Used with sys_GetPrintJob and gui_SetTrayIcon functions
//
//	DATE:		dcc 11/17/01

LRESULT APIENTRY newProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND					printWndHndl = NULL, childhWnd = NULL, nexthWnd = NULL;
	LONG_PTR					command; // 01/22/03
	static LONG_PTR		count = 1;
	char					windowName[255];
	char					dlgCaption[15];

	switch (uMsg)
	{
	case (WM_USER + 0x0021) :
		if ((lParam == WM_LBUTTONDOWN) || (lParam == WM_RBUTTONDOWN) || (lParam == WM_LBUTTONDBLCLK) || (lParam == WM_RBUTTONDBLCLK)) {
			processWindowMessage(TRAY_ICON_FUNCTION, (LONG_PTR)hwnd, wParam, lParam);
		}
		break;
		// 01/22/03 added check for maximize
	case WM_SYSCOMMAND: //this tells a subsequent WM_GETMINMAXINFO command
		// that it is okay to proceed if we are in the process of a maximize command.
		if (toolBarRestrictions.toolBarOnDeck) {
			command = wParam & 0xFFF0;
			if ((SC_MAXIMIZE == command) || (SC_SIZE == command) || (SC_RESTORE == command)) {
				//get frontmost window
				childhWnd = GetTopWindow(windowHandles.MDIhWnd);
				if (IsZoomed(childhWnd)) {
					switch (command)
					{
					case SC_MAXIMIZE:
						toolBarRestrictions.appBeingMaxed = APP_MAXIMIZING;
						break;

					case SC_RESTORE:
						toolBarRestrictions.appBeingMaxed = APP_RESTORING;
						//ShowWindowAsync (childhWnd, SW_SHOWMAXIMIZED);
						break;

					case SC_SIZE:
						toolBarRestrictions.appBeingMaxed = APP_SIZING_W_CHLDMAX;
						if (IsZoomed(windowHandles.fourDhWnd)) {
							toolBarRestrictions.appWindowState = APP_MAXIMIZED;
						}
						else {
							toolBarRestrictions.appWindowState = APP_NORM;
						}
						//PostMessage(childhWnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
						break;
					}
					//command = (LONG_PTR)childhWnd;
					//command *= -1;
				}
				else {
					processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, command, 0L, 0L);
				}
			}
		}
		break;

	case WM_EXITSIZEMOVE: // 01/27/03
		if (toolBarRestrictions.appBeingMaxed == APP_SIZING_W_CHLDMAX) {
			toolBarRestrictions.appBeingMaxed = 0;
			processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, WM_EXITSIZEMOVE, 0L, 0L);
		}
		break;

	case WM_SIZE:
		if ((toolBarRestrictions.appBeingMaxed == APP_MAXIMIZING) || (toolBarRestrictions.appBeingMaxed == APP_RESTORING)) {
			processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, toolBarRestrictions.appBeingMaxed, 0L, 0L);
		}
		break;
	default:
		// g_intrProcMsg will be PS_IDLE unless print dialogs have been requested
		if ((g_intrProcMsg != PS_IDLE) && (count % 5 == 0) && (g_intrProcMsg < 2)) {
			if (g_intrProcMsg == 0) { // 12/12/01
				strcpy_s(dlgCaption, sizeof(dlgCaption), "Print Setup");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			}
			else {
				strcpy_s(dlgCaption, sizeof(dlgCaption), "Print");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
			}
			if ((g_intrProcMsg == 0) || ((g_intrProcMsg == 1) && (strcmp(dlgCaption, "Print") == 0))) {
				nexthWnd = GetWindow(hwnd, GW_HWNDPREV);
				do {
					childhWnd = nexthWnd;
					GetWindowText(childhWnd, windowName, 256);
					if (strcmp("Print", windowName) == 0){  // AMS2 11/19/14 #40697 Fixed detection of Print Job window, previously the method assumed that it would always see Print Setup before Print Job.
						strcpy_s(dlgCaption, sizeof(dlgCaption), "Print");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
						g_intrProcMsg = 1;
					}
					nexthWnd = GetNextWindow(childhWnd, GW_HWNDPREV);
					if (nexthWnd == NULL) {
						count += 1;
						return CallWindowProc(processHandles.wpFourDOrigProc, hwnd, uMsg, wParam, lParam);
					}
				} while (strcmp(dlgCaption, windowName) != 0);
				// Match found
				printWndHndl = childhWnd;

				if (printWndHndl > 0) {
					strcpy_s(dlgCaption, sizeof(dlgCaption), "Print");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					g_intrProcMsg += 1;
					switch (g_intrProcMsg)
					{
					case 1:
						windowHandles.prthWnd = 0;
						// REB 3/18/11 #25290
						processHandles.wpPrintSettingsDlgOrigProc = (WNDPROC)SetWindowLongPtr(printWndHndl, DWLP_DLGPROC, (LONG_PTR)newPrtSettingsDlgProc);
						//processHandles.wpPrintSettingsDlgOrigProc = (WNDPROC) SetWindowLong(printWndHndl, DWL_DLGPROC, (LONG) newPrtSettingsDlgProc);
						windowHandles.prtSettingshWnd = printWndHndl;
						break;

					case 2:
						// REB 3/18/11 #25290
						processHandles.wpPrintDlgOrigProc = (WNDPROC)SetWindowLongPtr(printWndHndl, DWLP_DLGPROC, (LONG_PTR)newPrtDlgProc);
						//processHandles.wpPrintDlgOrigProc = (WNDPROC) SetWindowLong(printWndHndl, DWL_DLGPROC, (LONG) newPrtDlgProc);
						//restoreOrig4DWindowProcess(); // 01/21/03 // MJG 3/26/04 The 4D window will remain subclassed until the plug-in is unloaded.
						//if (activeCalls.bTrayIcons == FALSE) {
						//SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) processHandles.wpFourDOrigProc);
						//}
						windowHandles.prthWnd = printWndHndl;
						break;
					} // end switch
				} //(printWndHndl > 0)
			} //((g_intrProcMsg == 1) && (strcmp(dlgCaption, "Print") == 0))
		} //((count % 10 == 0) && (g_intrProcMsg < 2))

		count += 1;
	} // end switch

	return CallWindowProc(processHandles.wpFourDOrigProc, hwnd, uMsg, wParam, lParam);
}

//  FUNCTION: newDlgPrtSettingsProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept print setup dialog
//
//  COMMENTS:
//
//	DATE:			dcc 11/17/01

LRESULT APIENTRY newPrtSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (hookHandles.printSettingsHookHndl == NULL) {
		hookHandles.printSettingsHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)printSettingsDlgHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
	}
	return CallWindowProc(processHandles.wpPrintSettingsDlgOrigProc, hwnd, uMsg, wParam, lParam);
}

// ------------------------------------------------
//
//  FUNCTION: printSettingsDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Get change of printer if combo box accessed
//
//	DATE:			dcc 11/17/01
//
// WJF 6/30/16 Win-21 INT_PTR_INT
LRESULT CALLBACK printSettingsDlgHook(INT hCode, WPARAM wParam, LPARAM lParam)
{
	CWPRETSTRUCT	*cwrps = (CWPRETSTRUCT*)lParam;

	if (cwrps->message == WM_COMMAND) {
		EnumChildWindows(windowHandles.prtSettingshWnd, EnumChildProc2, (LPARAM)PS_PRTSETTINGSDLG);
	}
	return CallNextHookEx(hookHandles.printSettingsHookHndl, hCode, wParam, lParam);
}

//  FUNCTION: newPrtDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept print dialog
//
//  COMMENTS:
//
//	DATE:			dcc 11/17/01

LRESULT APIENTRY newPrtDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (hookHandles.printHookHndl == NULL) {
		UnhookWindowsHookEx(hookHandles.printSettingsHookHndl);
		hookHandles.printSettingsHookHndl = NULL;
		hookHandles.printHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)printDlgHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
	}
	return CallWindowProc(processHandles.wpPrintDlgOrigProc, hwnd, uMsg, wParam, lParam);
}

// ------------------------------------------------
//
//  FUNCTION: printDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Get change of printer if combo box accessed
//
//	DATE:			dcc 11/17/01
//
// WJF 6/30/16 Win-21 INT_PTR_INT
LRESULT CALLBACK printDlgHook(INT hCode, WPARAM wParam, LPARAM lParam)
{
	CWPRETSTRUCT	*cwrps = (CWPRETSTRUCT*)lParam;

	if (cwrps->message == WM_COMMAND) {
		EnumChildWindows(windowHandles.prthWnd, EnumChildProc2, (LPARAM)PS_PRTDLG);
	}

	return CallNextHookEx(hookHandles.printHookHndl, hCode, wParam, lParam);
}

// ------------------------------------------------
//
//  FUNCTION: CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam)
//
//  PURPOSE:	Find combo box ID with printer names
//
//  COMMENTS: Possible chg this later to constant control ID of 1136
//
//	DATE:			dcc 10/23/01
//
//  MODIFICATIONS: 11/05/02 Added ID var to better debug.  Also added control ID 1136 for
//									comboBox on PrintSettings dialog. (3.5.2)
BOOL CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam)
{
	char						szClassName[255];
	LONG_PTR					ID;
	LRESULT						ndx;

	GetClassName(hWnd, szClassName, 255);

	_strlwr_s(szClassName, sizeof(szClassName));  // ZRW 4/12/17 WIN-39 

	if (strcmp(szClassName, "combobox") == 0) {  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName
		ID = GetDlgCtrlID(hWnd);
		switch (ID)
		{
		case ID_CB_PRINTER:
		case 1136:
			ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
			SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.printerSelection);
			break;
		case ID_CB_PAPERSIZE:
			ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
			SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.size);
			break;
		case ID_CB_SOURCE:
			ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
			SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.source);
			break;
		}
	}
	if (strcmp(szClassName, "button") == 0) {  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName
		ID = GetDlgCtrlID(hWnd);

		switch (ID)
		{
		case ID_BTN_PORTRAIT:
			if (lParam == PS_PRTSETTINGSDLG) {
				if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
					printerSettings.portraitLandscape = PS_PORTRAIT;
				}
				else {
					printerSettings.portraitLandscape = PS_LANDSCAPE;
				}
			}
			break;

		case ID_BTN_PRINTTOFILE:
			if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
				printerSettings.printToFile = TRUE;
			}
			else {
				printerSettings.printToFile = FALSE;
			}
			break;
		case ID_BTN_PRINTPREVIEW:
			if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
				printerSettings.printPreview = TRUE;
			}
			else {
				printerSettings.printPreview = FALSE;
			}
			break;
		}
	}
	if (strcmp(szClassName, "edit") == 0) {  // ZRW 4/12/17 WIN-39 _strlwr(szClassName) -> szClassName
		// REB 5/13/08 #16829 Storing control ID in ID now.
		ID = GetDlgCtrlID(hWnd);
		switch (ID)
		{
		case ID_EDIT_COPIES:
			ndx = SendMessage(hWnd, WM_GETTEXT, (WPARAM)4, (LPARAM)printerSettings.copies);
			printerSettings.copies[ndx] = '\0';
			break;
		}
	}

	// AMS2 11/26/14 #40697 Below is an attempt to get the printer information that is not visible on the print job dialog with the scanner above.
	// The part that is causing problems is the call to DocumentProperties. I'm not sure if that is the correct window handle to pass in, but the printer handle/device name and other parameters seem to be correct.
	// The issue is that the printerInfo that is returned does not match the settings that are input. I attempted to move this to sys_getPrintSettings but the PA parameter for the return array seemed to be replaced with a null address instead of the array's address.
	/*
	if (strlen(printerSettings.printerSelection) != 0){
	strcpy(printerName, printerSettings.printerSelection);
	OpenPrinter(printerName, &hPrintHandle, NULL); // get the handle
	//printerBuffer = &pInfo;
	LONG result = GetPrinter(hPrintHandle, dwLevel, NULL, 0, &dwPrinterSize); // get the info for the printer

	PRINTER_INFO_2	*pInfo = (PRINTER_INFO_2*)malloc(dwPrinterSize);
	GetPrinter(hPrintHandle, 2, (LPBYTE)pInfo, dwPrinterSize, &dwPrinterSize);

	deviceName = pInfo->pPrinterName;
	pPort = pInfo->pPortName;
	//DeviceCapabilities(deviceName, pPort, DC_SIZE, capabilities, NULL);
	//DocumentProperties(hWnd, hPrintHandle, deviceName, printerInfo, printInput, DM_OUT_BUFFER); //windowHandles.prthWnd
	ClosePrinter(hPrintHandle);
	}
	*/
	return TRUE;
}

// ------------------------------------------------
//
//  FUNCTION: enumPrintersUsingRegistry( PA_Variable *printerArray )
//
//  PURPOSE:	Alternative function for enum printers
//
//  COMMENTS: Uses registry for NT/2000/XP
//						Returns positon of default printer in array
//
//	DATE:			dcc 04/20/02
//
// WJF 6/29/16 Win-21 LONG_PTR -> LONG
LONG enumPrintersUsingRegistry(PA_Variable *printerArray)
{
	LONG					returnValue = 0, errorCode = 0; // WJF 6/29/16 Win-21 LONG_PTR -> LONG and initialized errorCode
	HKEY					hKeyWindows, hKeyDevices, rootKey;
	char					subKey[100];
	DWORD					dwIndex = 0;
	DWORD					dwType = REG_SZ;
	DWORD					resultSize = 150, dataSize = 150;
	char					sz[150], szData[150], defPrinter[150];

	// get default printer
	strcpy_s(subKey, sizeof(subKey), "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	rootKey = HKEY_CURRENT_USER; //HKEY_LOCAL_MACHINE;
	hKeyWindows = HKEY_CURRENT_USER; // will get new handle of open key
	hKeyDevices = HKEY_CURRENT_USER;
	errorCode = RegOpenKeyEx(rootKey, subKey, 0, KEY_READ, &hKeyWindows);
	if (errorCode != ERROR_SUCCESS) {
		return returnValue;;
	}

	errorCode = RegQueryValueEx(hKeyWindows, "Device", NULL, &dwType, (LPBYTE)szData, &resultSize); // WJF 6/24/16 Win-21 Casting to LPBYTE
	if (errorCode != ERROR_SUCCESS) {
	}
	else {
		strcpy_s(defPrinter, sizeof(defPrinter), szData);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	} //(errorCode != ERROR_SUCCESS)
	errorCode = RegCloseKey(hKeyWindows);

	strcpy_s(subKey, sizeof(subKey), "Software\\Microsoft\\Windows NT\\CurrentVersion\\Devices");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
	errorCode = RegOpenKeyEx(rootKey, subKey, 0, KEY_READ, &hKeyDevices);
	if (errorCode != ERROR_SUCCESS) {
		return returnValue;;
	}
	resultSize = 150;
	errorCode = RegEnumValue(hKeyDevices, dwIndex, sz, &resultSize, NULL, &dwType, (LPBYTE)szData, &dataSize); // WJF 6/24/16 Win-21 Casting to LPBYTE
	while (errorCode != ERROR_NO_MORE_ITEMS)
	{
		if (errorCode == ERROR_SUCCESS) {
			// get data for device (printer)
			PA_ResizeArray(printerArray, (LONG_PTR)dwIndex + 1);
			
			  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
			strcat_s(sz, sizeof(sz), ",");
			strcat_s(sz, sizeof(sz), szData);
			if (strcmp(sz, defPrinter) == 0) {
				returnValue = dwIndex + 1;
			}
			PA_SetTextInArray(*printerArray, dwIndex + 1, sz, strlen(sz));
		}
		dwIndex++;
		resultSize = 150;
		dataSize = 150;
		errorCode = RegEnumValue(hKeyDevices, dwIndex, sz, &resultSize, NULL, &dwType, (LPBYTE)szData, &dataSize); // WJF 6/24/16 Win-21 Casting to LPBYTE
	}

	errorCode = RegCloseKey(hKeyDevices);
	return returnValue;
}

// ------------------------------------------------
//
//  FUNCTION: enumPrintersUsingINI( PA_Variable *printerArray )
//
//  PURPOSE:	Alternative function for enum printers
//
//  COMMENTS: Uses Win.ini file for 95/98/Me
//						Returns positon of default printer in array
//
//	DATE:			dcc 04/20/02
//
// ZRW 4/26/17 WIN-39 Removed the method, it isn't used anywhere and I didn't want to update strtok to strtok_s for no reason. You can see this method in previous versions


// ------------------------------------------------
//
//  FUNCTION: sys_GetTimeZoneList( PA_PluginParameters params )
//
//  PURPOSE:  Returns an array containing time zone information for all time zones
//				defined on the system.  Each element is in the form:
//				TimeZoneName;Current Time;Current Date
//
//
//  REB 4/6/09 #19472

void sys_GetTimeZoneList(PA_PluginParameters params)
{
	PA_Variable		atTZ;
	char			standardName[255];
	char			daylightName[255];
	char			displayName[255];
	LONG_PTR			displayName_len;
	LONG			returnValue, errorCode; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HKEY			hkTimeZone, hkRootKey;
	char			TimeStr[255];
	char			hours[3];  // ZRW 5/4/17 WIN-39 Increased from 2 to 3 to account for the null terminator
	char			mins[3];  // ZRW 5/4/17 WIN-39 Increased from 2 to 3 to account for the null terminator
	char			secs[3];  // ZRW 5/4/17 WIN-39 Increased from 2 to 3 to account for the null terminator
	char			DateStr[255];
	char			month[3];  // ZRW 5/4/17 WIN-39 Increased from 2 to 3 to account for the null terminator
	char			day[3];  // ZRW 5/4/17 WIN-39 Increased from 2 to 3 to account for the null terminator
	char			year[11];  // ZRW 5/4/17 WIN-39 Increased from 10 to 11 to account for the null terminator
	char			TZ[512];
	DWORD			dwSubKeys, dwValues, dwDataSize;
	REG_TZI_FORMAT	TZInfoFormat;
	DWORD			index = 1;
	char			rootTimeZoneKey[60] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";
	DWORD			dwIndex = 0;
	TCHAR			tcKeyName[512];
	DWORD			dwcbName = 512 * sizeof(TCHAR);
	FILETIME		ftLastWrite;
	TIME_ZONE_INFORMATION TimeZoneInformation;
	SYSTEMTIME		SystemTimeNow, LocalTime;
	size_t          *numConverted = NULL;  // ZRW 5/1/17 WIN-39
	
	// For some reason we are unable to return 3 arrays to 4D.  Instead we'll return
	// a single array with all three data items in semicolon delimited elements.

	atTZ = PA_GetVariableParameter(params, 1);
	PA_ResizeArray(&atTZ, 0);

	returnValue = -1; // Assume we fail, this is set to the number of time zones once we successfully open the root TZ key.

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, rootTimeZoneKey, 0, KEY_READ, &hkRootKey) == ERROR_SUCCESS)
	{
		if (RegQueryInfoKey(hkRootKey, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
		{
			PA_ResizeArray(&atTZ, dwSubKeys);

			returnValue = dwSubKeys; // Return the number of time zones we've found.

			while (RegEnumKeyEx(hkRootKey, dwIndex++, tcKeyName, &dwcbName, NULL, NULL, NULL, &ftLastWrite) != ERROR_NO_MORE_ITEMS)
			{
				if (RegOpenKeyEx(hkRootKey, tcKeyName, 0, KEY_READ, &hkTimeZone) == ERROR_SUCCESS)
				{
					// Get TZI Upper Bytes
					dwDataSize = sizeof(TZInfoFormat);
					errorCode = RegQueryValueEx(hkTimeZone, "TZI", NULL, NULL, (BYTE*)&TZInfoFormat, &dwDataSize);

					TimeZoneInformation.Bias = TZInfoFormat.Bias;
					TimeZoneInformation.DaylightBias = TZInfoFormat.DaylightBias;
					TimeZoneInformation.DaylightDate = TZInfoFormat.DaylightDate;
					TimeZoneInformation.StandardBias = TZInfoFormat.StandardBias;
					TimeZoneInformation.StandardDate = TZInfoFormat.StandardDate;

					// Get Text Values
					dwDataSize = 255;
					if (RegQueryValueEx(hkTimeZone, "Display", NULL, NULL, (LPBYTE)&displayName, &dwDataSize) != ERROR_SUCCESS)
					{
						strcpy_s(displayName, sizeof(displayName), "n/a");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					}
					displayName_len = strlen(displayName);

					strcpy_s(TZ, sizeof(TZ), displayName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

					dwDataSize = 255;
					if (RegQueryValueEx(hkTimeZone, "Dlt", NULL, NULL, (LPBYTE)&daylightName, &dwDataSize) != ERROR_SUCCESS)
					{
						strcpy_s(daylightName, sizeof(daylightName), "n/a");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					}

					//mbstowcs(TimeZoneInformation.DaylightName, daylightName, dwDataSize);
					mbstowcs_s(numConverted, TimeZoneInformation.DaylightName, sizeof(TimeZoneInformation.DaylightName), daylightName, dwDataSize);  // ZRW 5/1/17 WIN-39 mbstowcs -> mbstowcs_s

					dwDataSize = 255;
					if (RegQueryValueEx(hkTimeZone, "Std", NULL, NULL, (LPBYTE)&standardName, &dwDataSize) != ERROR_SUCCESS)
					{
						strcpy_s(standardName, sizeof(standardName), "n/a");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					}
					//mbstowcs(TimeZoneInformation.StandardName, standardName, dwDataSize);
					mbstowcs_s(numConverted, TimeZoneInformation.StandardName, sizeof(TimeZoneInformation.StandardName), standardName, dwDataSize);  // ZRW 5/1/17 WIN-39 mbstowcs -> mbstowcs_s

					RegCloseKey(hkTimeZone);

					// Get the current time in UTC
					GetSystemTime(&SystemTimeNow);

					// Get the current time in the specified time zone.
					SystemTimeToTzSpecificLocalTime(&TimeZoneInformation, &SystemTimeNow, &LocalTime);

					// ZRW 5/4/17 WIN-39 Apparently converting a WORD variable to a character variable here was causing a buffer overflow; rather than use itoa or itoa_s to convert to a char array, we'll convert to a string first, then grab the first two characters of that string
					
					_itoa(LocalTime.wHour, hours, 10);
					_itoa(LocalTime.wMinute, mins, 10);
					_itoa(LocalTime.wSecond, secs, 10);

					//  ZRW 4/5/17 WIN-39 strcat -> strcat_s for the rest of this method
					strcpy_s(TimeStr, sizeof(TimeStr), hours);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					strcat_s(TimeStr, sizeof(TimeStr), ":");
					strcat_s(TimeStr, sizeof(TimeStr), mins);
					strcat_s(TimeStr, sizeof(TimeStr), ":");
					strcat_s(TimeStr, sizeof(TimeStr), secs);

					strcat_s(TZ, sizeof(TZ), ";");
					strcat_s(TZ, sizeof(TZ), TimeStr);

					_itoa(LocalTime.wDay, day, 10);
					_itoa(LocalTime.wMonth, month, 10);
					_itoa(LocalTime.wYear, year, 10);

					strcpy_s(DateStr, sizeof(DateStr), month);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					strcat_s(DateStr, sizeof(DateStr), "/");
					strcat_s(DateStr, sizeof(DateStr), day);
					strcat_s(DateStr, sizeof(DateStr), "/");
					strcat_s(DateStr, sizeof(DateStr), year);

					strcat_s(TZ, sizeof(TZ), ";");
					strcat_s(TZ, sizeof(TZ), DateStr);

					strcpy_s(TZ, sizeof(TZ), displayName);  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s
					strcat_s(TZ, sizeof(TZ), ";");
					strcat_s(TZ, sizeof(TZ), TimeStr);
					strcat_s(TZ, sizeof(TZ), ";");
					strcat_s(TZ, sizeof(TZ), DateStr);

					PA_SetTextInArray(atTZ, index, TZ, strlen(TZ));
				}
				dwcbName = 512 * sizeof(TCHAR);
				++index;
			}
		}
		RegCloseKey(hkRootKey);
	}

	PA_SetVariableParameter(params, 1, atTZ, 0);

	PA_ReturnLong(params, returnValue);
}

// Note, this does not need to use the semaphore since it is already waiting on a file
void TWAIN_GetSources(PA_PluginParameters params)
{
	LONG				returnValue, debug; // WJF 6/30/21 Win-21 LONG_PTR -> LONG
	DWORD				index = 1;
	PA_Variable			atSources;
	// TW_IDENTITY			NewSourceId; // WJF 9/14/15 #43727 Removed
	char				lpParameters[16] = "-S"; // WJF 9/21/15 #43940 3 -> 16
	char				filePath[MAX_PATH] = "";
	BOOL				get64 = FALSE;
	FILE				*fp = NULL;
	char				source[256] = "";
	char				pluginPath[MAX_PATH] = "";
	char				*pos = NULL;
	SHELLEXECUTEINFO	utilities;
	DWORD				dwExitCode = 0;
	BOOL				bSuccess = FALSE;
	BOOL				bDoNotAddSuffix = FALSE; // WJF 10/27/16 Win-41
	LONG				flags = 0x0000; // SDL 10/3/17 WIN-51 "optional" parameter. Include WIA by default and create room for future flags // SDL 1/31/18 H-9141 UNLONG -> LONG

	atSources = PA_GetVariableParameter(params, 1);
	PA_ResizeArray(&atSources, 0);

	debug = PA_GetLongParameter(params, 2);

	get64 = PA_GetLongParameter(params, 3);

	bDoNotAddSuffix = PA_GetLongParameter(params, 4); // WJF 10/27/16 Win-41

	flags = PA_GetLongParameter(params, 5); // SDL 10/3/17 WIN-51 

	returnValue = 1;

	// WJF 9/11/15 #43727 Begin changes

	strcpy_s(pluginPath, MAX_PATH, pathName);

	pos = strrchr(pluginPath, '\\');

	strcpy_s(pos, MAX_PATH, "\0");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	pos = strrchr(pluginPath, '\\');

	strcpy_s(pos, MAX_PATH, "\\\0");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	// WJF 9/21/15 #43940 OrchardTwain -> Orchard_Utilities
	if (get64){
		strcpy_s(pos, MAX_PATH, "\\Windows64\\Orchard_Utilities.exe");
	}
	else {
		strcpy_s(pos, MAX_PATH, "\\Windows\\Orchard_Utilities.exe");
	}

	GetTempPath(MAX_PATH, filePath);

	strcat_s(filePath, sizeof(filePath), "twainSources.txt");  // ZRW 4/5/17 WIN-39 MAX_PATH -> sizeof(filePath)

	// WJF 3/29/16 Win-11 Begin Changes
	utilities.cbSize = sizeof(SHELLEXECUTEINFO);
	utilities.fMask = SEE_MASK_NOCLOSEPROCESS;
	utilities.hInstApp = NULL;
	utilities.hwnd = windowHandles.fourDhWnd;
	utilities.lpFile = pluginPath;
	utilities.lpParameters = lpParameters;
	utilities.lpDirectory = NULL;
	utilities.nShow = SW_HIDE;
	utilities.lpVerb = NULL;

	if (ShellExecuteEx(&utilities)) {
		PA_YieldAbsolute();
		PA_YieldAbsolute();
		PA_YieldAbsolute();

		do {
			bSuccess = GetExitCodeProcess(utilities.hProcess, &dwExitCode);
			PA_YieldAbsolute();
		} while ((dwExitCode == STILL_ACTIVE) && (bSuccess));

		//fp = fopen(filePath, "r");
		fopen_s(&fp, filePath, "r");  // ZRW 4/13/17 WIN-39 Using the more scure method

		if (fp){
			while (fgets(source, 256, fp) != NULL){
				if (strcmp(source, "-1\n") == 0){ // Failed to load Twain library // WJF 3/7/16 Win-7 Added \n
					returnValue = -1;
				}
				else if (strcmp(source, "-2\n") == 0){ // Failed to open Data Source Manager // WJF 3/7/16 Win-7 Added \n
					returnValue = -2;
				}
				else if (strcmp(source, "") == 0){ // Empty line
					// do nothing
				}
				else { // Valid Product Name
					pos = strrchr(source, '\n');
					strcpy_s(pos, MAX_PATH, "\0");  // ZRW 3/22/17 WIN-39 256 -> MAX_PATH

					if (!bDoNotAddSuffix) // WJF 10/27/16 Win-41 Do not add suffix if this is TRUE
					{
						strcat_s(source, sizeof(source), "-TWAIN"); // WJF 9/21/15 #43940  // ZRW 4/5/17 WIN-39 256 -> sizeof(source)
					}

					PA_ResizeArray(&atSources, index);
					PA_SetTextInArray(atSources, index, source, strlen(source));
					++index;
				}
			}

			fclose(fp);

			fp = NULL;

			DeleteFile(filePath);
		}
	}
	else {
		returnValue = -1;
	}

	if (!(flags & TW_FLAG_EXCLUDE_WIA)){ // SDL 10/3/17 WIN-51 Option to include WIA drivers (default)
		GetTempPath(MAX_PATH, filePath);

		strcat_s(filePath, sizeof(filePath), "wiaSources.txt");  // ZRW 4/5/17 WIN-39 MAX_PATH -> sizeof(filePath)

		strcpy_s(lpParameters, sizeof(lpParameters), "-ws");  // ZRW 3/22/17 WIN-39 16 -> sizeof(lpParameters)

		utilities.hProcess = NULL;
		utilities.lpParameters = lpParameters;

		if (ShellExecuteEx(&utilities)) {
			PA_YieldAbsolute();
			PA_YieldAbsolute();
			PA_YieldAbsolute();

			do {
				bSuccess = GetExitCodeProcess(utilities.hProcess, &dwExitCode);
				PA_YieldAbsolute();
			} while ((dwExitCode == STILL_ACTIVE) && (bSuccess));

			//fp = fopen(filePath, "r");
			fopen_s(&fp, filePath, "r");  // ZRW 4/13/17 WIN-39 Using the more secure method

			if (fp){
				while (fgets(source, 256, fp) != NULL){
					if (strcmp(source, "") != 0){
						pos = strrchr(source, '\n');
						strcpy_s(pos, MAX_PATH, "\0");  // ZRW 3/22/17 WIN-39 256 -> MAX_PATH

						if (!bDoNotAddSuffix) // WJF 10/27/16 Win-41 Do not add suffix if this is TRUE
						{
							strcat_s(source, sizeof(source), "-WIA");  // ZRW 4/5/17 WIN-39 256 -> sizeof(source)
						}

						PA_ResizeArray(&atSources, index);
						PA_SetTextInArray(atSources, index, source, strlen(source));
						++index;
					}
				}

				fclose(fp);

				fp = NULL;
			}

			DeleteFile(filePath);
		}
		else {
			returnValue = -2;
		}
	}

	// WJF 3/29/16 Win-11 Rewrote
	/*
	utilitiesLock(); // WJF 9/21/15 #43940

	ShellExecute(windowHandles.fourDhWnd, "", pluginPath, lpParameters, NULL, SW_HIDE);

	if (GetLastError() == ERROR_SUCCESS){
	PA_YieldAbsolute();
	PA_YieldAbsolute();
	PA_YieldAbsolute();

	if (utilitiesYield(NULL, TRUE, FALSE) == ERROR_SUCCESS){ // WJF 9/21/15 #43940 Moved to common method // WJF 12/17/15 Win-7 Added TRUE, FALSE
	fp = fopen(filePath, "r");

	if (fp){
	while (fgets(source, 256, fp) != NULL){
	if (strcmp(source, "-1\n") == 0){ // Failed to load Twain library // WJF 3/7/16 Win-7 Added \n
	returnValue = -1;
	}
	else if (strcmp(source, "-2\n") == 0){ // Failed to open Data Source Manager // WJF 3/7/16 Win-7 Added \n
	returnValue = -2;
	}
	else if (strcmp(source, "") == 0){ // Empty line
	// do nothing
	}
	else { // Valid Product Name
	pos = strrchr(source, '\n');
	strcpy_s(pos, 256, "\0");
	strcat_s(source, 256, "-TWAIN"); // WJF 9/21/15 #43940
	PA_ResizeArray(&atSources, index);
	PA_SetTextInArray(atSources, index, source, strlen(source));
	++index;
	}
	}

	fclose(fp);

	fp = NULL;

	DeleteFile(filePath);
	}
	}
	else { // WJF 12/17/15 Win-7
	returnValue = -2;
	}

	// WJF 9/21/15 #43940 Begin Changes
	GetTempPath(MAX_PATH, filePath);

	strcat_s(filePath, MAX_PATH, "wiaSources.txt");

	strcpy_s(lpParameters, 16, "-ws");

	utilitiesLock();

	ShellExecute(windowHandles.fourDhWnd, "", pluginPath, lpParameters, NULL, SW_HIDE);

	if (GetLastError() == ERROR_SUCCESS){
	PA_YieldAbsolute();
	PA_YieldAbsolute();
	PA_YieldAbsolute();

	if (utilitiesYield(NULL, TRUE, FALSE) == ERROR_SUCCESS){ // WJF 9/21/15 #43601 Moved to common method // WJF 12/17/15 Win-7
	fp = fopen(filePath, "r");

	if (fp){
	while (fgets(source, 256, fp) != NULL){
	if (strcmp(source, "") != 0){
	pos = strrchr(source, '\n');
	strcpy_s(pos, 256, "\0");
	strcat_s(source, 256, "-WIA");
	PA_ResizeArray(&atSources, index);
	PA_SetTextInArray(atSources, index, source, strlen(source));
	++index;
	}
	}

	fclose(fp);

	fp = NULL;
	}

	DeleteFile(filePath); // WJF 9/21/15 #43940
	}
	else { // WJF 12/17/15 Win-7
	returnValue = -3;
	}
	}
	else {
	returnValue = (returnValue == -2 ? -2 : -1); // WJF 12/17/15 Win-7 We don't want to overwrite a -2 from TWAIN
	}
	// WJF 9/21/15 #43940 End changes
	}
	// Removed
	/*if (debug) returnValue = TWAIN_SelectImageSource(windowHandles.fourDhWnd);

	memset(&NewSourceId, 0, sizeof NewSourceId);

	state = TWAIN_State();

	if (state >= TWAIN_SM_OPEN || TWAIN_OpenSourceManager(windowHandles.fourDhWnd)) {
	OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETFIRST, &NewSourceId);
	if (!(debug)){
	returnValue = OK;
	}
	while (OK){
	PA_ResizeArray(&atSources, index);
	PA_SetTextInArray(atSources, index, NewSourceId.ProductName, strlen(NewSourceId.ProductName));
	++index;
	OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETNEXT, &NewSourceId);
	}
	}
	*/
	// WJF 9/11/15 #43727 End changes

	PA_SetVariableParameter(params, 1, atSources, 0);
	PA_ReturnLong(params, returnValue);
}

void TWAIN_SetSource(PA_PluginParameters params)
{
	LONG			returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG_PTR			source_len;
	char			sourceName[255];

	source_len = PA_GetTextParameter(params, 1, sourceName);
	sourceName[source_len] = '\0';

	returnValue = 1;

	// WJF 9/11/15 #43727 Begin changes
	if (twainSource){ // If we've already set a source, clear it
		free(twainSource);

		twainSource = NULL;
	}

	twainSource = malloc(source_len + 1); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices

	// WJF 9/29/15 Added a check to see if it was actually allocated and a new error code
	if (twainSource){
		strcpy_s(twainSource, source_len + 1, sourceName);
	}
	else {
		returnValue = 0;
	}

	// Removed
	/*
	memset(&NewSourceId, 0, sizeof NewSourceId);

	// If the source is already open, close it to reset the connection.
	state = TWAIN_State();
	if (state >= TWAIN_SOURCE_ENABLED){
	OK = TWAIN_EndXfer();
	OK = TWAIN_AbortAllPendingXfers();
	OK = TWAIN_CloseSource();
	}

	if (state >= TWAIN_SM_OPEN || TWAIN_OpenSourceManager(windowHandles.fourDhWnd)) {
	OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETFIRST, &NewSourceId);
	while (OK){
	if (strcmp(sourceName, NewSourceId.ProductName) == 0){
	OK = 0;
	returnValue = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_OPENDS, &NewSourceId);
	}
	else{
	OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETNEXT, &NewSourceId);
	}
	}
	} */
	// WJF 9/1/15 #43727 End changes

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	OrchTwain_Get(LPCSTR filePath, BOOL Get64)
//
//  PURPOSE:	Launches the external OrchTwain DLL and waits for the operation to finish
//
//  COMMENTS:
//
//	DATE:		WJF 9/10/15 #43727
long __stdcall OrchTwain_Get(const char * filePath, BOOL Get64, BOOL ShowUI, BOOL IsWIA, BOOL GetMultiple){
	char lpParameters[MAX_PATH_PLUS] = "";
	char pluginPath[MAX_PATH] = "";
	char *pos = NULL;
	long returnValue = 1;
	char sourceName[256] = "";
	SHELLEXECUTEINFO utilities;
	DWORD dwExitCode = 0;
	BOOL bSuccess = FALSE;

	strcpy_s(pluginPath, MAX_PATH, pathName);

	pos = strrchr(pluginPath, '\\');

	strcpy_s(pos, MAX_PATH, "\0");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	pos = strrchr(pluginPath, '\\');

	strcpy_s(pos, MAX_PATH, "\\\0");  // ZRW 3/22/17 WIN-39 strcpy -> strcpy_s

	if (Get64){
		strcpy_s(pos, MAX_PATH, "\\Windows64\\Orchard_Utilities.exe");
	}
	else {
		strcpy_s(pos, MAX_PATH, "\\Windows\\Orchard_Utilities.exe");
	}

	// WJF 9/21/15 #43940
	if (twainSource){
		pos = NULL;
		pos = strstr(twainSource, "-TWAIN");

		if (!pos){
			pos = strstr(twainSource, "-WIA");

			if (pos){
				IsWIA = TRUE;
			}
		}

		// WJF 9/24/15 #43940
		strcpy_s(sourceName, sizeof(sourceName), twainSource);  // ZRW 3/22/17 WIN-39 256 -> sizeof(sourceName)
		pos = NULL;
		pos = strrchr(sourceName, '-');

		if (pos){
			strcpy_s(pos, MAX_PATH, "\0");
		}
	}

	if (IsWIA){ // WJF 9/21/15 #43940
		strcpy_s(lpParameters, sizeof(lpParameters), "-wa ");  // ZRW 3/22/17 WIN-39 MAX_PATH_PLUS -> sizeof(lpParamters)
	}
	else {
		strcpy_s(lpParameters, sizeof(lpParameters), "-A ");  // ZRW 3/22/17 WIN-39 MAX_PATH_PLUS -> sizeof(lpParamters)
	}

	  // ZRW 4/5/17 WIN-39 MAX_PATH_PLUS -> sizeof(lpParamters)
	strcat_s(lpParameters, sizeof(lpParameters), filePath);

	if (GetMultiple){
		strcat_s(lpParameters, sizeof(lpParameters), " 1");
	}
	else {
		strcat_s(lpParameters, sizeof(lpParameters), " 0");
	}

	if (ShowUI){
		strcat_s(lpParameters, sizeof(lpParameters), " 1 ");
	}
	else {
		strcat_s(lpParameters, sizeof(lpParameters), " 0 ");
	}

	if (twainSource){
		if (strcmp(sourceName, "") != 0){
			strcat_s(lpParameters, sizeof(lpParameters), "\"");
			strcat_s(lpParameters, sizeof(lpParameters), sourceName);
			strcat_s(lpParameters, sizeof(lpParameters), "\"");
		}
	}

	// WJF 3/29/16 Win-11
	utilities.cbSize = sizeof(SHELLEXECUTEINFO);
	utilities.fMask = SEE_MASK_NOCLOSEPROCESS;
	utilities.hwnd = windowHandles.fourDhWnd;
	utilities.lpVerb = NULL;
	utilities.lpFile = pluginPath;
	utilities.lpParameters = lpParameters;
	utilities.lpDirectory = NULL;
	utilities.nShow = SW_SHOW;
	utilities.hInstApp = NULL;
	ShellExecuteEx(&utilities);

	// WJF 3/29/16 Win-11 Wait until the process closes
	do {
		Sleep(100);
		bSuccess = GetExitCodeProcess(utilities.hProcess, &dwExitCode);
	} while ((dwExitCode == STILL_ACTIVE) && (bSuccess));

	returnValue = 0;

	// WJF 3/29/16 Win-11 Removed
	// utilitiesLock(); // WJF 9/21/15 #43601 Moved to common method
	//
	//ShellExecute(windowHandles.fourDhWnd, "", pluginPath, lpParameters, NULL, SW_SHOW);
	//
	//if (GetLastError() == ERROR_SUCCESS){
	//	utilitiesYield(NULL, FALSE, TRUE); // WJF 9/21/15 #43601 Moved to common method // WJF 12/17/15 Win-7 utilitiesSleep() -> utilitiesYield()
	//
	//	returnValue = 0;
	//}

	return returnValue;
}

// WJF 3/29/16 Win-11 Removed
/*
//  FUNCTION:	utilitiesLock()
//
//  PURPOSE:	Creates the semaphore for the orchard_utilties application
//
//  COMMENTS:
//
//	DATE:		WJF 9/21/15 #43601
void utilitiesLock(){
char lockPath[MAX_PATH] = "";
FILE *fp = NULL;

GetTempPath(MAX_PATH, lockPath);

strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");

fp = fopen(lockPath, "w");

if (fp){
fprintf(fp, "Locked\n");

fclose(fp);

fp = NULL;
}
}
*/

// WJF 12/17/15 Win-7 Removed
/*
//  FUNCTION:	utilitiesSleep()
//
//  PURPOSE:	Waits until the utilities application semaphore is cleared
//
//  COMMENTS:	Use this when NOT in the main Win32API thread
//
//	DATE:		WJF 9/21/15 #43601
void utilitiesSleep(const char * filePath){
char lockPath[MAX_PATH] = "";

GetTempPath(MAX_PATH, lockPath);

strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");

SetLastError(ERROR_SUCCESS);

if (filePath){
while ((GetFileAttributes(filePath) == INVALID_FILE_ATTRIBUTES) || (GetLastError() == ERROR_FILE_NOT_FOUND)){ // When this file exists, the operation is completed
Sleep(100);
}
}
else {
while ((GetFileAttributes(lockPath) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){ // When this file no longer exists, the operation is completed
Sleep(100);
}
}
}*/

// WJF 3/29/16 Win-11 Removed
/*
//  FUNCTION:	utilitiesYield()
//
//  PURPOSE:	Waits until the utilities application semaphore is cleared
//
//  COMMENTS:	Use this when in the main Win32API thread
//
//	DATE:		WJF 9/21/15 #43601
DWORD utilitiesYield(const char * filePath, BOOL bTimer, BOOL bSleep){
char		lockPath[MAX_PATH] = "";
time_t		tTime = 0;
time_t		tEndTime = 0;
DWORD		dwReturn = 0;
LONG		lProcessCode = 0;

if (filePath == NULL){
GetTempPath(MAX_PATH, lockPath);

strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");
}
else { // WJF 12/17/15 Win-7
strcpy_s(lockPath, MAX_PATH, filePath);
}

SetLastError(ERROR_SUCCESS);

if (bTimer){ // WJF 12/17/15 Win-7
tTime = time(NULL);
tEndTime = tTime + 30; // Only wait 30 seconds if we're not interacting with the user
while ((GetFileAttributes(lockPath) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){ // When this file no longer exists, the operation is completed
if (bSleep){ // WJF 12/17/15 Win-7
Sleep(100);
}
else {
PA_YieldAbsolute();
}
tTime = time(NULL);
if (tTime >= tEndTime){
DeleteFile(lockPath);
lProcessCode = killProcessByName("Orchard_Utilities.exe", 0, FALSE);
dwReturn = -1;
break;
}
}
}
else {
while ((GetFileAttributes(lockPath) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){ // When this file no longer exists, the operation is completed
if (bSleep){ // WJF 12/17/15 Win-7
Sleep(100);
}
else {
PA_YieldAbsolute();
}
}
}

return dwReturn;
}
*/

// REB 2/26/13 #35165 Intermediary method we can call as a new thread.
unsigned __stdcall TWAIN_GetImage(void *arg)
{
	TWAIN_CAPTURE*	TWAINCapture;
	char			iterator[16] = "";
	char			*pos = NULL;
	BOOL			bContinue = TRUE;
	char			filePath[MAX_PATH] = "";
	long			i = 0;

	TWAINCapture = (TWAIN_CAPTURE*)arg;
	// WJF 9/10/15 #43727 Removed
	//TWAIN_UnloadSourceManager();  // REB 2/26/13 #35165 We have to reset our source before trying to acquire an image.
	//TWAINCapture->DIBHandle = TWAIN_AcquireNative(NULL, TWAIN_ANYTYPE, &returnValue);

	TWAINCapture->returnValue = OrchTwain_Get(TWAINCapture->filePath, TWAINCapture->get64, TWAINCapture->showUI, TWAINCapture->wiaMode, TWAINCapture->getMultiple); // WJF 9/10/15 #43727 // WJF 9/21/15 #43940

	if (TWAINCapture->getMultiple){
		while (bContinue){
			SetLastError(ERROR_SUCCESS);

			i++;

			strcpy_s(filePath, sizeof(filePath), TWAINCapture->filePath);  // ZRW 3/23/17 WIN-39 MAX_PATH -> sizeof(filePath)

			pos = strrchr(filePath, '.');

			_itoa(i, iterator, 10);

			strcpy_s(pos, MAX_PATH, iterator);

			strcat_s(filePath, sizeof(filePath), ".bmp");  // ZRW 4/5/17 WIN-39 MAX_PATH -> sizeof(filePath)

			if ((GetFileAttributes(filePath) == INVALID_FILE_ATTRIBUTES) || (GetLastError() == ERROR_FILE_NOT_FOUND)){
				bContinue = FALSE;
				i--;
			}
		}

		TWAINCapture->numPictures = i;
	}

	TWAINCapture->done = TRUE;

	return 0;
}

void TWAIN_AcquireImage(PA_PluginParameters params)
{
	LONG			returnValue = 0, showDialog = 0; // WJF 6/24/16 Win-21 Initialize to 0 // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	UINT			threadID = 0; // WJF 6/24/16 Win-21 LONG_PTR -> UINT and initialize to 0
	char*			charPos = NULL; // WJF 6/24/16 Win-21 Initialize to NULL
	char			fileName[255] = "";
	char			fileName2[255] = "";
	char			 *pch = NULL;
	char			command[255] = "";
	// HANDLE			DIBHandle = NULL; // WJF 9/10/15 #43727 No longer needed
	HANDLE			CaptureThread;
	PA_Unistring	Unistring;
	TWAIN_CAPTURE	TWAINCapture; // REB 2/26/13 #35165
	char			*BLOB = NULL; // AMS 7/3/14 #39391
	LONG_PTR		len = 0; // AMS 7/3/14 #39391
	char			cmdName[256] = ""; // WJF 6/29/15 #42792
	char			cName[256] = ""; // WJF 6/29/15 #42792
	char			pathName[MAX_PATH] = ""; // WJF 9/15/15 #43727 Initialize this value
	char			iterator[16] = ""; // WJF 9/21/15 #43940
	BOOL			x64 = FALSE; // WJF 9/21/15 #43727
	BOOL			wiaMode = FALSE; // WJF 9/21/15 #43940
	BOOL			getMultiple = FALSE; // WJF 9/21/15 #43940
	char			fileName3[255] = ""; // WJF 9/21/15 #43940
	char			cName2[256] = ""; // WJF 9/21/15 #43940
	char			command2[256] = ""; // WJF 9/21/15 #43940

	showDialog = PA_GetLongParameter(params, 1);

	// AMS 7/3/14 #39391 Get the blob parameter // WJF 6/29/15 #42792 Changed BLOB -> Text
	BLOB = NULL;
	len = PA_GetTextParameter(params, 2, NULL);

	if (len > 0) { // WJF 6/29/15 #42792 Don't allocate unless a variable was passed
		BLOB = malloc(len + 1); // WJF 6/29/15 #42792 Added +1
		len = PA_GetTextParameter(params, 2, BLOB);
	}

	x64 = PA_GetLongParameter(params, 3); // WJF 9/21/15 #43727

	getMultiple = PA_GetLongParameter(params, 4); // WJF 9/21/15 #43940

	wiaMode = PA_GetLongParameter(params, 5); // WJF 9/21/15 #43940

	//Unistring = PA_GetApplicationFullPath(); // REB 4/20/11 #27322
	//pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322 #27490 Fixed method call.
	//	PA_DisposeUnistring(&Unistring); // WJF 6/29/15 #42792
	GetTempPath(MAX_PATH, pathName);
	charPos = strrchr(pathName, '\\');
	strncpy_s(fileName, sizeof(fileName), pathName, (charPos - pathName + 1));  // ZRW 4/7/17 WIN-39 strncpy -> strncpy_s
	strncat(fileName, "TWNIMG.bmp", strlen("TWNIMG.bmp"));  // ZRW 4/10/17 WIN-39 "strncat_s(fileName, 255, "TWNIMG.bmp", strlen("TWNIMG.bmp"))" -> "strncat(fileName, "TWNIMG.bmp", strlen("TWNIMG.bmp"))"; rather than hardcoding the size allowed we'll used the defined macro to use the size of fileName instead
	
	// Allow the image dialog to display if so desired.
	// WJF 9/10/15 #43727 Changed to use a new variable instead of the EZTWAIN function
	if (showDialog){
		TWAINCapture.showUI = TRUE;
	}
	else{
		TWAINCapture.showUI = FALSE;
	}

	// REB 2/26/13 #35165 Load our variables into the structure we can pass to the new thread
	TWAINCapture.returnValue = 0;
	// TWAINCapture.DIBHandle = DIBHandle; // WJF 9/10/15 #43727 Removed
	TWAINCapture.done = FALSE;

	TWAINCapture.get64 = x64; // WJF 9/10/15 #43727

	TWAINCapture.getMultiple = getMultiple; // WJF 9/21/15 #43940

	TWAINCapture.wiaMode = wiaMode; // WJF 9/21/15 #43940

	TWAINCapture.numPictures = 1; // WJF 9/21/15 #43940 Default

	TWAINCapture.filePath = malloc(MAX_PATH_PLUS); // WJF 9/15/15 #43727 // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices

	strcpy_s(TWAINCapture.filePath, MAX_PATH_PLUS, ""); // WJF 9/15/15 #43727

	strncpy_s(TWAINCapture.filePath, MAX_PATH_PLUS, fileName, strlen(fileName)); // WJF 9/10/15 #43727

	//DIBHandle = TWAIN_AcquireNative( windowHandles.fourDhWnd, TWAIN_ANYTYPE, &returnValue);
	// REB 2/26/13 #35165 Start a new thread to handle the image acquisition so that we can yield time
	// back to 4D to prevent an application timeout.
	CaptureThread = (HANDLE)_beginthreadex(NULL, 0, TWAIN_GetImage, &TWAINCapture, 0, &threadID);

	// REB 2/26/13 #35165 4D says to call this at least three times when starting an external process.
	// That's not exactly what we're doing but I'll err on the side of caution.
	PA_YieldAbsolute();
	PA_YieldAbsolute();
	PA_YieldAbsolute();

	// Yield time back to 4D until the capture is finished.
	while (TWAINCapture.done == FALSE){
		PA_YieldAbsolute();
	}

	// REB 2/26/13 #35165 Now get the values from the structure
	//DIBHandle = TWAINCapture.DIBHandle; // WJF 9/10/15 #43727
	returnValue = TWAINCapture.returnValue;

	// Updated so that return code is 1 for success, 0 for cancel and negative for error codes.
	// Suppress eztwain error dialogs
	// WJF 9/10/15 #43727 We are now checking to see if the file exists rather than for a valid DIB handle
	strcpy_s(fileName3, sizeof(fileName3), fileName);  // ZRW 3/23/17 WIN-39 255 -> sizeof(fileName3)
	charPos = strrchr(fileName3, '.');
	strcpy_s(charPos, 255, "1");
	strcat_s(fileName3, sizeof(fileName3), ".bmp");  // ZRW 4/5/17 WIN-39 255 -> sizeof(fileName3)
	if ((GetFileAttributes(fileName3) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){
		// returnValue = TWAIN_WriteNativeToFilename(DIBHandle, fileName2); // WJF 9/10/15 #43727 Removed

		// TWAIN_WriteNativetoFilename returns 0 on success
		if (returnValue == 0) {
			returnValue = 1;

			strcpy_s(fileName3, sizeof(fileName3), fileName); // WJF 9/21/15 #43940 Backup the file name  // ZRW 3/23/17 WIN-39 255 -> sizeof(fileName3)

			if (len == 0) // AMS 7/3/14 #39391 Use PA_ExecuteMethod if no blob was passed in.
			{
				// AMS 7/10/14 #39391 Rewrote this portion of the method to use PA_GetCommandName. This allows users to not have to pass in an extra blob parameter.

				PA_GetCommandName(525, (PA_Unichar *)cmdName); // WJF 6/24/16 Win-21 Casting to PA_Unichar *

				int j = 0;

				// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..).
				// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
				for (int i = 0; i < sizeof(cmdName); i++) // WJF 6/29/15 #43134 Changed <= to <
				{
					if (cmdName[i] != '\0')
					{
						cName[j] = cmdName[i];
						j++;
					}
				}

				cName[(strlen(cName))] = '\0';

				for (int i = 0; i < TWAINCapture.numPictures; i++){// WJF 9/21/15 #43940
					pch = fileName;

					// WJF 9/21/15 #43940
					strcpy_s(fileName, sizeof(fileName), fileName3);  // ZRW 3/23/17 WIN-39 255 -> sizeof(fileName)
					charPos = strrchr(fileName, '.');
					_itoa(i + 1, iterator, 10);
					strcpy_s(charPos, 255, iterator);
					strcat_s(fileName, sizeof(fileName), ".bmp");  // ZRW 3/23/17 WIN-39 255 -> sizeof(fileName)
					strcpy_s(fileName2, sizeof(fileName2), "");  // ZRW 3/23/17 WIN-39 255 -> fileName2

					charPos = strchr(fileName, '\\');
					while (charPos != NULL){
						strncat(fileName2, pch, (charPos - pch));
						pch = charPos;
						charPos = strchr((charPos + 1), '\\');
						if (charPos != NULL){
							strcat_s(fileName2, sizeof(fileName2), "\\");  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
						}
						else{
							// add the remainder of fileName to fileName2.
							strcat_s(fileName2, sizeof(fileName2), "\\");  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
							strcat_s(fileName2, sizeof(fileName2), pch);  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
						}
					}

					if (getMultiple){ // WJF 9/22/15 #43940
						//strcpy(command, "DOCUMENT TO BLOB(\"");
						strncpy_s(command, sizeof(command), cName, sizeof(command));  // ZRW 4/7/17 WIN-39 strncpy -> strncpy_s
						
						  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
						strcat_s(command, sizeof(command), "(\"");
						strcat_s(command, sizeof(command), fileName2);
						strcat_s(command, sizeof(command), "\";xTempTWAINBlob)");

						Unistring = CStringToUnistring(command);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);

						PA_GetCommandName(532, (PA_Unichar *)cmdName); // VARIABLE TO BLOB // WJF 6/24/16 Win-21 Casting to PA_Unichar *

						j = 0;

						// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..).
						// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
						for (int k = 0; k < sizeof(cmdName); k++)
						{
							if (cmdName[k] != '\0')
							{
								cName2[j] = cmdName[k];
								j++;
							}
						}

						strcpy_s(command2, sizeof(command2), cName2);  // ZRW 3/23/17 WIN-39 255 -> sizeof(command2)
						strcat_s(command2, sizeof(command2), "(xTempTWAINBlob;xTWAINBlob;*)");  // ZRW 4/5/17 WIN-39 255 -> sizeof(command2)

						Unistring = CStringToUnistring(command2); // WJF 6/21/16 Win-21 Removed unneccessary addressof operator
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);
					}
					else {
						//strcpy(command, "DOCUMENT TO BLOB(\"");
						strncpy_s(command, sizeof(command), cName, sizeof(command));  // ZRW 4/7/17 WIN-39 strncpy -> strncpy_s

						  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
 						strcat_s(command, sizeof(command), "(\"");
						strcat_s(command, sizeof(command), fileName2);
						strcat_s(command, sizeof(command), "\";xTWAINBLOB)");

						// REB 4/20/11 #27322 Conver the C string to a Unistring
						Unistring = CStringToUnistring(command); // WJF 6/21/16 Win-21 Removed unneccessary addressof operator
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring); // WJF 6/25/15 #42792
						//PA_ExecuteMethod(command, strlen(command));
					}

					DeleteFile(fileName); // WJF 9/21/15 #43940 Moved to loop
				}
			}
			else // Leaving this in place just in case a user does not want to use our xTWAINBlob variable
			{ // WJF 6/29/15 #42792 Changed this to be like the above section because of a memory leak with varArray[0]. Now users will have to pass the name of the blob as text.
				PA_GetCommandName(525, (PA_Unichar *)cmdName); // WJF 6/24/16 Win-21 Casting to PA_Unichar *

				int j = 0;

				// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..).
				// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
				for (int i = 0; i < sizeof(cmdName); i++)
				{
					if (cmdName[i] != '\0')
					{
						cName[j] = cmdName[i];
						j++;
					}
				}

				cName[(strlen(cName))] = '\0';

				// WJF 9/21/15 #43940
				for (int i = 0; i < TWAINCapture.numPictures; i++){
					pch = fileName;

					strcpy_s(fileName, sizeof(fileName), fileName3);  // ZRW 3/23/17 WIN-39 255 -> sizeof(fileName)
					charPos = strrchr(fileName, '.');
					_itoa(i + 1, iterator, 10);
					strcpy_s(charPos, 255, iterator);
					strcat_s(fileName, sizeof(fileName), ".bmp");  // ZRW 4/5/17 WIN-39 255 -> sizeof(fileName)
					strcpy_s(fileName2, sizeof(fileName2), "");  // ZRW 3/23/17 WIN-39 255 -> sizeof(fileName2)

					charPos = strchr(fileName, '\\');
					while (charPos != NULL){
						strncat(fileName2, pch, (charPos - pch));
						pch = charPos;
						charPos = strchr((charPos + 1), '\\');
						if (charPos != NULL){
							strcat_s(fileName2, sizeof(fileName2), "\\");  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
						}
						else{
							// add the remainder of fileName to fileName2.
							strcat_s(fileName2, sizeof(fileName2), "\\");  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
							strcat_s(fileName2, sizeof(fileName2), pch);  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
						}
					}

					if (getMultiple){
						strncpy_s(command, sizeof(command), cName, sizeof(command));  // ZRW 4/7/17 WIN-39 strncpy -> strncpy_s

						  // ZRW 4/5/17 WIN-39 strcat -> strcat_s
						strcat_s(command, sizeof(command), "(\"");
						strcat_s(command, sizeof(command), fileName2);
						strcat_s(command, sizeof(command), "\";xTempTWAINBlob)");

						Unistring = CStringToUnistring(command); // WJF 6/24/16 Win-21 Removed unneccessary addressof operator
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);

						PA_GetCommandName(532, (PA_Unichar *)cmdName); // VARIABLE TO BLOB // WJF 6/24/16 Win-21 Casting to PA_Unichar *

						j = 0;

						// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..).
						// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
						for (int k = 0; k < sizeof(cmdName); k++)
						{
							if (cmdName[k] != '\0')
							{
								cName2[j] = cmdName[k];
								j++;
							}
						}
						// ZRW 3/23/17 WIN-39 255 -> sizeof(command2)
						strcpy_s(command2, sizeof(command2), cName2);  
						strcat_s(command2, sizeof(command2), "(xTempTWAINBlob;");
						strcat_s(command2, sizeof(command2), BLOB);
						strcat_s(command2, sizeof(command2), ";*)");

						Unistring = CStringToUnistring(command2); // WJF 6/21/16 Win-21 Removed unneccessary addressof operator
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);
					}
					else {
						// ZRW 3/23/17 WIN-39 255 -> sizeof(command)
						strcpy_s(command, sizeof(command), cName);  
						strcat_s(command, sizeof(command), "(\"");
						strcat_s(command, sizeof(command), fileName2);
						strcat_s(command, sizeof(command), "\";");
						strcat_s(command, sizeof(command), BLOB);
						strcat_s(command, sizeof(command), ")");

						Unistring = CStringToUnistring(command); // WJF 6/21/16 Win-21 Removed unneccessary addressof operator
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);
					}

					DeleteFile(fileName);
				}

				// WJF 9/22/15 #43940 Removed
				/*strncpy(command, cName, sizeof(command));
				strcat(command, "(\"");
				strcat(command, fileName2);
				strcat(command, "\";");
				strcat(command, BLOB);
				strcat(command, ")");

				Unistring = CStringToUnistring(&command);
				PA_ExecuteMethod(&Unistring);
				PA_DisposeUnistring(&Unistring);*/

				/*PA_Unistring _path = CStringToUnistring(fileName);
				PA_Variable varArray[2];

				varArray[0] = PA_CreateVariable(eVK_Unistring);
				PA_SetStringVariable(&varArray[0], &_path);

				varArray[1] = PA_CreateVariable(eVK_Blob);
				varArray[1].fFiller = 0;

				PA_ExecuteCommandByID(525, varArray, 2);

				char *twainBlob;
				long blobSize;

				blobSize = PA_GetBlobVariable(varArray[1], NULL);
				twainBlob = malloc(blobSize);
				blobSize = PA_GetBlobVariable(varArray[1], twainBlob);

				PA_SetBlobParameter(params, 2, twainBlob, blobSize);

				PA_DisposeUnistring(&Unistring); // WJF 6/25/15 #42792
				free(twainBlob); */
			}
		}
	}

	if (len > 0) // WJF 6/29/15 #42792 Only free if allocated
	{
		free(BLOB); // AMS 7/10/14 #39391
	}

	//free(pathName); // WJF 6/25/15 #42792

	if (TWAINCapture.filePath){
		free(TWAINCapture.filePath);
		TWAINCapture.filePath = NULL;
	}

	PA_ReturnLong(params, returnValue);

	// TWAIN_FreeNative(DIBHandle); // WJF 9/10/15 #43727 No longer needed
}

/***************************************************************
Determine if the frontmost window belongs to our instance
of 4D.

REB 4/6/09 #19472
****************************************************************/
void sys_IsAppFrontmost(PA_PluginParameters params)
{
	HWND			hwndFront;
	HWND			MDIhWnd, ChildhWnd, NexthWnd;
	BOOL			lFound = 0; // WJF 6/30/16 Win-21 LONG_PTR -> BOOL

	// First get the frontmost window.
	hwndFront = GetForegroundWindow();

	MDIhWnd = windowHandles.MDIhWnd; // Assigning to a variable to use later.

	// Now see if the frontmost window is one of ours.

	if (windowHandles.fourDhWnd == hwndFront){
		lFound = 1;
	}
	else if (MDIhWnd == hwndFront){
		lFound = 1;
	}
	else{
		// It's not one of the main windows, check all of our child windows

		NexthWnd = GetWindow(MDIhWnd, GW_CHILD);
		do {
			ChildhWnd = NexthWnd;
			if (IsChild(MDIhWnd, ChildhWnd)) {
				if (hwndFront == ChildhWnd){
					lFound = 1;
					break;
				}
				NexthWnd = GetNextWindow(ChildhWnd, GW_HWNDNEXT);
			}
			else {
				break;
			}
		} while (NexthWnd != NULL);
	};

	PA_ReturnLong(params, lFound);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MessageBox
//
// PURPOSE:		Exposes the MessageBox Win32 API function
//
// DATE:			DJD 2008-09-12
//
void gui_MessageBox(PA_PluginParameters params, BOOL isEx)
{
	DWORD ownerHandleIndex; // WJF 6/30/16 Win-21 LONG_PTR -> DWORD
	HWND ownerHandle;
	LONG_PTR messageText_len;
	char messageText[32000];
	LONG_PTR dialogTitle_len;
	char dialogTitle[32000];
	LONG_PTR dialogType;
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG

	ownerHandleIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal handle array
	messageText_len = PA_GetTextParameter(params, 2, messageText);
	messageText[messageText_len] = '\0';
	dialogTitle_len = PA_GetTextParameter(params, 3, dialogTitle);
	dialogTitle[dialogTitle_len] = '\0';
	dialogType = PA_GetLongParameter(params, 4);

	if (isEx){
		ownerHandle = handleArray_retrieve(ownerHandleIndex); // WJF 9/16/15 #43731
	}
	else {
		ownerHandle = (HWND)ownerHandleIndex;
	}

	returnValue = MessageBoxEx(ownerHandle, (LPCSTR)messageText, (LPCSTR)dialogTitle, (UINT)dialogType, 0); // WJF 9/1/15 #43731 Removed typecasting on the handle

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_SetMDIOpaque
//
// PURPOSE:		Make the main MDI window background opaque.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_SetMDIOpaque(PA_PluginParameters params)
{
	LONG_PTR returnValue;

	returnValue = SetLayeredWindowAttributes(windowHandles.fourDhWnd, GetSysColor(COLOR_APPWORKSPACE), 255, LWA_ALPHA);
	// REB 3/11/10 #23109 Set the window style back to the orignal value.
	if (windowStyle != 0){
		returnValue = SetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE, windowStyle);
	};

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, (LONG)returnValue); // WJF 6/30/16 Win-21 Cast to LONG
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_SetMDITransparent
//
// PURPOSE:		Make the main MDI window background transparent.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_SetMDITransparent(PA_PluginParameters params)
{
	LONG_PTR returnValue;
	// REB 3/11/10 #23109 Get the original window style before we mess around with it.
	windowStyle = GetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE);

	returnValue = SetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE, GetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE) | WS_EX_LAYERED);
	returnValue = SetLayeredWindowAttributes(windowHandles.fourDhWnd, GetSysColor(COLOR_APPWORKSPACE), 0, LWA_COLORKEY);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, (LONG)returnValue); // WJF 6/30/16 Win-21 LONG_PTR -> LONG
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_HideTaskBar
//
// PURPOSE:		Hide the Windows taskbar.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_HideTaskBar(PA_PluginParameters params)
{
	HWND HWND_tray;
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG

	HWND_tray = FindWindow("Shell_TrayWnd", NULL);
	returnValue = ShowWindow(HWND_tray, SW_HIDE);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_ShowTaskBar
//
// PURPOSE:		Show the Windows taskbar.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_ShowTaskBar(PA_PluginParameters params)
{
	HWND HWND_tray;
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG

	HWND_tray = FindWindow("Shell_TrayWnd", NULL);
	returnValue = ShowWindow(HWND_tray, SW_SHOW);

	// Reverse the return values so that a return value of 0 means there was an error
	// making the taskbar visible and non-zero if there were no problems.
	if (returnValue == 0){
		returnValue = 1;
	}
	else{
		returnValue = 0;
	};

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_HideTitleBar
//
// PURPOSE:		Hide the title bar of the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_HideTitleBar(PA_PluginParameters params)
{
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG

	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) | WS_POPUP);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) &~WS_CAPTION);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) &~WS_SYSMENU);
	returnValue = SetWindowPos(windowHandles.fourDhWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_ShowTitleBar
//
// PURPOSE:		Show the title bar of the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_ShowTitleBar(PA_PluginParameters params)
{
	BOOL returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> BOOL

	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) &~WS_POPUP);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) | WS_CAPTION);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) | WS_SYSMENU);
	returnValue = SetWindowPos(windowHandles.fourDhWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MaximizeMDI
//
// PURPOSE:		Maximize the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_MaximizeMDI(PA_PluginParameters params)
{
	BOOL returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> BOOL
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_SHOWMAXIMIZED;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MinimizeMDI
//
// PURPOSE:		Minimize the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_MinimizeMDI(PA_PluginParameters params)
{
	BOOL returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> BOOL
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_SHOWMINIMIZED;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_RestoreMDI
//
// PURPOSE:		Restore the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_RestoreMDI(PA_PluginParameters params)
{
	BOOL returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> BOOL
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_RESTORE;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_DisableTaskManager
//
// PURPOSE:		Restore the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void sys_DisableTaskManager(PA_PluginParameters params)
{
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HKEY hk;
	DWORD val = 1;

	if (!hookHandles.keyboardLLHook)
		hookHandles.keyboardLLHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)keyboardLLHook, (HINSTANCE)GetModuleHandle(0), 0);

	if (RegOpenKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk) != ERROR_SUCCESS)
		RegCreateKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk);

	returnValue = RegSetValueEx(hk, VAL_DisableTaskMgr, 0, REG_DWORD, (BYTE*)&val, sizeof(val));

	if (returnValue == ERROR_SUCCESS){
		returnValue = 1;
	}
	else{
		returnValue = 0;
	};

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_EnableTaskManager
//
// PURPOSE:		Enable task manager.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void sys_EnableTaskManager(PA_PluginParameters params)
{
	LONG returnValue; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	HKEY hk;

	if (hookHandles.keyboardLLHook)
	{
		UnhookWindowsHookEx(hookHandles.keyboardLLHook);
		hookHandles.keyboardLLHook = NULL;
	}

	if (RegOpenKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk) != ERROR_SUCCESS)
		RegCreateKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk);

	returnValue = RegDeleteValue(hk, VAL_DisableTaskMgr);

	if (returnValue == ERROR_SUCCESS){
		returnValue = 1;
	}
	else{
		returnValue = 0;
	};

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_SetRegKey( PA_PluginParameters params, LONG_PTR selector )
//
//  PURPOSE:  Set a registry key value.
//
//	DATE:	  REB 11/17/10 #25402
//
void sys_SetRegKey(PA_PluginParameters params, LONG_PTR selector)
{
	LONG returnValue, regKey, retErr, arraySize, value, expandDataSize; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	DWORD dataSize = 0; // WJF 6/24/16 Win-21 LONG_PTR -> DWORD
	DWORD keyState = 0; // WJF 6/24/16 Win-21 LONG_PTR -> DWORD and initialized to 0;
	DWORD dwVal = 0;
	__int64 val64 = 0;
	LONG i; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	DWORD len; // WJF 6/30/16 Win-21 LONG_PTR -> DWORD
	char regSub[MAXBUF];
	char regName[MAXBUF];
	PBYTE newDataBuffer = NULL; // WJF 6/24/16 Win-21 char -> PBYTE
	LPSTR element = NULL;
	unsigned char * pos = NULL; // WJF 6/24/16 Win-21 char -> unsigned char
	HKEY hRootKey;
	HKEY hOpenKey;
	DWORD dwDataType;
	PA_Variable	paReturnArray;

	returnValue = regKey = retErr = arraySize = expandDataSize = 0;
	hRootKey = hOpenKey = 0;
	newDataBuffer = NULL;
	memset(regSub, 0, MAXBUF);
	memset(regName, 0, MAXBUF);

	// Get the function parameters.
	regKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, regSub);
	PA_GetTextParameter(params, 3, regName);

	// Convert the 4d registry constant into a Windows registry key.
	hRootKey = getRootKey(regKey);

	// Open the registry key.
	retErr = RegOpenKeyEx(hRootKey, regSub, 0, KEY_ALL_ACCESS, &hOpenKey);

	returnValue = -99;

	// If the key does not exist create it now.
	if (retErr == ERROR_FILE_NOT_FOUND){
		returnValue = -98;
		//retErr = RegCreateKeyEx(hRootKey, regSub, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hOpenKey, &keyState);
		retErr = RegCreateKeyEx(hRootKey, regSub, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hOpenKey, &keyState);
	}

	if (retErr == ERROR_SUCCESS){
		returnValue = -97;

		// Get the value type from the registry.
		retErr = RegQueryValueEx(hOpenKey, regName, NULL, &dwDataType, NULL, &dataSize);

		// If the value was not found we'll need to determine the type based on the value passed in.
		if (retErr == ERROR_FILE_NOT_FOUND){
			switch (selector){
			case 90:
				dwDataType = REG_SZ;
				retErr = ERROR_SUCCESS;
				break;

			case 91:
				dwDataType = REG_DWORD;
				retErr = ERROR_SUCCESS;
				break;

			case 92:
				dwDataType = REG_MULTI_SZ;
				retErr = ERROR_SUCCESS;
				break;

			case 93:
				dwDataType = REG_BINARY;
				retErr = ERROR_SUCCESS;
				break;

			case 104:
				dwDataType = REG_QWORD;
				retErr = ERROR_SUCCESS;
				break;
			}
		}

		if (retErr == ERROR_SUCCESS){
			switch (dwDataType){
			case REG_BINARY:
				len = PA_GetBlobParameter(params, 4, NULL);
				newDataBuffer = malloc(len);
				len = PA_GetBlobParameter(params, 4, newDataBuffer);

				retErr = RegSetValueEx(hOpenKey, regName, (DWORD)NULL, dwDataType, newDataBuffer, len); // WJF 6/21/16 Win-21 Casting NULL to DWORD

				free(newDataBuffer);

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;

			case REG_DWORD:
			case REG_DWORD_BIG_ENDIAN:
				value = PA_GetLongParameter(params, 4);
				dwVal = value; // WJF 8/31/15 #43731 Truncate to 32-bit DWORD
				retErr = RegSetValueEx(hOpenKey, regName, (DWORD)NULL, dwDataType, (PBYTE)&dwVal, sizeof(dwVal)); // WJF 6/21/16 Win-21 Casting NULL to DWORD and dwVal to PBYTE

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;

			case REG_MULTI_SZ:

				paReturnArray = PA_GetVariableParameter(params, 4);

				if (paReturnArray.uValue.fArray.fNbElements > 0){
					//Convert the 4D array into a null delimited string to be stored
					for (i = 1; i <= paReturnArray.uValue.fArray.fNbElements; i++)
					{
						arraySize += PA_GetTextInArray(paReturnArray, i, NULL) + 1;
					}

					newDataBuffer = malloc(arraySize + 1);
					memset(newDataBuffer, 0, arraySize + 1);
					pos = newDataBuffer;
					for (i = 1; i <= paReturnArray.uValue.fArray.fNbElements; i++)
					{
						len = PA_GetTextInArray(paReturnArray, i, NULL);
						element = malloc(len + 1);
						len = PA_GetTextInArray(paReturnArray, i, element);
						element[len] = '\0';

						memcpy(pos, element, len + 1);
						pos += len + 1;

						free(element);
					}

					retErr = RegSetValueEx(hOpenKey, regName, (DWORD)NULL, dwDataType, newDataBuffer, arraySize + 1); // WJF 6/21/16 Win-21 Casting NULL to DWORD
					free(newDataBuffer);
				}

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;

			case REG_EXPAND_SZ:
			case REG_SZ:

				len = (DWORD)PA_GetTextParameter(params, 4, NULL) + 1; // WJF 6/30/16 Win-21 Cast to DWORD
				newDataBuffer = malloc(len * sizeof(char));
				memset(newDataBuffer, 0, (len * sizeof(char)));
				len = (DWORD)PA_GetTextParameter(params, 4, (LPSTR)newDataBuffer); // WJF 6/24/16 Win-21 Cast to LPSTR // WJF 6/30/16 Win-21 Cast to DWORD
				newDataBuffer[len] = '\0';

				retErr = RegSetValueEx(hOpenKey, regName, (DWORD)NULL, dwDataType, newDataBuffer, len); // WJF 6/24/16 Win-21 Casting NULL to DWORD

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				free(newDataBuffer);

				break;

			case REG_QWORD: // WJF 8/31/15 #43731 Added Support for 64-bit QWORD
				value = PA_GetLongParameter(params, 4);
				val64 = value; // Force to 64-bit
				retErr = RegSetValueEx(hOpenKey, regName, (DWORD)NULL, dwDataType, (PBYTE)&val64, sizeof(val64)); // WJF 6/24/16 Win-21 Casting NULL to DWORD and casting to PBYTE

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;
			}
		}
	}

	RegCloseKey(hOpenKey);
	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
//
//  FUNCTION: sys_IsAppRunningAsService( PA_PluginParameters params, LONG_PTR selector )
//
//  PURPOSE:  Determine if the application is running as a service.
//
//	DATE:	  REB 1/12/11 #25587, contributed by Justin Carr
//
void sys_IsAppRunningAsService(PA_PluginParameters params)
{
	short serviceInd = 0;
	SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
	PSID pServiceSid = NULL;
	PSID pLocalSystemSid = NULL;
	BOOL bHasServiceSid;
	BOOL bHasLocalSystemSid;

	if (AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &pServiceSid)){
		if (CheckTokenMembership(NULL, pServiceSid, &bHasServiceSid)) {
			if (bHasServiceSid) {
				serviceInd = 1;
			}
			else if (AllocateAndInitializeSid(&siaNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pLocalSystemSid)) {
				if (CheckTokenMembership(NULL, pLocalSystemSid, &bHasLocalSystemSid)) {
					if (bHasLocalSystemSid) {
						serviceInd = 1;
					}
				}
			}
		}
	}

	if (pLocalSystemSid)
		FreeSid(pLocalSystemSid);

	if (pServiceSid)
		FreeSid(pServiceSid);

	PA_ReturnShort(params, serviceInd);
}

// ------------------------------------------------
//
//  FUNCTION: sys_CompareBLOBs( PA_PluginParameters params )
//
//  PURPOSE:  Compare two BLOBs and return 1 if they are equal and 0 if they are not.
//
//	DATE:	  // REB 11/9/12 TESTING
//
void sys_CompareBLOBs(PA_PluginParameters params)
{
	LONG returnValue = 0; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	LONG len1, len2; // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	char *BLOB1 = NULL;
	char *BLOB2 = NULL;

	len1 = PA_GetBlobParameter(params, 1, NULL);
	BLOB1 = malloc(len1);
	len1 = PA_GetBlobParameter(params, 1, BLOB1);

	len2 = PA_GetBlobParameter(params, 2, NULL);
	BLOB2 = malloc(len2);
	len2 = PA_GetBlobParameter(params, 2, BLOB2);

	if (len1 == len2){
		returnValue = memcmp(BLOB1, BLOB2, len1);
	}
	else{
		returnValue = -1;
	}

	free(BLOB1);
	free(BLOB2);

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	keyboardLLHook
//
// PURPOSE:		Hook to handle low level keyboard events.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
// WJF 6/30/21 Win-21 INT_PTR -> INT
LRESULT CALLBACK keyboardLLHook(INT code, WPARAM wParam, LPARAM lParam)
{
	KBDLLHOOKSTRUCT *pkh = (KBDLLHOOKSTRUCT *)lParam;
	BOOL bCtrlKeyDown = FALSE;
	BOOL bAltKeyDown = FALSE;
	BOOL bShiftKeyDown = FALSE;

	if (code == HC_ACTION) {
		bCtrlKeyDown = GetAsyncKeyState(VK_CONTROL) >> ((sizeof(SHORT)* 8) - 1);
		bShiftKeyDown = GetAsyncKeyState(VK_SHIFT) >> ((sizeof(SHORT)* 8) - 1);
		bAltKeyDown = pkh->flags & LLKHF_ALTDOWN;

		if ((pkh->vkCode == VK_ESCAPE && bCtrlKeyDown) ||					// Ctrl+Esc
			(pkh->vkCode == VK_TAB && bAltKeyDown) ||						// Alt+Tab
			(pkh->vkCode == VK_ESCAPE && bAltKeyDown) ||					// Alt+Esc
			(pkh->vkCode == VK_ESCAPE && bCtrlKeyDown && bShiftKeyDown) || // Ctrl+Shift+Esc
			(pkh->vkCode == VK_F4 && bAltKeyDown) ||						// Alt+F4
			(pkh->vkCode == VK_LWIN || pkh->vkCode == VK_RWIN))				// Start Menu
		{
			return 1;
		}
	}
	return CallNextHookEx(hookHandles.keyboardLLHook, code, wParam, lParam);
}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_GetFileVersionInfo
//
// PURPOSE:		Return file version information
//
// AMS 2/14/14 #36899
//
void sys_GetFileVersionInfo(PA_PluginParameters params)
{
	char *verData = NULL;
	char *file = NULL;
	DWORD verHandle = 0; // WJF 6/24/16 Win-21 NULL -> 0
	DWORD verSize = 0; // WJF 6/24/16 Win-21 NULL -> 0

	LONG_PTR ret = 0;
	LONG_PTR major = 0;
	LONG_PTR minor = 0;
	LONG_PTR rev = 0;
	LONG_PTR build = 0;

	UINT size = 0;
	LPBYTE *lpBuffer = NULL;

	file = getTextParameter(params, 1);

	verSize = GetFileVersionInfoSize(file, &verHandle);

	if (0 != verSize)
	{
		verData = malloc(verSize);
		if (GetFileVersionInfo(file, verHandle, verSize, verData))
		{
			ret = 1;
			if (VerQueryValue(verData, "\\", (VOID FAR* FAR*)&lpBuffer, &size))
			{
				if (size)
				{
					VS_FIXEDFILEINFO *verInfo = (VS_FIXEDFILEINFO *)lpBuffer;
					if (verInfo->dwSignature == 0xfeef04bd)
					{
						major = HIWORD(verInfo->dwFileVersionMS);
						minor = LOWORD(verInfo->dwFileVersionMS);
						build = HIWORD(verInfo->dwFileVersionLS);
						rev = LOWORD(verInfo->dwFileVersionLS);
					}
				}
			}
		}

		else
		{
			ret = GetLastError();
		}

		free(verData);
	}

	free(file);

	PA_SetLongParameter(params, 2, (LONG)major);
	PA_SetLongParameter(params, 3, (LONG)minor);
	PA_SetLongParameter(params, 4, (LONG)build);
	PA_SetLongParameter(params, 5, (LONG)rev);

	PA_ReturnLong(params, (LONG)ret);
}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_SendRawPrinterData
//
// PURPOSE:		Sends raw printer data directly to a printer. sys_PrintDirect2Driver
//
//
// AMS 12/5/14 #37816
//

void sys_SendRawPrinterData(PA_PluginParameters params){
	char *printerName = NULL;   // String to hold the printerName param ($1) // WJF 5/5/16 Win-16 Changed to a pointer
	char *data = NULL;      // String to hold the data param ($2) REB 6/5/08 #17022 Changed MAXBUF to MAXLABELBUF which is twice as big. // WJF 5/5/16 Win-16 Changed to a pointer
	char *origDefault;                // String to hold the original default printer
	BOOL ret;                          // Int to hold return value of functions // WJF 6/30/16 Win-21 LONG_PTR -> BOOL
	LONG iErrCode = 1;                 // Int to hold the error code. // WJF 6/30/16 Win-21 LONG_PTR -> LONG
	DWORD dwBytesNeeded;      // Holds size information // WJF 6/24/16 Win-21 ULONG_PTR -> DWORD

	BOOL     bStatus = FALSE;
	HANDLE     hPrinter = NULL;
	DOC_INFO_1 DocInfo;
	DWORD      dwJob = 0L;
	DWORD      dwBytesWritten = 0L;
	DWORD		dwSize = 0;

	// Set needed bytes to default value
	dwBytesNeeded = MAXLABELBUF; // REB 6/5/08 #17022 Changed MAXBUF to MAXLABELBUF

	// WJF 5/13/16 Win-16 Removed because it wasn't used
	// Set this to 255.
	//printerName_len = 255;

	// Get the function parameters.
	// WJF 5/5/16 Win-16
	dwSize = PA_GetTextParameter(params, 1, NULL);
	if (printerName = malloc(dwSize + 1)) {// WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
		dwSize = PA_GetTextParameter(params, 1, printerName);
	}
	else {
		PA_ReturnLong(params, -1);
		return;
	}

	// WJF 5/5/16 Win-16
	dwSize = PA_GetTextParameter(params, 2, NULL);
	if (data = malloc(dwSize + 1)) { // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
		dwSize = PA_GetTextParameter(params, 2, data);
	}
	else {
		PA_ReturnLong(params, -1);
		return;
	}

	// Allocate memory for Storing string for Original Default Printer & pBuf
	origDefault = malloc(dwBytesNeeded); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
	memset(origDefault, 0, dwBytesNeeded);

	// Get name of current Default Printer
	GetDefaultPrinter(origDefault, &dwBytesNeeded);

	// Set the new Default Printer to our label printer, with the name obtained from the registry
	ret = SetDefaultPrinter((char *)printerName);

	// We set the default printer just fine, now let's do the printing.
	if (ret != 0)
	{
		// Open a handle to the printer.
		bStatus = OpenPrinter(printerName, &hPrinter, NULL);
		if (bStatus)
		{
			// Fill in the structure with info about this "document."
			DocInfo.pDocName = (LPTSTR)("My Document");
			DocInfo.pOutputFile = NULL;
			DocInfo.pDatatype = (LPTSTR)("RAW");

			// Inform the spooler the document is beginning.
			dwJob = StartDocPrinter(hPrinter, 1, (LPBYTE)&DocInfo);
			if (dwJob > 0) {
				// Start a page.
				bStatus = StartPagePrinter(hPrinter);
				if (bStatus) {
					// Send the data to the printer.
					bStatus = WritePrinter(hPrinter, data, dwSize, &dwBytesWritten);
					EndPagePrinter(hPrinter);
				}
				// Inform the spooler that the document is ending.
				EndDocPrinter(hPrinter);
			}
			// Close the printer handle.
			ClosePrinter(hPrinter);
		}
		// Check to see if correct number of bytes were written.
		if (!bStatus || (dwBytesWritten != dwSize))
		{
			bStatus = FALSE;
			iErrCode = GetLastError();
		}
		else
		{
			bStatus = TRUE;
			iErrCode = 0;
		}
	}

	// WJF 5/5/16 Win-16
	if (printerName != NULL){
		free(printerName);
		printerName = NULL;
	}

	// WJF 5/5/16 Win-16
	if (data != NULL){
		free(data);
		data = NULL;
	}

	ret = SetDefaultPrinter(origDefault); // WJF 6/9/15 #40818

	free(origDefault); // WJF 6/5/15 #42792

	PA_ReturnLong(params, iErrCode);
}

/*
void sys_SendRawPrinterData(PA_PluginParameters params)
{
// 4D Parameters
char szPrinterName[255] = "";  // Text printer name
char szData[MAXLABELBUF] = "";  // Text printer data
DWORD dwCount = 0;  // Long printer data length
char szDocName[255] = "";  // Text document name

BOOL			bStatus = FALSE;
HANDLE			hPrinter = NULL;
DOC_INFO_1		DocInfo;
DWORD			dwJob = 0L;
DWORD			dwBytesWritten = 0L;
LONG_PTR		lpReturn = 0;
char			*origDefault;  // String to hold the original default printer
ULONG_PTR		ulBytesNeeded;      // Holds size information

// Set needed bytes to default value
ulBytesNeeded = MAXLABELBUF;

PA_GetTextParameter(params, 1, szPrinterName);
PA_GetTextParameter(params, 2, szData);
PA_GetLongParameter(params, 3, dwCount);
PA_GetTextParameter(params, 4, szDocName);

// Allocate memory for Storing string for Original Default Printer & pBuf
origDefault = (char *)malloc(ulBytesNeeded);
memset(origDefault, 0, ulBytesNeeded);

GetDefaultPrinter(origDefault, &ulBytesNeeded);

// Set the new Default Printer to our label printer, with the name obtained from the registry
lpReturn = SetDefaultPrinter((char *)szPrinterName);

if (lpReturn != 0)
{
// Open a handle to the printer.
bStatus = OpenPrinter(szPrinterName, &hPrinter, NULL);
if (bStatus) {
// Fill in the structure with info about this "document."
DocInfo.pDocName = (LPTSTR)szDocName;
DocInfo.pOutputFile = NULL;
DocInfo.pDatatype = (LPTSTR)("RAW");

// Inform the spooler the document is beginning.
dwJob = StartDocPrinter(hPrinter, 1, (LPBYTE)&DocInfo);
if (dwJob > 0) {
// Start a page.
bStatus = StartPagePrinter(hPrinter);
if (bStatus) {
// Send the data to the printer.
bStatus = WritePrinter(hPrinter, szData, dwCount, &dwBytesWritten);
EndPagePrinter(hPrinter);
}
// Inform the spooler that the document is ending.
EndDocPrinter(hPrinter);
}
// Close the printer handle.
ClosePrinter(hPrinter);
}
// Check to see if correct number of bytes were written.
if (!bStatus || (dwBytesWritten != dwCount)) {
bStatus = FALSE;
lpReturn = 1;
}
else {
bStatus = TRUE;
lpReturn = 0;
}
lpReturn = SetDefaultPrinter(origDefault);
}
PA_ReturnLong(params, lpReturn);
}
*/

//  FUNCTION: sys_setCursor(PA_PluginParameters params)
//
//  PURPOSE:	Sets the cursor based on the passed value
//
//  COMMENTS:
//
//	DATE:		WJF 4/10/15 #23512
/*
void sys_SetCursor(PA_PluginParameters params){
long lCursor = 0;

lCursor = PA_GetLongParameter(params, 1);

switch (lCursor)
{
case 1:
cursorHandle = LoadCursor(NULL, IDC_IBEAM);
cursorHandleSet = TRUE;
break;
case 2:
cursorHandle = LoadCursor(NULL, IDC_CROSS);
cursorHandleSet = TRUE;
break;
case 3:
cursorHandle = LoadCursor(NULL, IDC_SIZEALL);
cursorHandleSet = TRUE;
break;
case 4:
cursorHandle = LoadCursor(NULL, IDC_WAIT);
cursorHandleSet = TRUE;
break;
default:
cursorHandle = LoadCursor(NULL, IDC_ARROW);
cursorHandleSet = FALSE;
break;
}

SetClassLong(windowHandles.MDIhWnd, GCL_HCURSOR, NULL);
SetCursor(cursorHandle);

PA_ReturnLong(params, 0);
}*/

//  FUNCTION: sys_DeleteRegKey(PA_PluginParameters params)
//
//  PURPOSE:	Deletes a registry key
//
//  COMMENTS:
//
//	DATE:		WJF 4/14/15 #27474
void sys_DeleteRegKey(PA_PluginParameters params)
{
	HKEY hKey = 0;
	long baseKey = 0; // WJF 6/24/16 Win-21 short -> long
	char subKey[255];
	long errorCode = 0;

	baseKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, subKey);

	hKey = getRootKey(baseKey);

	if (hKey != 0)
	{
		errorCode = RegOpenKeyEx(hKey, NULL, 0, KEY_ALL_ACCESS, &hKey); // Open key

		if (errorCode == ERROR_SUCCESS){
			errorCode = RegDeleteKey(hKey, TEXT(subKey));
		}
		RegCloseKey(hKey); // Keys aren't deleted until they are closed
	}

	PA_ReturnLong(params, errorCode);
}

//  FUNCTION: sys_DeleteRegKey64(PA_PluginParameters params)
//
//  PURPOSE:	Deletes a registry key, used for 64-bit Windows
//
//  COMMENTS:	Passing non-1 values is the same as calling sys_DeleteRegKey on 64-bit
//
//	DATE:		WJF 4/14/15 #27474
/* WJF 6/12/15 #42964 Removed for now since RegDeleteKeyEx merely existing in the code causes Win32API to crash on 32bit XP
void sys_DeleteRegKey64(PA_PluginParameters params)
{
HKEY hKey = 0;
short baseKey = 0;
char subKey[255];
long errorCode = 0;
REGSAM regView;
long view = 0;

baseKey = PA_GetLongParameter(params, 1);
PA_GetTextParameter(params, 2, subKey);
view = PA_GetLongParameter(params, 3);

switch (view)
{
case 1:
regView = KEY_WOW64_64KEY;
break;
default:
regView = KEY_WOW64_32KEY;
}

hKey = getRootKey(baseKey);

if (errorCode != -1)
{
errorCode = RegOpenKeyEx(hKey, NULL, 0, KEY_ALL_ACCESS, &hKey); // Open Key
if (errorCode == ERROR_SUCCESS)
{
RegDeleteKeyEx(hKey, TEXT(subKey), regView, 0);
}
RegCloseKey(hKey); // Keys aren't deleted until they are closed
}

PA_ReturnLong(params, errorCode);
}*/

//  FUNCTION: sys_DeleteRegValue(PA_PluginParameters params)
//
//  PURPOSE:	Deletes a registry value
//
//  COMMENTS:
//
//	DATE:		WJF 4/14/15 #27474
void sys_DeleteRegValue(PA_PluginParameters params)
{
	HKEY hKey = 0;
	long baseKey = 0; // WJF 6/24/16 Win-21 short -> long
	char subKey[255];
	long errorCode = 0;
	char keyValue[255];

	baseKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, subKey);
	PA_GetTextParameter(params, 3, keyValue);

	hKey = getRootKey(baseKey);

	if (hKey != 0)
	{
		errorCode = RegOpenKeyEx(hKey, TEXT(subKey), 0, KEY_ALL_ACCESS, &hKey);

		if (errorCode == ERROR_SUCCESS){
			errorCode = RegDeleteValue(hKey, TEXT(keyValue));
		}
		RegCloseKey(hKey); // Values aren't deleted until the key is closed
	}

	PA_ReturnLong(params, errorCode);
}

//  FUNCTION:	gui_TakeScreenshot (PA_PluginParameters params)
//
//  PURPOSE:	Takes a screenshot of the desktop
//
//  COMMENTS:
//
//	DATE:		WJF 7/7/15 #43138

void gui_TakeScreenshot(PA_PluginParameters params, BOOL isEx){
	LONG_PTR				hWndIndex;
	RECT					rcClient;
	int						lError = 0;
	HDC						hdcScreen;
	HDC						hdcWindow;
	HDC						hdcMemDC;
	HBITMAP					hbmScreen;
	BITMAP					bmpScreen;
	DWORD					dwBmpSize;
	HANDLE					hDIB;
	char					*lpbitmap;
	HANDLE					hFile;
	DWORD					dwSizeofDIB;
	DWORD					dwBytesWritten;
	char					*filePath;
	DWORD					dwFilePathLength;
	BITMAPFILEHEADER		bmfHeader;
	BITMAPINFOHEADER		bi;
	HWND					hWnd;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array;

	dwFilePathLength = PA_GetTextParameter(params, 2, NULL);
	filePath = malloc(dwFilePathLength); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
	dwFilePathLength = PA_GetTextParameter(params, 2, filePath);

	if (isEx){ // WJF 9/16/15 #43731
		hWnd = handleArray_retrieve((DWORD)hWndIndex);
	}
	else {
		hWnd = (HWND)hWndIndex;
	}

	if (IsWindow(hWnd)) {
		// Get a screen DC and a DC for the window for which the handle was provided
		hdcScreen = GetDC(NULL);
		hdcWindow = GetDC(hWnd);

		// Create a compatible DC which is used in a BitBlt from the window DC
		hdcMemDC = CreateCompatibleDC(hdcWindow);

		if (hdcMemDC) {
			// Get the client area for size calculation
			GetClientRect(hWnd, &rcClient);
			// Adjust for caption bar and borders
			rcClient.top -= GetSystemMetrics(SM_CYCAPTION);
			rcClient.bottom += 5;
			rcClient.left -= 5;
			rcClient.right += 5;

			// Create a compatible bitmap from the Window DC
			hbmScreen = CreateCompatibleBitmap(hdcWindow, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);

			if (hbmScreen){
				// Select the compatible bitmap into the compatible memory DC.
				SelectObject(hdcMemDC, hbmScreen);

				// Bit block transfer into our compatible memory DC.
				if (BitBlt(hdcMemDC, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, hdcWindow, rcClient.left, rcClient.top, SRCCOPY)) {
					// Get the BITMAP from the HBITMAP
					GetObject(hbmScreen, sizeof(BITMAP), &bmpScreen);

					bi.biSize = sizeof(BITMAPINFOHEADER);
					bi.biWidth = bmpScreen.bmWidth;
					bi.biHeight = bmpScreen.bmHeight;
					bi.biPlanes = 1;
					bi.biBitCount = 32;
					bi.biCompression = BI_RGB;
					bi.biSizeImage = 0;
					bi.biXPelsPerMeter = 0;
					bi.biYPelsPerMeter = 0;
					bi.biClrUsed = 0;
					bi.biClrImportant = 0;

					dwBmpSize = ((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight;

					// Starting with 32-bit Windows, GlobalAlloc and LocalAlloc are implemented as wrapper functions that
					// call HeapAlloc using a handle to the process's default heap. Therefore, GlobalAlloc and LocalAlloc
					// have greater overhead than HeapAlloc.
					hDIB = GlobalAlloc(GHND, dwBmpSize);
					lpbitmap = (char *)GlobalLock(hDIB);

					// Gets the "bits" from the bitmap and copies them into a buffer
					// which is pointed to by lpbitmap.
					GetDIBits(hdcWindow, hbmScreen, 0, (UINT)bmpScreen.bmHeight, lpbitmap, (BITMAPINFO *)&bi, DIB_RGB_COLORS);

					// A file is created, this is where we will save the screen capture.
					hFile = CreateFile(filePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

					// Add the size of the headers to the size of the bitmap to get the total file size
					dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);

					// Offset to where the actual bitmap bits start.
					bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER)+(DWORD)sizeof(BITMAPINFOHEADER);

					// Size of the file
					bmfHeader.bfSize = dwSizeofDIB;

					// bfType must always be BM for Bitmaps
					bmfHeader.bfType = 0x4D42; //BM

					dwBytesWritten = 0;
					WriteFile(hFile, (LPSTR)&bmfHeader, sizeof(BITMAPFILEHEADER), &dwBytesWritten, NULL);
					WriteFile(hFile, (LPSTR)&bi, sizeof(BITMAPINFOHEADER), &dwBytesWritten, NULL);
					WriteFile(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, NULL);

					// Unlock and Free the DIB from the heap
					GlobalUnlock(hDIB);
					GlobalFree(hDIB);

					// Close the handle for the file that was created
					CloseHandle(hFile);
				}
				else {
					lError = 3;
				}

				DeleteObject(hbmScreen);
			}
			else {
				lError = 2;
			}

			DeleteObject(hdcMemDC);
		}
		else {
			lError = 1;
		}

		ReleaseDC(NULL, hdcScreen);
		ReleaseDC(hWnd, hdcWindow);
	}
	else {
		lError = 4;
	}

	free(filePath);

	PA_ReturnLong(params, lError);
}

//  FUNCTION:	handleArray_add (LONG_PTR hWND)
//
//  PURPOSE:	Adds a handle to the internal handle array
//
//  COMMENTS:
//
//	DATE:		WJF 9/1/15 #43731
//  WJF 6/24/16 Win-21 DWORD -> INT
INT handleArray_add(LONG_PTR hWND){
	int i = 0;
	BOOL hasEmptySlot = FALSE;
	DWORD dwResult = 0;

	// Wait for the mutex
	dwResult = WaitForSingleObject(hArrayMutex, 2000);

	if (dwResult == WAIT_OBJECT_0){
		__try{
			// Find first empty slot
			while (i < HANDLEARRAY_CAPACITY){
				if (handleArray[i] == 0){
					hasEmptySlot = TRUE;
					break;
				}
				else {
					i++;
				}
			}

			if (hasEmptySlot){
				handleArray[i] = hWND;
			}
		}
		__finally {
			ReleaseMutex(hArrayMutex);
		}

		if (hasEmptySlot){
			return i;
		}
		else {
			return -1;
		}
	}
	else {
		return -1;
	}
}

//  FUNCTION:	handleArray_init ()
//
//  PURPOSE:	Initializes the internal handle array and its mutex object
//
//  COMMENTS:
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_init(){
	for (int i = 0; i < HANDLEARRAY_CAPACITY; i++)
		handleArray[i] = 0;

	hArrayMutex = CreateMutex(NULL, FALSE, NULL);

	if (hArrayMutex == NULL){
		return GetLastError();
	}
	else {
		return ERROR_SUCCESS;
	}
}

//  FUNCTION:	handleArray_remove (PA_PluginParameters params)
//
//  PURPOSE:	Removes a handle from the internal handle array
//
//  COMMENTS:	gui_FreeHandle
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_remove(PA_PluginParameters params){
	LONG index = 0;
	PA_long32 errorCode = -1; // WJF 6/24/16 Win-21 DWORD - PA_long32

	index = PA_GetLongParameter(params, 1);

	if ((index >= 0) && (index < HANDLEARRAY_CAPACITY)){
		errorCode = WaitForSingleObject(hArrayMutex, 2000);
		if (errorCode == WAIT_OBJECT_0){
			__try{
				handleArray[index] = 0;
			}
			__finally {
				ReleaseMutex(hArrayMutex);
			}
		}
	}

	PA_ReturnLong(params, errorCode);

	return errorCode;
}

//  FUNCTION:	handleArray_free (PA_PluginParameters params)
//
//  PURPOSE:	"Frees" all handle in the internal handle array, setting their values to 0.
//
//  COMMENTS:
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_free(PA_PluginParameters params){
	DWORD errorCode = 0;

	errorCode = WaitForSingleObject(hArrayMutex, 2000);

	if (errorCode == WAIT_OBJECT_0){
		__try {
			for (int i = 0; i < HANDLEARRAY_CAPACITY; i++)
				handleArray[i] = 0;
		}
		__finally {
			ReleaseMutex(hArrayMutex);
		}
	}

	PA_ReturnLong(params, errorCode);

	return errorCode;
}

//  FUNCTION:	handleArray_retrieve (DWORD handleIndex)
//
//  PURPOSE:	Common method to return a handle from the handleArray
//
//  COMMENTS:
//
//	DATE:		WJF 9/16/15 #43731
HWND handleArray_retrieve(DWORD handleIndex){
	LONG_PTR handle = 0;

	if ((handleIndex >= 0) && (handleIndex < HANDLEARRAY_CAPACITY)){
		handle = handleArray[handleIndex];
	}

	return (HWND)handle;
}

//  FUNCTION:	gui_GetWindowEx (PA_PluginParameters params, HWND hWnd)
//
//  PURPOSE:	Finds a handle, adds it to the internal handle array, and returns the index
//
//  COMMENTS:
//
//	DATE:		WJF 9/15/15 #43731
void gui_GetWindowEx(PA_PluginParameters params, HWND hWnd)
{
	LONG_PTR			windowTitle_len;
	char				*windowTitle;
	long				returnValue = -1;
	LONG_PTR			windowHandle = 0;

	windowTitle_len = PA_GetTextParameter(params, 1, NULL) + 1;
	windowTitle = malloc(windowTitle_len * sizeof(char));
	memset(windowTitle, 0, (windowTitle_len * sizeof(char)));
	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';

	if (strcmp(windowTitle, "*") == 0) { // return the frontmost window
		windowHandle = (LONG_PTR)hWnd;
	}
	else {
		
		_strlwr_s(windowTitle, MAXBUF); // ZRW 4/12/17 WIN-39 using the more secure _s method; using MAXBUF since windowTitle is a pointer
		
		if ((strlen(windowTitle) == 0) && (windowHandles.MDIs_4DhWnd != NULL)) {
			windowHandle = (LONG_PTR)windowHandles.fourDhWnd;
		}
		else if ((strcmp(windowTitle, "mdi") == 0) && (windowHandles.MDIhWnd != NULL)) {  // ZRW 4/12/17 WIN-39 _strlwr(windowTitle) -> windowTitle
			windowHandle = (LONG_PTR)windowHandles.MDIhWnd;
		}
		else {
			windowHandle = (LONG_PTR)getWindowHandle(windowTitle, hWnd);
		}
		if (!windowHandle) {
			returnValue = -3;
		}
	}

	if (windowHandle){
		returnValue = handleArray_add(windowHandle);
	}

	free(windowTitle);

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	gui_GetWindowFrom4DWinEx (PA_PluginParameters params)
//
//  PURPOSE:	Finds a handle, adds it to the internal handle array, and returns the index
//
//  COMMENTS:
//
//	DATE:		WJF 9/15/15 #43731
void gui_GetWindowFrom4DWinEx(PA_PluginParameters params)
{
	LONG_PTR h4DWnd = 0;
	LONG_PTR windowHandle = 0;
	long returnValue = 0;

	h4DWnd = PA_GetLongParameter(params, 1);

	windowHandle = PA_GetHWND((PA_WindowRef)h4DWnd); // WJF 6/21/16 Win-19 Casting to PA_WindowRef

	returnValue = handleArray_add(windowHandle);

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	gui_SetForegroundWindow (PA_PluginParameters params)
//
//  PURPOSE:	Finds a handle, adds it to the internal handle array, and returns the index
//
//  COMMENTS:	Needed for Automated Testing
//
//	DATE:		WJF 9/15/15 #43731
void gui_SetForegroundWindow(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR			index = 0;
	BOOL				bResult = FALSE;
	long				returnValue = 0;
	HWND				hWnd = NULL;

	index = PA_GetLongParameter(params, 1);

	if (isEx){
		hWnd = handleArray_retrieve((DWORD)index);
	}
	else {
		hWnd = (HWND)index;
	}

	if (IsWindow(hWnd)){
		bResult = SetForegroundWindow(hWnd);
	}

	if (bResult){
		returnValue = 1;
	}

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	gui_SetFocusEx (PA_PluginParameters params)
//
//  PURPOSE:	Sets the focus to the specified window
//
//  COMMENTS:
//
//	DATE:		WJF 10/19/15 Win-3
void gui_SetFocusEx(PA_PluginParameters params){
	HWND hWnd = NULL;
	DWORD index = 0;
	DWORD targetThread = 0;
	DWORD thisThread = 0;
	LONG error = 1;

	index = PA_GetLongParameter(params, 1);

	hWnd = handleArray_retrieve(index);

	if (IsWindow(hWnd)){
		thisThread = GetCurrentThreadId();
		targetThread = GetWindowThreadProcessId(hWnd, 0);

		if (thisThread == targetThread){
			SetFocus(hWnd);
			error = 0;
		}
		else if (AttachThreadInput(thisThread, targetThread, TRUE)){
			SetFocus(hWnd);
			AttachThreadInput(thisThread, targetThread, FALSE);
			error = 0;
		}
	}

	PA_ReturnLong(params, error);
}

//  FUNCTION: fileEncryption(PA_PluginParameters params, BOOL bDecrypt)
//
//  PURPOSE:	Encrypts/Decrypts a file
//
//  COMMENTS:
//
//	DATE:		WJF 10/28/15 Win-4
void fileEncryption(PA_PluginParameters params, BOOL bDecrypt)
{
	HCRYPTPROV	hProv = 0;
	HCRYPTHASH	hHash = 0;
	HCRYPTKEY	hKey = 0;
	HANDLE		hSourceFile = NULL;
	HANDLE		hDestFile = NULL;
	CHAR		fileSource[MAX_PATH]; // WJF 4/18/16 Win-13 Pointer -> Array
	CHAR		fileDest[MAX_PATH]; // WJF 4/18/16 Win-13 Pointer -> Array
	DWORD		dwSize = 0;
	CHAR		pbPass[33] = "0"; // WJF 6/21/16 Win-21 BYTE TO CHAR
	DWORD		dwPassLength = 0;
	CHAR		IV[17] = "0"; // WJF 6/21/16 Win-21 BYTE TO CHAR
	DWORD		dwIVLength = 0;
	CHAR		tempIV[17] = "0"; // WJF 6/21/16 Win-21 BYTE TO CHAR
	DWORD		error = 0;
	LPCSTR		myContainer = "MyContainer";
	PBYTE		pbBuffer = NULL;
	DWORD		dwBlockLen = 0;
	DWORD		dwBufferLen = 0;
	DWORD		dwCount = 0;
	BOOL		fEOF = FALSE;
	LONG		returnCode = 1;
	PBYTE		pbBufferAlt = NULL; // SDL 10/2/17 WIN-53
	BOOL		bCopyAltBuffer = FALSE; // SDL 10/2/17 WIN-53
	DWORD		dwCountAlt = 0; // SDL 10/2/17 WIN-53

	__try {
		// WJF 4/18/16 Win-13 Removed
		//dwSize = PA_GetTextParameter(params, 1, NULL);
		//
		//if (!(fileSource = (CHAR *)malloc(dwSize))){
		//	__leave;
		//}

		dwSize = PA_GetTextParameter(params, 1, fileSource);

		// WJF 4/18/16 Win-13 Removed
		//dwSize = PA_GetTextParameter(params, 2, NULL);
		//
		//if (!(fileDest = (CHAR *)malloc(dwSize))){
		//	__leave;
		//}

		dwSize = PA_GetTextParameter(params, 2, fileDest);

		dwPassLength = PA_GetTextParameter(params, 3, pbPass);

		if (dwPassLength > 32) {
			__leave;
		}

		dwIVLength = PA_GetTextParameter(params, 4, tempIV);

		// Clean up the IV input
		for (DWORD i = 0; i < 16; i++){ // WJF 6/24/16 Win-21 int -> DWORD
			if (i <= dwIVLength){
				if (tempIV[i] == '\0'){
					IV[i] = '0';
				}
				else {
					IV[i] = tempIV[i];
				}
			}
			else {
				IV[i] = '0';
			}
		}

		// Open the source file
		hSourceFile = CreateFile(fileSource, FILE_READ_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hSourceFile == INVALID_HANDLE_VALUE){
			__leave;
		}

		// Open the destination file
		hDestFile = CreateFile(fileDest, FILE_WRITE_DATA, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hDestFile == INVALID_HANDLE_VALUE){
			__leave;
		}

		// Get security provider
		if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))){
			error = GetLastError();
			if (error == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		// Create hash object
		if (!(CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))){
			__leave;
		}

		// Hash the password
		if (!(CryptHashData(hHash, (PBYTE)pbPass, dwPassLength, 0))){ // WJF 6/24/16 Win-21 Casting to PBYTE
			__leave;
		}

		// Derive the key from the hashed password
		if (!(CryptDeriveKey(hProv, CALG_AES_256, hHash, CRYPT_EXPORTABLE, &hKey))){
			__leave;
		}

		// Destroy the hash object
		if (!(CryptDestroyHash(hHash))){
			__leave;
		}
		else {
			hHash = 0;
		}

		// Set IV
		if (!(CryptSetKeyParam(hKey, KP_IV, (PBYTE)IV, 0))){ // WJF 6/24/16 Win-21 Removed unneccessary addressof operator and casting to PBYTE
			__leave;
		}

		dwBlockLen = 1000 - 1000 % AES_BLOCK_SIZE;

		if (bDecrypt)
		{
			dwBufferLen = dwBlockLen;
		}
		else {
			dwBufferLen = dwBlockLen + AES_BLOCK_SIZE;
		}

		if (!(pbBuffer = malloc(dwBufferLen))){ // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
			__leave;
		}

		// SDL 10/2/17 WIN-53
		if (!(pbBufferAlt = malloc(dwBufferLen))){ 
			__leave;
		}

		do{
			if (bCopyAltBuffer){ // SDL 10/2/17 WIN-53 If we held onto the alternate buffer, copy it into the primary instead of reading from the file again
				memcpy_s(pbBuffer, dwBufferLen, pbBufferAlt, dwCountAlt);
				bCopyAltBuffer = FALSE;
				dwCount = dwCountAlt;
			}
			else{
				if (!ReadFile(hSourceFile, pbBuffer, dwBlockLen, &dwCount, NULL)){
					__leave;
				}
			}

			if (dwCount < dwBlockLen){
				fEOF = TRUE;
			}

			if (bDecrypt && !fEOF){ // SDL 10/2/17 WIN-53 Decryption needs a second buffer to determine if we are truly at the end or not
				if (!ReadFile(hSourceFile, pbBufferAlt, dwBlockLen, &dwCountAlt, NULL)){
					__leave;
				}
					
				if (dwCountAlt == 0){ // There was nothing left in the file after the first buffer. 
					fEOF = TRUE; // The first buffer contains everything. Set this to true for the first buffer
				}
				else{
					bCopyAltBuffer = TRUE; // We'll decrypt and write out the primary buffer first, then copy the alternate buffer into the primary at the top.
				}
			}

			if (bDecrypt){
				if (!CryptDecrypt(hKey, 0, fEOF, 0, pbBuffer, &dwCount)){ 
					__leave;
				}

			}
			else {
				if (!CryptEncrypt(hKey, (HCRYPTHASH)NULL, fEOF, 0, pbBuffer, &dwCount, dwBufferLen)){ // WJF 6/21/16 Win-21 Casting NULL to HCRYPTHASH
					__leave;
				}
			}

			if (!WriteFile(hDestFile, pbBuffer, dwCount, &dwCount, NULL)){ 
				__leave;
			}
			
		} while (!fEOF);

		returnCode = ERROR_SUCCESS;
	}
	__finally{
		if (hSourceFile){
			CloseHandle(hSourceFile);
		}

		if (hDestFile){
			CloseHandle(hDestFile);
		}

		if (pbBuffer){
			free(pbBuffer);
			pbBuffer = NULL;
		}

		// SDL 10/2/17 WIN-53
		if (pbBufferAlt){
			free(pbBufferAlt);
			pbBufferAlt = NULL;
		}

		// WJF 4/18/16 Win-13 Removed
		//if (fileSource){
		//	free(fileSource);
		//	fileSource = NULL;
		//}
		//
		//if (fileDest){
		//	free(fileDest);
		//	fileDest = NULL;
		//}

		if (hKey) {
			CryptDestroyKey(hKey);
			hKey = 0;
		}

		if (hHash) {
			CryptDestroyHash(hHash);
			hHash = 0;
		}

		if (hProv){
			CryptReleaseContext(hProv, 0);
			hProv = 0;
		}

		PA_ReturnLong(params, returnCode);
	}
}

//  FUNCTION: sys_HashText(PA_PluginParameters params)
//
//  PURPOSE:	Hashes text and returns it
//
//  COMMENTS:
//
//	DATE:		WJF 10/28/15 Win-4
void sys_HashText(PA_PluginParameters params){
	LPSTR		lpInput = NULL;
	DWORD		dwSize = 0;
	LONG		lAlgorithm = 0;
	ALG_ID		algorithm = 0;
	CHAR		provider[64] = "";
	DWORD		provType = 0;
	HCRYPTPROV	hProv = 0;
	HCRYPTHASH	hHash = 0;
	DWORD		error = 0;
	LPCSTR		myContainer = "MyContainer";
	LONG		returnCode = 1;
	BYTE		*pbData = NULL;
	DWORD		dwDataSize = 0;
	DWORD		dwCount = 0;
	LPSTR		lpOutput = NULL;
	CHAR        *pOutput = NULL;
	DWORD		dwOutSize = 0;

	__try{
		dwSize = PA_GetTextParameter(params, 1, NULL);

		if (!(lpInput = malloc(dwSize + 1))){ // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
			__leave;
		}

		dwSize = PA_GetTextParameter(params, 1, lpInput);

		lAlgorithm = PA_GetLongParameter(params, 2);

		switch (lAlgorithm){
		case 0:
			algorithm = CALG_MD5;
			strcpy_s(provider, sizeof(provider), MS_DEF_PROV);  // ZRW 3/23/17 WIN-39 64 -> sizeof(provider)
			provType = PROV_RSA_FULL;
			break;
		case 1:
			algorithm = CALG_SHA1;
			strcpy_s(provider, sizeof(provider), MS_DEF_PROV);  // ZRW 3/23/17 WIN-39 64 -> sizeof(provider)
			provType = PROV_RSA_FULL;
			break;

		case 2:
			algorithm = CALG_SHA_256;
			strcpy_s(provider, sizeof(provider), MS_ENH_RSA_AES_PROV);  // ZRW 3/23/17 WIN-39 64 -> sizeof(provider)
			provType = PROV_RSA_AES;
			break;

		case 3:
			algorithm = CALG_SHA_384;
			strcpy_s(provider, sizeof(provider), MS_ENH_RSA_AES_PROV);  // ZRW 3/23/17 WIN-39 64 -> sizeof(provider)
			provType = PROV_RSA_AES;
			break;

		case 4:
			algorithm = CALG_SHA_512;
			strcpy_s(provider, sizeof(provider), MS_ENH_RSA_AES_PROV);  // ZRW 3/23/17 WIN-39 64 -> sizeof(provider)
			provType = PROV_RSA_AES;
			break;

		default:
			__leave;
		}

		// Get security provider
		if (!(CryptAcquireContext(&hProv, myContainer, provider, provType, CRYPT_NEWKEYSET))){
			error = GetLastError();
			if (error == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, provider, provType, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		// Create hash object
		if (!(CryptCreateHash(hProv, algorithm, 0, 0, &hHash))){
			__leave;
		}

		// Hash the password
		if (!(CryptHashData(hHash, (PBYTE)lpInput, dwSize, 0))){ // WJF 6/24/16 Win-21 Casting to PBYTE
			__leave;
		}

		// Get the size of the hash
		dwCount = sizeof(DWORD);
		if (!(CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&dwDataSize, &dwCount, 0))){
			__leave;
		}

		// Allocate the buffer
		if (!(pbData = malloc(dwDataSize))){ // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
			__leave;
		}

		// Get the hash value
		if (!(CryptGetHashParam(hHash, HP_HASHVAL, pbData, &dwDataSize, 0))){
			__leave;
		}

		dwOutSize = 2 * dwDataSize + 1;
		lpOutput = malloc(dwOutSize); // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
		pOutput = lpOutput;
		for (DWORD i = 0; i < dwDataSize; i++){ // WJF 6/24/16 Win-21 int -> DWORD
			pOutput += sprintf_s(pOutput, MAXBUF, "%02X", pbData[i]);  // ZRW 4/24/17 WIN-39 sprintf -> sprintf_s
			//pOutput += sprintf(pOutput, "%02X", pbData[i]);  // ZRW 4/24/17 WIN-39 sprintf -> sprintf_s
		}

		returnCode = ERROR_SUCCESS;
	}
	__finally {
		if (hHash) {
			CryptDestroyHash(hHash);
			hHash = 0;
		}

		if (hProv){
			CryptReleaseContext(hProv, 0);
			hProv = 0;
		}

		if (lpInput){
			free(lpInput);
			lpInput = NULL;
		}

		if (lpOutput){
			PA_SetTextParameter(params, 3, lpOutput, dwOutSize);
			free(lpOutput);
			lpOutput = NULL;
		}

		if (pbData){
			free(pbData);
			pbData = NULL;
		}

		PA_ReturnLong(params, returnCode);
	}
}

//  FUNCTION: textEncryption(PA_PluginParameters params, BOOL bDecrypt)
//
//  PURPOSE:	Encrypts/Decrypts a message in AES
//
//  COMMENTS:	Rewrote with updated practices and merged decrypt/encrypt into one method
//
//	DATE:		WJF 10/29/15 Win-4
void textEncryption(PA_PluginParameters params, BOOL bDecrypt)
{
	HCRYPTPROV	hProv = 0;
	HCRYPTHASH	hHash = 0;
	HCRYPTKEY	hKey = 0;
	LPSTR		pbBuffer = NULL; // WJF 6/13/16 Win-17 Initializing this to NULL now // WJF 6/24/16 Win-21 PBYTE to LPSTR
	DWORD		dwSize = 0;
	LPSTR		pbMessage = NULL; // WJF 6/24/16 Win-21 PBYTE to LPSTR
	CHAR		pbPass[33] = "0"; // WJF 6/24/16 Win-21 BYTE TO CHAR
	DWORD		dwPassLength = 0;
	DWORD		BUFFER_SIZE = 0;
	CHAR		IV[17] = "0"; // WJF 6/24/16 Win-21 BYTE TO CHAR
	DWORD		dwIVLength;
	CHAR		tempIV[17] = "0"; // WJF 6/24/16 Win-21 BYTE TO CHAR
	DWORD		error = 0;
	LPCSTR		myContainer = "MyContainer";

	__try{
		dwSize = PA_GetTextParameter(params, 1, pbMessage);

		if (!(pbMessage = malloc(dwSize + 1))){ // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
			__leave;
		}

		dwSize = PA_GetTextParameter(params, 1, pbMessage);

		dwPassLength = PA_GetTextParameter(params, 2, pbPass);

		if (dwPassLength > 32) {
			__leave;
		}

		dwIVLength = PA_GetTextParameter(params, 3, tempIV);

		for (DWORD i = 0; i < 16; i++){ // WJF 6/24/16 Win-21 int -> DWORD
			if (i <= dwIVLength){
				if (tempIV[i] == '\0'){
					IV[i] = '0';
				}
				else {
					IV[i] = tempIV[i];
				}
			}
			else {
				IV[i] = '0';
			}
		}

		// Clean decryption input
		if (bDecrypt){
			for (size_t i = 0; i < strlen(pbMessage); i++){ // WJF 6/24/16 Win-21 int -> size_t
				if (pbMessage[i] <= 32) {
					memmove(&pbMessage[i], &pbMessage[i + 1], strlen(pbMessage) - i);
					dwSize--;
					i--;
				}
			}
		}

		// Get security provider
		if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))){
			error = GetLastError();
			if (error == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		// Create hash object
		if (!(CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))){
			__leave;
		}

		// Hash the password
		if (!(CryptHashData(hHash, (PBYTE)pbPass, dwPassLength, 0))){ // WJF 6/24/16 Win-21 Casting to PBYTE
			__leave;
		}

		// Derive the key from the hashed password
		if (!(CryptDeriveKey(hProv, CALG_AES_256, hHash, CRYPT_NO_SALT, &hKey))){
			__leave;
		}

		// Destroy the hash object
		if (!(CryptDestroyHash(hHash))){
			__leave;
		}
		else {
			hHash = 0;
		}

		if (!(CryptSetKeyParam(hKey, KP_IV, (PBYTE)IV, 0))){ // WJF 6/24/16 Win-21 Removed unneccessary addressof operator and casting to PBYTE
			__leave;
		}

		if (bDecrypt){
			BUFFER_SIZE = dwSize + 1;
		}
		else {
			BUFFER_SIZE = ((dwSize + AES_BLOCK_SIZE) / (AES_BLOCK_SIZE))*AES_BLOCK_SIZE;
		}

		pbBuffer = malloc(BUFFER_SIZE); // Allocate to AES block size // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices

		strncpy_s(pbBuffer, BUFFER_SIZE, pbMessage, dwSize); // WJF 6/29/16 Win-18 memcpy_s -> strncpy_s

		if (bDecrypt){
			pbBuffer = (LPSTR)base64_decode(pbBuffer, dwSize, (size_t *)&dwSize); // Decode from base64 // WJF 6/24/16 Win-21 Cast to LPSTR and size_t *
			// Decrypt the message
			if (!(CryptDecrypt(hKey, 0, TRUE, 0, (PBYTE)pbBuffer, &dwSize))){ // WJF 6/24/16 Win-21 Cast to PBYTE
				__leave;
			}
			else { // WJF 6/29/16 Win-18
				pbBuffer[dwSize] = '\0';
			}
		}
		else {
			// Encrypt the message
			if (!(CryptEncrypt(hKey, 0, TRUE, 0, (PBYTE)pbBuffer, &dwSize, BUFFER_SIZE))) { // WJF 6/24/16 Win-21 Cast to PBYTE
				__leave;
			}
		}

		if (!bDecrypt){
			pbBuffer = base64_encode((PBYTE)pbBuffer, dwSize, (size_t *)&dwSize); // Encode to Base64  // WJF 6/24/16 Win-21 Cast to PBYTE and size_t
		}
	}
	__finally {
		if (hKey) {
			CryptDestroyKey(hKey);
			hKey = 0;
		}

		if (hHash) {
			CryptDestroyHash(hHash);
			hHash = 0;
		}
		if (hProv){
			CryptReleaseContext(hProv, 0);
			hProv = 0;
		}

		if (pbBuffer){
			PA_ReturnText(params, pbBuffer, dwSize);
			free(pbBuffer);
			pbBuffer = NULL;
		}
		else { // WJF 6/13/16 Win-17
			PA_ReturnText(params, "", 0);
		}

		if (pbMessage){
			free(pbMessage);
			pbMessage = NULL;
		}
	}
}

//  FUNCTION:   sys_GetDiskFreeSpace (PA_PluginParameters params)
//
//  PURPOSE:	Returns the amount of free space left on the specified volume
//
//  COMMENTS:	Implements GetDiskFreeSpaceEx
//
//	DATE:		WJF 11/2/15 Win-6
void sys_GetDiskFreeSpace(PA_PluginParameters params){
	CHAR			directoryPath[MAX_PATH];
	LONG_PTR		pathSize = 0;
	ULARGE_INTEGER	ulintFreeBytes;
	LONG			returnCode = 1;
	LONG			lResult = -1;

	pathSize = PA_GetTextParameter(params, 1, directoryPath);

	if (GetDiskFreeSpaceEx(directoryPath, NULL, NULL, &ulintFreeBytes)){
		returnCode = ERROR_SUCCESS;
		lResult = (LONG)((ulintFreeBytes.QuadPart) / (1024 * 1024 * 1024)); // WJF 6/24/16 Win-21 Pow -> 1024 * 1024 * 1024 and casting to LONG
	}

	PA_SetLongParameter(params, 2, lResult);

	PA_ReturnLong(params, returnCode);
}

//  FUNCTION:   killProcessByName(const char * processName, LONG_PTR lMode, BOOL bCleanFirst)
//
//  PURPOSE:	Kills a process by name
//
//  COMMENTS:	Moved to common method, Originally by MWD
//
//	DATE:		WJF 12/17/15 Win-7
LONG killProcessByName(const char * processName, LONG_PTR lMode, BOOL bOrigCleanFirst){
	LONG returnCode = 0;

	HANDLE hProcessSnap;				// Handle to the process snapshot

	HANDLE hProcess;					// Handle to the process itself

	PROCESSENTRY32 pe32;				// ProcessEntry to get info about processes

	BOOL bCleanFirst = FALSE;			// Boolean to see if we should try to cleanly close the app
	// before killing it mercilessly

	BOOL bDone = FALSE;					// This will keep track of whether or not we are finished looping through processes.

	// Take a snapshot of all processes in the system.
	// If we fail, return the error code
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap == INVALID_HANDLE_VALUE)
	{
		returnCode = GetLastError();
		return returnCode;
	}

	// Set the size of the structure before using it.
	pe32.dwSize = sizeof(PROCESSENTRY32);

	// Retrieve information about the first process,
	// If we can't do it, then return the error code
	if (!Process32First(hProcessSnap, &pe32))
	{
		CloseHandle(hProcessSnap);     // Must clean up the snapshot object!
		returnCode = GetLastError();
		return returnCode;
	}

	// Now walk the snapshot of processes, and
	// display information about each process in turn
	do
	{
		// Check the name
		if (strcmp(pe32.szExeFile, processName) == 0)
		{
			bCleanFirst = bOrigCleanFirst;
			// Get the process
			// We need to make sure that we have the TERMINATE right
			hProcess = OpenProcess(SYNCHRONIZE | PROCESS_TERMINATE, FALSE, pe32.th32ProcessID);

			// Couldn't get the process
			// Clean up the handle
			// and return the error
			if (hProcess == NULL) {
				CloseHandle(hProcessSnap);
				returnCode = GetLastError();
				return returnCode;
			}

			if (bCleanFirst)
			{
				// TerminateClean() posts WM_CLOSE to all windows whose PID
				// matches your process's.
				EnumWindows((WNDENUMPROC)TerminateClean, (LPARAM)pe32.th32ProcessID);

				if (WaitForSingleObject(hProcess, 500) != WAIT_OBJECT_0)
				{
					bCleanFirst = TRUE;
				}
			}

			if (!bCleanFirst)
			{
				// Kill the process
				if (TerminateProcess(hProcess, 1)) {
					;
					// Success!
					// If we're in mode 1 then we are finished
					// If not, then we will need to keep going
					if (lMode == 1) {
						bDone = TRUE;
					} // end
				}
				else {
					// Fail!
					// Clean up and return the error
					CloseHandle(hProcess);
					CloseHandle(hProcessSnap);
					returnCode = GetLastError();
					return returnCode;
				}
			}

			// Close our handle
			CloseHandle(hProcess);
		} // end if
		Process32Next(hProcessSnap, &pe32); // WJF 6/2/15 #42839 Moved out of while condition
	} while ((GetLastError() != 18) && (!bDone)); // WJF 6/2/15 #42839 Added GetLastError Check, corrected logical or syntax, and added inversion to bDone

	// Close the handle and return success
	CloseHandle(hProcessSnap);

	returnCode = (-1 * bCleanFirst);

	return returnCode;
}

//  FUNCTION:   sys_ProcessStart(PA_PluginParameters params)
//
//  PURPOSE:	Starts a process synchronously, unlike sys_ShellExecute
//
//  COMMENTS:
//
//	DATE:		WJF 4/20/16 Win-14
void sys_ProcessStart(PA_PluginParameters params){
	SHELLEXECUTEINFO proc;
	char applicationPath[MAX_PATH];
	char *parameters = NULL;
	DWORD dwSize = 0;
	BOOL bSuccess = FALSE;
	DWORD dwExitCode = 0;

	dwSize = PA_GetTextParameter(params, 1, applicationPath);

	dwSize = PA_GetTextParameter(params, 2, NULL);

	if (parameters = malloc(dwSize + 1)) { // WJF 7/13/16 Win-21 Removed typecasting on malloc to follow C best practices
		dwSize = PA_GetTextParameter(params, 2, parameters);
	}

	proc.cbSize = sizeof(SHELLEXECUTEINFO);
	proc.fMask = SEE_MASK_NOCLOSEPROCESS;
	proc.hInstApp = NULL;
	proc.hwnd = windowHandles.fourDhWnd;
	proc.lpDirectory = NULL;
	proc.nShow = SW_HIDE;
	proc.lpVerb = NULL;
	proc.lpParameters = parameters;
	proc.lpFile = applicationPath;

	if (ShellExecuteEx(&proc)) {
		PA_YieldAbsolute();
		PA_YieldAbsolute();
		PA_YieldAbsolute();

		do {
			bSuccess = GetExitCodeProcess(proc.hProcess, &dwExitCode);
			PA_YieldAbsolute();
		} while ((dwExitCode == STILL_ACTIVE) && (bSuccess));
	}

	if (parameters) {
		free(parameters);
		parameters = NULL;
		proc.lpParameters = NULL;
	}

	PA_ReturnLong(params, dwExitCode);
}

//  FUNCTION:   sys_IsWow64Process(PA_PluginParameters params)
//
//  PURPOSE:	Determines whether or not the current process is a WOW64 process (The operating system is 64-bit)
//
//  COMMENTS:	
//
//	DATE:		WJF 7/22/16 Win-26
void sys_IsWow64Process(PA_PluginParameters params)
{
	BOOL		bSuccess = FALSE;
	BOOL		bWOW64 = FALSE;
	HANDLE		hCurrentProcess = NULL;

	hCurrentProcess = GetCurrentProcess();

	bSuccess = IsWow64Process(hCurrentProcess, &bWOW64);

	PA_SetLongParameter(params, 1, bWOW64);

	PA_ReturnLong(params, bSuccess);
}

//  FUNCTION:   sys_CryptGenRandom(PA_PluginParameters params)
//
//  PURPOSE:	Fills a buffer with cryptographically random bytes
//
//  COMMENTS:	
//
//	DATE:		WJF 8/30/16 Win-30
void sys_CryptGenRandom(PA_PluginParameters params)
{
	DWORD		dwNumBytes = 0;
	HCRYPTPROV	hProv = 0;
	DWORD		dwError = ERROR_SUCCESS;
	LPCSTR		myContainer = "MyContainer";
	BOOL		bSuccess = FALSE;
	PBYTE		pbRandomBytes = NULL;
	LPSTR		szByteHexString = NULL;
	DWORD		i = 0;
	DWORD		dwStrLen = 0;

	dwNumBytes = (DWORD)PA_GetLongParameter(params, 1);

	dwStrLen = (dwNumBytes * 2) + 1;

	__try {

		if (!(pbRandomBytes = malloc(dwNumBytes))){
			__leave;
		}

		if (!(szByteHexString = malloc(dwStrLen))){
			__leave;
		}

		if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))){
			dwError = GetLastError();
			if (dwError == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		bSuccess = CryptGenRandom(hProv, dwNumBytes, pbRandomBytes);

		if (bSuccess){
			for (i = 0; i < dwNumBytes; i++){
				sprintf_s(szByteHexString + i * 2, dwStrLen, "%02x", pbRandomBytes[i]);
			}
			szByteHexString[i * 2] = '\0';

			PA_SetTextParameter(params, 2, szByteHexString, dwStrLen);
		}

		CryptReleaseContext(hProv, 0);
	}
	__finally{
		PA_ReturnLong(params, bSuccess);
	}
}